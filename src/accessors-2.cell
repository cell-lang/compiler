type Context = null_context, Function, Procedure, Automaton, Database;

////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType] {
  [FnFamilyId -> SgnSet] signatures {
    signatures = merge_values([[family_id(fd.id) -> signature(fd)] : fd <- program.fndefs]);
    return [id -> preprocess_signatures(ss) : id, ss <- signatures];
  }


  [+AggrFunct] aggr_functs(PlainAggrFnId id, Nat extra_arity) {
    return nonempty([f : f <- aggr_functs(id, extra_arity, ?)]);

    [PlainAggrFnId, Nat, AggrFunct] aggr_functs =
      [plain_id(f.id), |f.extra_args|, f : f <- program.aggr_fn_defs];
  }


  (NeType*, Maybe[NeType]) procedure_signature(ProcSymbol name) {
    if builtin_procedures_signatures(name, *):
      return builtin_procedures_signatures[name];
    else
      proc = procs_by_name[name];
      return ((a.type : a <- proc.args), proc.res_type);
    ;

    [ProcSymbol -> Procedure] procs_by_name = [p.id -> p : p <- program.proc_defs];
  }


  SgnSet method_signatures(<AutoSymbol, DBSymbol> type, MethodSymbol name, Nat arity) {
    return signatures[type][(name, arity)];

    [<AutoSymbol, DBSymbol> -> [(MethodSymbol, Nat) -> SgnSet]] signatures = [
        auto_or_db.name -> {
          sgns = merge_values([[(m.name, |m.args|) -> signature(m)] : m <- auto_or_db.methods]);
          return [n -> preprocess_signatures(ss) : n, ss <- sgns];
        }
      : auto_or_db <- program.auto_defs | auto_or_db <- program.data_bases
    ];
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit program : Program, context : Context {
  [ClsVar -> ClsType] closures =
    match (context)
      function()    = [v -> t : v, t <~ context.cls_args],
      _             = [];


  [PlainFnFamilyId -> [+ClsType]] constraints =
    match (context)
      function()  = merge_values([[fn_family_id(n, arity(s)) -> s] : n, ss <- context.constrs, s <- ss]),
      _           = [];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program : Program {
  [TypeName -> NeType] schema_and_typedefs {
    schema_typedefs = [type_name(schema_type_symbol(bare_id(db.name)), 0) -> state_type(db) : db <- program.data_bases];
    return program.typedefs & schema_typedefs;
  }

  Int+* int_seqs = rand_sort(retrieve_nested_int_seqs(program));

  [Int+ -> Nat] int_seqs_ids = merge(([s -> i] : s @ i <- int_seqs));
}
