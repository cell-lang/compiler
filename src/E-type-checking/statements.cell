implicit program : Program, typedefs : [TypeName -> NeType], context : Context, typed_vars : [StdVar -> NeType] {

  [TypeCheckingError] typecheck(Statement* stmts, Type exp_type, [EnvVar -> Type] env) {
    curr_env = env;
    for s <- stmts:
      errs = typecheck(s, exp_type, curr_env);
      return errs if errs != [];
      curr_env = update_env(s, curr_env);
    ;
    return [];
  }

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(Statement stmt, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck_without_annotations(stmt, exp_type, env);
    return [add_anchor_if_needed(e, stmt) : e <- errs];


    [TypeCheckingError] typecheck_without_annotations(Statement stmt, Type exp_type, [EnvVar -> Type] env) =
      assignment_stmt()   = typecheck_assignment_stmt(stmt.vars, stmt.value, env),
      return_stmt(e?)     = typecheck(e, exp_type, env),
      if_stmt()           = typecheck_if_stmt(stmt.cond, stmt.body, stmt.else, exp_type, env),
      loop_stmt(ss?)      = typecheck_loop_stmt(ss, exp_type, env),
      foreach_stmt()      = typecheck_foreach_stmt(stmt.iter, stmt.body, exp_type, env),
      for_stmt()          = { maybe_var = if stmt.var? then just(stmt.var) else nothing;
                              return typecheck_for_stmt(maybe_var, stmt.start_val,
                                stmt.end_val, stmt.end_val_incl, stmt.body, exp_type, env);
                            },
      let_stmt()          = typecheck_let_stmt(stmt.asgnms, stmt.body, exp_type, env),
      break_stmt          = [],
      fail_stmt()         = [],
      assert_stmt()       = typecheck(stmt.cond, type_bool, env),
      print_stmt(e?)      = typecheck(e, type_any, env),
      seq_update_stmt()   = typecheck_seq_update_stmt(stmt.seq_var, stmt.idx, stmt.value, env),

      send_msg_stmt()     = typecheck_send_msg_stmt(stmt.target, stmt.msg, env),
      try_update_stmt()   = typecheck_try_update_stmt(stmt.name, stmt.args, env),
      set_memb_var_stmt() = typecheck_set_memb_var_stmt(stmt.var, stmt.value, env),
      delete_stmt()       = typecheck_delete_stmt(stmt.var, stmt.args, env),
      insert_stmt()       = typecheck_insert_stmt(stmt.var, stmt.args, env),
      update_stmt()       = typecheck_standalone_insert_stmt(stmt.var, stmt.args, env),

      return_stmt         = [],
      proc_call_stmt()    = typecheck_proc_call_stmt(
                              if stmt.res_var? then just(stmt.res_var) else nothing,
                              stmt.proc_name, stmt.args, env
                            ),

      set_input_ctrl_stmt()         = typecheck_set_input_ctrl_stmt(stmt.var, stmt.input, stmt.value, env),
      clear_input_ctrl_stmt()       = [],
      set_elapsed_time_ctrl_stmt()  = typecheck_set_elapsed_time_ctrl_stmt(stmt.var, stmt.time, env),
      apply_ctrl_stmt()             = [],
      send_msg_ctrl_stmt()          = typecheck_send_msg_ctrl_stmt(stmt.res_var, stmt.db_var, stmt.msg, env),
      read_state_ctrl_stmt()        = [],
      restore_state_ctrl_stmt()     = typecheck_restore_state_ctrl_stmt(stmt.res_var, stmt.auto_var, stmt.state, env);
  }


  [TypeCheckingError] typecheck_seq_update_stmt(StdVar seq_var, Expr idx, Expr value, [EnvVar -> Type] env) {
    seq_var_errs = typecheck(seq_var, type_seq, env);
    idx_errs = typecheck(idx, integer, env);
    value_errs = typecheck(value, type_any, env);
    return seq_var_errs & idx_errs & value_errs;
  }


  [TypeCheckingError] typecheck_assignment_stmt(Var+ vars, Expr value, [EnvVar -> Type] env) {
    vars_types = (lookup(typed_vars, v, type_any) : v <- vars);
    exp_type = if |vars_types| == 1 then only(vars_types) else tuple_type(vars_types);
    return typecheck(value, exp_type, env);
  }


  [TypeCheckingError] typecheck_if_stmt(Expr cond, Statement+ body, Statement* else_body, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(cond, type_bool, env);
    return errs if errs != [];
    if_true_env, if_false_env = refine_env(cond, env);
    return typecheck(body, exp_type, if_true_env) &
           typecheck(else_body, exp_type, if_false_env);
  }


  [TypeCheckingError] typecheck_loop_stmt(Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    out_of_loop_vars = keys(env);
    entry_env = env;
    envs = (env);
    for 2:
      errs = typecheck(body, exp_type, entry_env);
      return errs if errs != [];
      exit_env = select_by_key(update_env(body, entry_env), out_of_loop_vars);
      return [] if not (v, t <- exit_env : not is_subset(t, entry_env[v]));
      entry_env = exit_env;
      envs = (envs | exit_env);
    ;
    return [loop_did_not_converge(2, bad_vars_history(envs))];
  }


  [TypeCheckingError] typecheck_foreach_stmt(CollValueIter iter, Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    nvars = |iter.vars|;
    exp_src_type = if nvars == 1 then type_seq else type_seq(type_tuple(nvars));
    errs_seq = typecheck(iter.src_expr, exp_src_type, env);
    return typecheck_loop_body(body, seq_loop_vars(iter, env), exp_type, env) if errs_seq == [];
    return errs_seq if iter.idx_var? or nvars > 3;

    if |iter.vars| == 1:
      errs_set = typecheck(iter.src_expr, type_set, env);
      if errs_set != []:
        ## BAD: THIS SHOULB BE DONE IN error-euristics.cell, NOT HERE
        errs_any = typecheck(iter.src_expr, ne_union_type([type_seq, type_set]), env);
        return if errs_any != [] then errs_any else errs_seq & errs_set;
      ;
      return typecheck_loop_body(body, set_loop_vars(iter, env), exp_type, env);

    elif |iter.vars| == 2:
      errs_rel = typecheck(iter.src_expr, type_bin_rel, env);
      if errs_rel != []:
        ## BAD: THIS SHOULB BE DONE IN error-euristics.cell, NOT HERE
        errs_any = typecheck(iter.src_expr, ne_union_type([type_seq, type_bin_rel]), env);
        return if errs_any != [] then errs_any else errs_seq & errs_rel;
      ;
      return typecheck_loop_body(body, bin_rel_loop_vars(iter, env), exp_type, env);

    else
      assert |iter.vars| == 3;
      errs_rel = typecheck(iter.src_expr, type_tern_rel, env);
      if errs_rel != []:
        ## BAD: THIS SHOULB BE DONE IN error-euristics.cell, NOT HERE
        errs_any = typecheck(iter.src_expr, ne_union_type([type_seq, type_tern_rel]), env);
        return if errs_any != [] then errs_any else errs_seq & errs_rel;
      ;
      return typecheck_loop_body(body, tern_rel_loop_vars(iter, env), exp_type, env);
    ;


    [TypeCheckingError] typecheck_loop_body(Statement+ body, [EnvVar -> Type] loop_vars, Type exp_type, [EnvVar -> Type] env) {
      out_of_loop_vars = keys(env);
      entry_env = env & loop_vars;
      envs = (env);
      for 2:
        errs = typecheck(body, exp_type, entry_env);
        return errs if errs != [];
        exit_env = select_by_key(update_env(body, entry_env), out_of_loop_vars);
        return [] if not (v, t <- exit_env : not is_subset(t, entry_env[v]));
        entry_env = exit_env & loop_vars;
        envs = (envs | exit_env);
      ;
      return [loop_did_not_converge(2, bad_vars_history(envs))];
    }
  }


  [TypeCheckingError] typecheck_for_stmt(Maybe[StdVar] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(start_val, integer, env) & typecheck(end_val, integer, env);
    return errs if errs != [];

    loop_vars = [
      value(maybe_var) ->
        loop_var_type(
          expr_type(start_val, env),
          expr_type(end_val, env),
          end_val_incl
        ) if maybe_var != nothing
    ];

    out_of_loop_vars = keys(env);

    entry_env = env & loop_vars;
    envs = (env);
    for 2:
      errs = typecheck(body, exp_type, entry_env);
      return errs if errs != [];
      exit_env = select_by_key(update_env(body, entry_env), out_of_loop_vars);
      return [] if not (v, t <- exit_env : not is_subset(t, entry_env[v]));
      entry_env = exit_env & loop_vars;
      envs = (envs | exit_env);
    ;

    return [loop_did_not_converge(2, bad_vars_history(envs))];
  }


  [TypeCheckingError] typecheck_let_stmt([ImplArg -> Expr] asgnms, Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    errs = union([typecheck(e, type_any, env) : v, e <- asgnms]);
    return errs if errs != [];
    env_delta = [v -> expr_type(e, env) : v, e <- asgnms];
    new_env = update(env, env_delta);
    return typecheck(body, exp_type, new_env); ## BUG BUG BUG (WHY?)
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck_send_msg_stmt(NestedDBVar target, Expr msg, [EnvVar -> Type] env) {
    db_type = var_type(target);
    msg_type = db_msg_type(db_type);
    return typecheck(msg, msg_type, env);
  }


  [TypeCheckingError] typecheck_try_update_stmt(UpdateSymbol name, Expr* args, [EnvVar -> Type] env) {
    errs = seq_union((typecheck(a, type_any, env) : a <- args));
    return errs if errs != [];
    args_types = (expr_type(a, env) : a <- args);
    db_type = this_db_symbol;
    sgns = update_signatures(db_type, name);
    agg_sgns = update_aggregate_signatures(db_type, name);
    for s <- rand_sort(sgns) & rand_sort(agg_sgns):
      return [] if all((is_subset(at, ft) : at, ft <- zip(args_types, s)));
    ;
    return [no_disp_db_update(name, args_types, sgns)];
  }


  [TypeCheckingError] typecheck_set_memb_var_stmt(MembVar var, Expr value, [EnvVar -> Type] env) {
    var_type = memb_var_type(var);
    return [] if typecheck(value, var_type, env) == [];
    errs = typecheck(value, type_any, env);
    return if errs != [] then errs else [unexpected_actual_type(expr_type(value, env), var_type)];
  }


  [TypeCheckingError] typecheck_delete_stmt(RelVar var, Maybe[Expr]+ args, [EnvVar -> Type] env) {
    errs = seq_union((typecheck(value(a), type_any, env) : a <- args, a != nothing));
    return errs if errs != [];
    args_types = (apply(a, expr_type($, env)) : a <- args);
    sgns = cast_database(context).rel_vars[var].signatures;
    for s <- rand_sort(sgns):
      return [] if all((at == nothing or not are_ptype_disjoint(value(at), ft) : at, ft <- zip(args_types, s)));
    ;
    return [no_matching_relvar(var, args_types, sgns)];
  }


  [TypeCheckingError] typecheck_insert_stmt(RelVar var, Expr+ args, [EnvVar -> Type] env) {
    return typecheck_standalone_insert_stmt(var, args, env);
  }


  [TypeCheckingError] typecheck_standalone_insert_stmt(RelVar var, Expr+ args, [EnvVar -> Type] env) {
    errs = seq_union((typecheck(a, type_any, env) : a <- args));
    return errs if errs != [];
    args_types = (expr_type(a, env) : a <- args);
    database = cast_database(context);
    sgns = database.rel_vars[var].signatures;
    agg_sgns = relvar_aggregated_signatures(database.name, var);
    for s <- rand_sort(sgns) & rand_sort(agg_sgns):
      return [] if all((is_subset(at, ft) : at, ft <- zip(args_types, s)));
    ;
    return [no_matching_relvar(var, (just(a) : a <- args_types), sgns)];
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck_proc_call_stmt(Maybe[StdVar] maybe_res_var, ProcSymbol proc_name, Expr* args, [EnvVar -> Type] env) {
    args_types, unused_var = procedure_signature(proc_name);
    return seq_union((typecheck(e, t, env) : e, t <- zip(args, args_types)));
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck_set_input_ctrl_stmt(LocAutoVar var, Atom input, Expr value, [EnvVar -> Type] env) {
    auto = automaton_by_id(var_type(var));
    input_type = auto.inputs[signal_var(input)].type;
    return typecheck(value, input_type, env);
  }


  [TypeCheckingError] typecheck_set_elapsed_time_ctrl_stmt(LocAutoVar var, Expr time, [EnvVar -> Type] env) {
    return typecheck(time, integer, env);
  }


  [TypeCheckingError] typecheck_send_msg_ctrl_stmt(StdVar res_var, LocDBVar db_var, Expr msg, [EnvVar -> Type] env) {
    db = automaton_by_id(var_type(db_var));
    msg_type = db_msg_type(var_type(db_var));
    return typecheck(msg, msg_type, env);
  }


  [TypeCheckingError] typecheck_restore_state_ctrl_stmt(StdVar res_var, LocDBVar auto_var, Expr state, [EnvVar -> Type] env) {
    return typecheck(state, type_map(atom_type, type_any), env);
  }


  [TypeCheckingError] typecheck_restore_state_ctrl_stmt(StdVar res_var, LocAutoVar auto_var, Expr state, [EnvVar -> Type] env) {
    auto = automaton_by_id(var_type(auto_var));
    return typecheck(state, state_type(auto), env);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  [+EnvVar -> Type+] bad_vars_history([EnvVar -> Type]+ envs) {
    fail if |envs| != 3;
    env0, env1, env2 = envs;
    vars = only([keys(e) : e <~ envs]);
    res = [v -> (e(v, !!) : e <- envs) : v <- vars, not is_subset(env2(v, !!), env1(v, !!))];
    return nonempty_map(res);
  }
}
