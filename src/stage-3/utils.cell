type CodeOutcome = fails, returns, breaks_loop, exits_block, falls_through;

type TargetHandlerId = unknown, HandlerId;

////////////////////////////////////////////////////////////////////////////////

<fails>         fails         = :fails;
<returns>       returns       = :returns;
<breaks_loop>   breaks_loop   = :breaks_loop;
<exits_block>   exits_block   = :exits_block;
<falls_through> falls_through = :falls_through;


[+CodeOutcome] code_outcomes(BasicInstr) = [:fails, falls_through];


[+CodeOutcome] code_outcomes(JumpInstr) =
  break_loop    = [breaks_loop],
  exit_block    = [exits_block],
  ret_val()     = [returns],
  terminate()   = [fails];


[+CodeOutcome] code_outcomes(CompInstr instr) =
  branch()            = nonempty(code_outcomes(instr.when_true) & code_outcomes(instr.when_false)),
  switch_on_nat()     = nonempty(union([code_outcomes(c) : c <- instr.cases])),
  symb_switch()       = nonempty(union([code_outcomes(right(c)) : c <- instr.cases]) & code_outcomes(instr.else)),
  repeat(is?)         = loop_outcomes(is),
  foreach()           = [if o == breaks_loop then falls_through else o : o <- code_outcomes(instr.body)],
  execute_block(is?)  = block_outcomes(is),
  try_block()         = { assert block_outcomes(instr.body) :: [<fails, falls_through>];
                          return [falls_through];
                        };


[+CodeOutcome] loop_outcomes(Instr+ body) {
  body_outcomes = code_outcomes(body);
  may_break = in(breaks_loop, body_outcomes);
  return nonempty((body_outcomes - [breaks_loop, falls_through]) & [if may_break then falls_through else fails]);
}


[+CodeOutcome] block_outcomes(Instr+ body) {
  body_outcomes = code_outcomes(body);
  may_exit = in(exits_block, body_outcomes);
  return nonempty((body_outcomes - [exits_block]) & [falls_through if may_exit]);
}


[+CodeOutcome] code_outcomes(Instr* instrs) {
  outcomes = [falls_through];
  for instr <- instrs {
    assert in(falls_through, outcomes);
    outcomes = (outcomes - [falls_through]) & code_outcomes(instr);
    break if not in(falls_through, outcomes);
  }
  return nonempty(outcomes);
}


Bool may_break(Instr+ loop_body) = in(breaks_loop, code_outcomes(loop_body));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[MembVar] updated_memb_vars(CompiledHandler handler) {
  return search_instrs(handler.body, updated_memb_vars);

  [MembVar] updated_memb_vars(Instr instr) =
    set_var()   = [corresponding_memb_var(instr.var) if instr.var :: PendingStateVar],
    _           = search_any_nested(instr, updated_memb_vars, []);
}


[ValueStoreId] value_stores_with_insertions(CompiledHandler handler) {
  return search_instrs(handler.body, value_stores_with_insertions);

  [ValueStoreId] value_stores_with_insertions(Instr instr) =
    init_value_store()              |
    cleanup_value_store()           |
    immediate_insert_or_add_ref()   = undefined,
    lookup_or_queue_insert_value()  = [instr.store],
    _                               = search_any_nested(instr, value_stores_with_insertions, []);
}


[TableVar] table_vars_with_insertions(CompiledHandler handler) {
  return search_instrs(handler.body, table_vars);

  [TableVar] table_vars(Instr instr) =
    init_table()                            |
    cleanup_table()                         |
    immediate_insert_tuple()                |
    column_insert_immediate()               = undefined,
    queue_insert_tuple()                    = [instr.table_var],
    column_insert_deferred()                = [instr.table_var],
    _                                       = search_any_nested(instr, table_vars, []);
}


[TableVar] table_vars_with_deletions(CompiledHandler handler) {
  return search_instrs(handler.body, table_vars);

  [TableVar] table_vars(Instr instr) =
    init_table()                            |
    cleanup_table()                         |
    immediate_insert_tuple()                |
    column_insert_immediate()               = undefined,
    queue_deletes()                         = [instr.table_var],
    column_insert_deferred()                = [instr.table_var if instr.forced], ## NOT SURE THERE'S ANY POINT IN DOING THIS
    _                                       = search_any_nested(instr, table_vars, []);
}


// ## THE RETURNED TYPE IS ACTUALLY MORE SPECIFIC THAN THAT
// [UpdateId] invoked_mutators(CompiledHandler handler) {
//   return search_instrs(handler.body, mutators);

//   [UpdateId] mutators(Instr instr) =
//     // try_update()  = [instr.update_id],
//     _             = search_any_nested(instr, mutators, []);
// }


[LinkedDBVar, TargetHandlerId] updated_dependees(CompiledHandler handler) {
  return [v, h : vh <- search_instrs(handler.body, dependees), (v?, h?) ?= vh];

  [(LinkedDBVar, TargetHandlerId)] dependees(Instr instr) =
    send_internal_msg() = [(instr.db_var, if instr.handler_id != nothing then value(instr.handler_id) else :unknown)],
    _                   = search_any_nested(instr, dependees, []);
}

////////////////////////////////////////////////////////////////////////////////

implicit block : StaticBlock {
  [HandlerId, MembVar] updated_memb_vars                      = [id, v : id h <- block.handlers, v <- updated_memb_vars(h)];
  [HandlerId, ValueStoreId] value_stores_with_insertions      = [id, vs : id h <- block.handlers, vs <- value_stores_with_insertions(h)];
  [HandlerId, TableVar] table_vars_with_insertions            = [id, v : id h <- block.handlers, v <- table_vars_with_insertions(h)];
  [HandlerId, TableVar] table_vars_with_deletions             = [id, v : id h <- block.handlers, v <- table_vars_with_deletions(h)];
  [HandlerId, LinkedDBVar, TargetHandlerId] updated_dependees = [id, d, t : id h <- block.handlers, d t <- updated_dependees(h)];

  // [UpdateId, UpdateId] call_graph_transitive_closure {
  //   shallow_graph = [id -> invoked_mutators(h) : id h <- block.handlers];
  //   deep_graph = transitive_closure(shallow_graph);
  //   return [s, t : s ts <- deep_graph, t <- ts];
  // }

  // [HandlerId, MembVar] updated_memb_vars {
  //   directly_touched = [id -> updated_memb_vars(h) : id h <- block.handlers];
  //   deep_call_map = call_graph_transitive_closure;
  //   indirectly_touched = [s, v : s t <- deep_call_map, v <- directly_touched(t)];
  //   return [u, v : u vs <- directly_touched, v <- vs | v <- indirectly_touched(u, ?)];
  // }
}

////////////////////////////////////////////////////////////////////////////////

[TableVar, TableVar] unary_table_mandatory_columns(StaticBlock block) =
  [t.master, v : v t <- block.tables, mandatory_column() ?= t];
