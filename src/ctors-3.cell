OptTagRecRepr opt_tag_rec_repr(Symbol t, Nat i) = opt_tag_rec_repr(tag: t, index: i);

LocVar lvar(Nat n)      = :lvar(n);

ElemVar evar(Nat id, <Nat, IntVar> i)   = evar(id: id, idx: i);
ElemVar evar(Nat id, IntVar v, Nat i)   = evar(id: id, idx: add(val1: v, val2: i));

CaptVar capt_var(Nat n) = :capt_var(n);

PendingInputVar pending_input_var(Atom id)  = :pending_input_var(id);
PendingStateVar pending_state_var(Atom id)  = :pending_state_var(id);

VecVar vvar(Nat n, NzNat s) = vvar(id: n, size: s);

LocBoolVar bvar(<Symbol, Nat> id) = :bvar(id);
BoolFnArg  bool_arg(Nat id)       = :bool_arg(id);
LocBoolVar bool_arg(Symbol id)    = :bvar(id);

QualBoolVar qual_bool_var(LocAutoVar av, MembBoolVar mv) = qual_bool_var(auto_var: av, memb_var: mv);

MembBoolVar cond_value_var(Nat n)             = :cond_value_var(n);
MembBoolVar cond_is_def_var(Nat n)            = :cond_is_def_var(n);

MembBoolVar watched_signal_up_to_date_var(Atom id)  = :watched_signal_up_to_date_var(id);

MembBoolVar up_to_date_var(BlockNodeId n)     = :up_to_date_var(n);

MembBoolVar is_new    = :is_new;

IntVar curr_time      = :curr_time;
IntVar update_time    = :update_time;

IntVar update_expr_index = :update_expr_index;

IntVar elapsed_time(LocAutoVar v) = :elapsed_time(v);

ProjdIntVar changed_output(<Nat, IntVar> i)  = changed_output(index: i);

LocIntVar ivar(<Symbol, Nat> id)  = :ivar(id);
IntFnArg  int_arg(Nat id)         = :int_arg(id);
LocIntVar int_arg(Symbol id)      = :ivar(id);

Int32Var ivar32(Nat n)                        = :ivar32(n);
Int32Var shadow_surr_var(StdVar v)            = :shadow_surr_var(v);
Int32Var shadow_array_size_var(Symbol s)      = :shadow_array_size_var(s);
Int32Var shadow_array_capacity_var(Symbol s)  = :shadow_array_capacity_var(s);

MembIntVar update_source_var(Atom n)                            = :update_source_var(n);
MembIntVar null_locks_count_var(Atom id)                        = :null_locks_count_var(id);
MembIntVar update_count_var(Nat l)                              = :update_count_var(l);
MembIntVar nodes_to_update_var(Nat l, <Nat, IntVar> i)          = nodes_to_update_var(level: l, index: i);
MembIntVar next_trigger_time_var(Atom a)                        = :next_trigger_time_var(a);
MembIntVar curr_time_slot_var(Atom a)                           = :curr_time_slot_var(a);
MembIntVar time_triggers_count_var                              = :time_triggers_count_var;
MembIntVar trigger_times_heap_var(<0..0> i)                     = :trigger_times_heap_var(i);
MembIntVar time_varying_cond_ids_heap_var(<0..0> i)             = :time_varying_cond_ids_heap_var(i);
MembIntVar last_update_time                                     = :last_update_time;
MembIntVar elapsed_time                                         = :elapsed_time;
MembIntVar changed_outputs_count                                = :changed_outputs_count;
MembIntVar nested_auto_int_var(NestedAutoVar av, MembIntVar mv) = nested_auto_int_var(auto_var: av, memb_var: mv);

LocFloatVar fvar(<Symbol, Nat> id)  = :fvar(id);
FloatFnArg  float_arg(Nat id)       = :float_arg(id);
LocFloatVar float_arg(Symbol id)    = :fvar(id);

LocOptTagRecVar opt_tag_rec_var(<Symbol, Nat> id, Symbol s, Nat i) = opt_tag_rec_var(id: id, tag: s, index: i);

OptTagRecFnArg  opt_tag_rec_fn_arg(Nat id, Symbol s, Nat i) = opt_tag_rec_fn_arg(id: id, tag: s, index: i);
LocOptTagRecVar opt_tag_rec_fn_arg(Symbol id, Symbol s, Nat i) = opt_tag_rec_var(id: id, tag: s, index: i);

ArrayVar avar(Nat id, LowLevelEltRepr r) = avar(id: id, repr: r);
ArrayVar shadow_array_var(Symbol id, LowLevelEltRepr r) = shadow_array_var(id: id, repr: r);

MembObjVar watched_signal_value_var(Atom id)                  = :watched_signal_value_var(id);

IntConst time_slot_length(AutoSymbol a, Atom id, IntExpr i) = time_slot_length(automaton: a, expr_id: id, time_slot: i);

MembIntVectVar nodes_to_update_vect_var(Nat l, NzNat s) = nodes_to_update_vect_var(level: l, size: s);
MembIntVectVar changed_outputs(NzNat s)                 = changed_outputs(size: s);

StreamVar svar(Nat n) = :svar(n);

SetItVar set_it_var(Nat n)          = :set_it_var(n);
SeqItVar seq_it_var(Nat n)          = :seq_it_var(n);
BinRelItVar bin_rel_it_var(Nat n)   = :bin_rel_it_var(n);
TernRelItVar tern_rel_it_var(Nat n) = :tern_rel_it_var(n);

TableItVar table_it_var(Nat id, NzNat a, Bool s) = table_it_var(id: id, arity: a, symmetric: s);
ColumnItVar column_it_var(Nat id, ColumnRepr r) = column_it_var(id: id, repr: r);
SlaveColumnItVar slave_column_it_var(Nat id, ColumnRepr r) = slave_column_it_var(id: id, repr: r);

TableVar table_var(PhysRelVar v)        = :table_var(v);

QualTableVar qual_table_var(AnyDBVar db, TableVar v) = qual_table_var(db_var: db, table_var: v);

CaptTableVar capt_table_var(TableVar v) = :capt_table_var(v);

MembTestPredId memb_test(Atom a)            = :memb_test(a);
MembTestPredId memb_test(Nat n)             = :memb_test(n);
MembTestPredId memb_test(Atom a1, Atom a2)  = :memb_test(a1, a2);
MembTestPredId memb_test(Atom a, Nat n)     = :memb_test(a, n);

SubAggrFnId red_var_init(AggrFnId f, StdVar v)    = :red_var_init(f, v);
SubAggrFnId red_vars_merge(AggrFnId f, StdVar v)  = :red_vars_merge(f, v);
SubAggrFnId final_value_yield(AggrFnId f)         = :final_value_yield(f);
SubAggrFnId null_value(AggrFnId f)                = :null_value(f);

AtomicExpr empty_seq = :empty_seq;
AtomicExpr empty_rel = :empty_rel;

BoolNatOp is_symb(ObjExpr e)                              = :is_symb(e);
BoolNatOp is_int(ObjExpr e)                               = :is_int(e);
BoolNatOp is_float(ObjExpr e)                             = :is_float(e);
BoolNatOp is_ne_seq(ObjExpr e)                            = :is_ne_seq(e);
BoolNatOp is_ne_int_seq(ObjExpr e)                        = :is_ne_int_seq(e);
BoolNatOp is_ne_float_seq(ObjExpr e)                      = :is_ne_float_seq(e);
BoolNatOp is_ne_set(ObjExpr e)                            = :is_ne_set(e);
BoolNatOp is_ne_map(ObjExpr e)                            = :is_ne_map(e);
BoolNatOp is_ne_bin_rel(ObjExpr e)                        = :is_ne_bin_rel(e);
BoolNatOp is_ne_tern_rel(ObjExpr e)                       = :is_ne_tern_rel(e);
BoolNatOp is_tagged_obj(ObjExpr e)                        = :is_tagged_obj(e);
BoolNatOp are_eq(ObjExpr e1, ObjExpr e2)                  = :are_eq(e1, e2);
BoolNatOp is_lt(IntExpr e1, IntExpr e2)                   = :is_lt(e1, e2);
BoolNatOp is_le(IntExpr e1, IntExpr e2)                   = :is_le(e1, e2);
BoolNatOp is_gt(IntExpr e1, IntExpr e2)                   = :is_lt(e2, e1);
BoolNatOp is_ge(IntExpr e1, IntExpr e2)                   = :is_le(e2, e1);
BoolNatOp is_flt(FloatExpr e1, FloatExpr e2)              = :is_flt(e1, e2);
BoolNatOp is_fle(FloatExpr e1, FloatExpr e2)              = :is_fle(e1, e2);
BoolNatOp is_out_of_range(ItVar v)                        = :is_out_of_range(v);
BoolNatOp is_blank(<AnySignalVar, LocVar, PendingStateVar> v) = :is_blank(v);
BoolNatOp is_null(AnyNullableVar v)                       = :is_null(v);
BoolNatOp has_field(ObjExpr r, SymbObj f)                 = has_field(record: r, field: f);
BoolNatOp rel_obj_contains(ObjExpr r, Maybe[ObjExpr]+ as) = rel_obj_contains(rel: r, args: as);
BoolNatOp table_contains(AnyTableVar tv, Maybe[Int32Var]+ vs, Bool b) = table_contains(table: tv, tuple: vs, symmetric: b);

## THESE ARE ALL DEPRECATED AND SHOULD BE REMOVED
BoolNatOp is_eq(BoolExpr e1, BoolExpr e2)               = are_eq(bool_obj(e1), bool_obj(e2));
BoolNatOp is_eq(IntExpr e1, IntExpr e2)                 = are_eq(int_obj(e1), int_obj(e2));
BoolNatOp is_eq(<Int32Var, Int32NatOp> e1, IntExpr e2)  = are_eq(int_obj(upcast_int32(e1)), int_obj(e2));
BoolNatOp is_eq(ObjExpr e1, ObjExpr e2)                 = are_eq(e1, e2);
BoolNatOp inline_is_eq(ObjExpr e1, ObjExpr e2)          = are_eq(e1, e2);


IntExpr get_int_val(ObjExpr expr) =
  int_obj(e?)   = e,
  _             = :get_int_val(expr);

IntNatOp minus(IntExpr e)                       = :minus(e);
IntNatOp add(IntExpr e1, IntExpr e2)            = :add(e1, e2);
IntNatOp sub(IntExpr e1, IntExpr e2)            = :sub(e1, e2);
IntNatOp mult(IntExpr e1, IntExpr e2)           = :mult(e1, e2);
IntNatOp div(IntExpr e1, IntExpr e2)            = :div(e1, e2);
IntNatOp mod_op(IntExpr e1, IntExpr e2)         = :mod(e1, e2); ## THIS SHOULD JUST BE NAMED mod, BUT THAT WOULD CONFLICT WITH THE INTEGER MOD OPERATION
IntNatOp bitwise_and(IntExpr e1, IntExpr e2)    = :bitwise_and(e1, e2);
IntNatOp bitwise_or(IntExpr e1, IntExpr e2)     = :bitwise_or(e1, e2);
IntNatOp bitwise_xor(IntExpr e1, IntExpr e2)    = :bitwise_xor(e1, e2);
IntNatOp float_bits(FloatExpr e)                = :float_bits(e);
IntNatOp round(FloatExpr e)                     = :round(e);
IntNatOp upcast_int32(<Int32Var, Int32NatOp> e) = :upcast_int32(e);

IntNatOp surr_to_int_value(AnyValueStoreId s, Int32Var v) = surr_to_int_value(store: s, surrogate: v);

IntNatOp unique_nat           = :unique_nat;
IntNatOp rand_nat(ObjExpr e)  = :rand_nat(get_int_val(e));
IntNatOp rand_nat(IntExpr e)  = :rand_nat(e);
IntNatOp ticks                = :ticks;

Int32NatOp bool_to_bit(BoolExpr e)                                    = :bool_to_bit(e);
Int32NatOp get_size(ObjExpr e)                                        = :get_size(e);
Int32NatOp get_count(AnyTableVar v, Maybe[Int32Var]+ as, Bool s)      = get_count(table: v, args: as, symmetric: s);
Int32NatOp table_lookup(AnyTableVar v, Maybe[Int32Var]+ as, Bool s)   = table_lookup(table: v, args: as, symmetric: s);
Int32NatOp add32(Int32Expr e1, Int32Expr e2)                          = :add32(e1, e2);
Int32NatOp value_to_surr(AnyValueStoreId s, <AtomicExpr, IntExpr> e)  = value_to_surr(store: s, value: e);
Int32NatOp get_unknown_arg(TableItVar v, Nat i)                       = get_unknown_arg(iter: v, arg: if i :: <0..2> then i else undefined);
Int32NatOp get_unknown_arg(<ColumnItVar, SlaveColumnItVar> v, Nat i)  = get_unknown_arg(iter: v, arg: if i == 0 then 0 else undefined);
Int32NatOp get_arg_by_assoc_surr(AnyTableVar v, <0..1> a, Int32Var s) = get_arg_by_assoc_surr(table: v, arg: a, surr: s);
Int32NatOp get_assoc_surr(AnyTableVar v, (Int32Var, Int32Var) as)     = get_assoc_surr(table: v, args: as);

<Int32Var, Int32NatOp> cast_int32(IntExpr expr) =
  upcast_int32(e?)  = e,
  _                 = :cast_int32(expr);

FloatExpr float_value(ObjExpr expr) =
  float_obj(e?) = e,
  _             = :float_value(expr);

FloatNatOp neg_float(FloatExpr val)                 = :neg_float(val);
FloatNatOp add_floats(FloatExpr lv, FloatExpr rv)   = :add_floats(lv, rv);
FloatNatOp sub_floats(FloatExpr lv, FloatExpr rv)   = :sub_floats(lv, rv);
FloatNatOp mult_floats(FloatExpr lv, FloatExpr rv)  = :mult_floats(lv, rv);
FloatNatOp div_floats(FloatExpr lv, FloatExpr rv)   = :div_floats(lv, rv);
FloatNatOp exp_floats(FloatExpr lv, FloatExpr rv)   = :exp_floats(lv, rv);
FloatNatOp square_root(FloatExpr value)             = :square_root(value);
FloatNatOp int_to_float(IntExpr value)              = :int_to_float(value);


ObjExpr obj_expr(BoolExpr  expr)                = bool_obj(expr);
ObjExpr obj_expr(IntExpr   expr)                = int_obj(expr);
ObjExpr obj_expr(<Int32Var, Int32NatOp>  expr)  = int_obj(upcast_int32(expr));
ObjExpr obj_expr(FloatExpr expr)                = float_obj(expr);
ObjExpr obj_expr(ObjExpr   expr)                = expr;


ObjExpr bool_obj(BoolExpr expr) =
  are_eq(e1?, e2?)  = if e1 == obj_true then e2               else
                      if e2 == obj_true then e1               else
                                             :bool_obj(expr),
  _               = :bool_obj(expr);


ObjExpr int_obj(IntExpr expr) =
  get_int_val(e?) = e,
  _               = :int_obj(expr);


ObjExpr int_obj(<Int32Var, Int32NatOp> expr) = int_obj(upcast_int32(expr));


ObjExpr float_obj(FloatExpr expr) =
  float_value(e?) = e,
  _               = :float_obj(expr);


ObjNatOp at(ObjExpr s, IntExpr i)                     = at(seq: s, idx: i);
ObjNatOp array_at(ArrayVar a, Int32Var s, IntExpr i)  = array_at(array: a, size: s, idx: i);
ObjNatOp lookup(ObjExpr r, ObjExpr k)                 = lookup(rel: r, key: k);
ObjNatOp lookup_field(ObjExpr e, SymbObj f)           = lookup_field(record: e, field: f, repr: nothing);
ObjNatOp get_tag(ObjExpr e)                           = :get_tag(e);
ObjNatOp get_inner_obj(ObjExpr e)                     = :get_inner_obj(e);
ObjNatOp get_curr_obj(<SetItVar, SeqItVar> it)        = :get_curr_obj(it);
ObjNatOp get_curr_arg(BinRelItVar v,  Nat a)          = get_curr_arg(var: v, arg: if a :: <0..1> then a else undefined);
ObjNatOp get_curr_arg(TernRelItVar v, Nat a)          = get_curr_arg(var: v, arg: if a :: <0..2> then a else undefined);
ObjNatOp surr_to_value(AnyValueStoreId s, Int32Var v) = surr_to_value(store: s, surrogate: v);
ObjNatOp column_lookup(AnyTableVar v, Int32Var k, ColumnRepr r) = column_lookup(var: v, key: k, repr: r);
ObjNatOp rand_elem(ObjExpr s)                         = :rand_elem(s);

ObjNatOp lookup_field(ObjExpr e, SymbObj f, Maybe[LowLevelRepr] r) {
  assert e :: OptTagRecExpr or r == nothing;
  assert not (e :: OptTagRecExpr and r == nothing); ## JUST A TEMPORARY CHECK, IT'S PROBABLY NOT ALWAYS TRUE
  return lookup_field(record: e, field: f, repr: r);
}

BoolFnCall is_member(MembTestPredId p, AtomicExpr e)  = is_member(pred: p, obj: e);
BoolFnCall state_is_def(AnyAutoVar v, AutoSymbol t)   = state_is_def(auto_var: v, type: t);

BoolExpr neg(BoolExpr e) =
  neg(ne?)  = ne,
  _         = :neg(e);

BoolExpr and(BoolExpr+ es)      = if      not (e <- es : e != true) then true
                                  else if |es| != 1                 then :and(es)
                                                                    else only(es);

// BoolExpr and(BoolExpr+ es)      = if |es| != 1 then :and(es)      else only(es);
BoolExpr or(BoolExpr+ es)       = if |es| != 1 then :or(es)       else only(es);
BoolExpr and_then(BoolExpr+ es) = if |es| != 1 then :and_then(es) else only(es);
BoolExpr or_else(BoolExpr+ es)  = if |es| != 1 then :or_else(es)  else only(es);

BoolExpr and([+BoolExpr] es)  = and(rand_sort(es));
BoolExpr or([+BoolExpr] es)   = or(rand_sort(es));

OptTagRecExpr cast_opt_tag_rec(Symbol s, Nat i, ObjExpr e) = cast_opt_tag_rec(tag: s, index: i, expr: e);

BasicInstr init_stream(StreamVar v)          = :init_stream(v);
BasicInstr append(StreamVar v, AtomicExpr e) = append(stream: v, obj: e);

FloatExpr float_value(ObjExpr expr) =
  float_obj(e?) = e,
  _             = :float_value(expr);

FloatNatOp neg_float(FloatExpr val)                 = :neg_float(val);
FloatNatOp add_floats(FloatExpr lv, FloatExpr rv)   = :add_floats(lv, rv);
FloatNatOp sub_floats(FloatExpr lv, FloatExpr rv)   = :sub_floats(lv, rv);
FloatNatOp mult_floats(FloatExpr lv, FloatExpr rv)  = :mult_floats(lv, rv);
FloatNatOp div_floats(FloatExpr lv, FloatExpr rv)   = :div_floats(lv, rv);
FloatNatOp exp_floats(FloatExpr lv, FloatExpr rv)   = :exp_floats(lv, rv);
FloatNatOp square_root(FloatExpr value)             = :square_root(value);
FloatNatOp int_to_float(IntExpr value)              = :int_to_float(value);


RefObjExpr mk_set(StreamVar s)              = mk_set_from_stream(stream: s);
RefObjExpr mk_set(VecVar es, IntExpr s)     = mk_set(elems: es, size: s);
RefObjExpr mk_set(ArrayVar a, Int32Expr s)  = mk_set_from_array(array: a, size: s);

RefObjExpr mk_seq(StreamVar s)              = mk_seq_from_stream(stream: s);
RefObjExpr mk_seq(VecVar es, IntExpr s)     = mk_seq(elems: es, size: s);
RefObjExpr mk_seq(ArrayVar a, Int32Expr s)  = mk_seq_from_array(array: a, size: s);

RefObjExpr build_const_int_seq(Nat id)    = build_const_int_seq(seq_id: id);

RefObjExpr mk_map(StreamVar ks, StreamVar vs)       = mk_map_from_streams(key_stream: ks, value_stream: vs);
RefObjExpr mk_map(VecVar ks, VecVar vs, IntExpr s)  = mk_map(keys: ks, values: vs, size: s);

RefObjExpr mk_rel(StreamVar s1, StreamVar s2) = mk_bin_rel_from_streams(streams: (s1, s2));
RefObjExpr mk_bin_rel((VecVar, VecVar) cs, IntExpr s) = mk_bin_rel(cols: cs, size: s);
RefObjExpr mk_rel(ArrayVar c1, ArrayVar c2, Int32Expr s, Bool b) = mk_bin_rel_from_arrays(col1: c1, col2: c2, size: s, is_map: b);

RefObjExpr mk_rel(StreamVar s1, StreamVar s2, StreamVar s3) = mk_tern_rel_from_streams(streams: (s1, s2, s3));
RefObjExpr mk_tern_rel((VecVar, VecVar, VecVar) cs, IntExpr s) = mk_tern_rel(cols: cs, size: s);
RefObjExpr mk_rel(ArrayVar c1, ArrayVar c2, ArrayVar c3, Int32Expr s) = mk_tern_rel_from_arrays(col1: c1, col2: c2, col3: c3, size: s);

RefObjExpr mk_tagged_obj(AtomicExpr t, AtomicExpr o) = mk_tagged_obj(tag: t, obj: o);

RefObjExpr mk_record([+SymbObj -> AtomicExpr] fs) = mk_record(fields: fs);

RefObjExpr get_seq_slice(AtomicExpr s, IntExpr f, IntExpr l)  = get_seq_slice(seq: s, idx_first: f, len: l);
RefObjExpr append_to_seq(AtomicExpr s, AtomicExpr e)          = append_to_seq(seq: s, new_elem: e);
RefObjExpr update_seq_at(AtomicExpr s, IntExpr i, AtomicExpr v) = update_seq_at(seq: s, idx: i, value: v);

RefObjExpr join_seqs(AtomicExpr l, AtomicExpr r)              = join_seqs(left: l, right: r);
RefObjExpr rev_seq(AtomicExpr s)                              = rev_seq(seq: s);

RefObjExpr internal_sort(AtomicExpr s) = internal_sort(set: s);

RefObjExpr insert_elt(AtomicExpr s, AtomicExpr e) = insert_elt(set: s, elt: e);
RefObjExpr remove_elt(AtomicExpr s, AtomicExpr e) = remove_elt(set: s, elt: e);

RefObjExpr set_key_value(AtomicExpr m, AtomicExpr k, AtomicExpr e) = set_key_value(map: m, key: k, value: e);
RefObjExpr drop_key(AtomicExpr m, AtomicExpr k) = drop_key(map: m, key: k);

RefObjExpr parse_value(AtomicExpr s)  = parse_value(value: s);
RefObjExpr print_value(AtomicExpr s)  = print_value(value: s);

RefObjExpr copy_state(AnyDBVar dv, DBSymbol t) = copy_state(var: dv, type: t);
RefObjExpr copy_rel([+TableVar -> AnyTable] ts, [+Nat -> Nat] p) = copy_rel(tables: ts, applied_perm: p);

RefObjExpr copy_persistent_state(AnyAutoVar av, AutoSymbol t) = copy_persistent_state(var: av, type: t);

RefObjExpr read_pending_var(<PendingStateVar, PendingInputVar> sv) = :read_pending_var(sv);


// Basic instructions

BasicInstr mk_set(WriteObjVar v, StreamVar s)             = set_var(v, mk_set_from_stream(stream: s));
BasicInstr mk_set(WriteObjVar v, VecVar es, IntExpr s)    = set_var(v, mk_set(elems: es, size: s));
BasicInstr mk_set(WriteObjVar v, ArrayVar a, Int32Expr s) = set_var(v, mk_set_from_array(array: a, size: s));

BasicInstr mk_seq(WriteObjVar v, StreamVar s)              = set_var(v, mk_seq_from_stream(stream: s));
BasicInstr mk_seq(WriteObjVar v, VecVar es, IntExpr s)     = set_var(v, mk_seq(elems: es, size: s));
BasicInstr mk_seq(WriteObjVar v, ArrayVar a, Int32Expr s)  = set_var(v, mk_seq_from_array(array: a, size: s));

BasicInstr build_const_int_seq(WriteObjVar v, Nat id)    = set_var(v, build_const_int_seq(seq_id: id));

BasicInstr mk_map(WriteObjVar v, StreamVar ks, StreamVar vs)       = set_var(v, mk_map_from_streams(key_stream: ks, value_stream: vs));
BasicInstr mk_map(WriteObjVar v, VecVar ks, VecVar vs, IntExpr s)  = set_var(v, mk_map(keys: ks, values: vs, size: s));

BasicInstr mk_rel(WriteObjVar v, StreamVar s1, StreamVar s2)       = set_var(v, mk_bin_rel_from_streams(streams: (s1, s2)));
BasicInstr mk_rel(WriteObjVar v, VecVar c1, VecVar c2, IntExpr s)  = set_var(v, mk_bin_rel(cols: (c1, c2), size: s));
BasicInstr mk_rel(WriteObjVar v, ArrayVar c1, ArrayVar c2, Int32Expr s, Bool b) = set_var(v, mk_bin_rel_from_arrays(col1: c1, col2: c2, size: s, is_map: b));

BasicInstr mk_rel(WriteObjVar v, StreamVar s1, StreamVar s2, StreamVar s3)   = set_var(v, mk_tern_rel_from_streams(streams: (s1, s2, s3)));
BasicInstr mk_rel(WriteObjVar v, VecVar c1, VecVar c2, VecVar c3, IntExpr s) = set_var(v, mk_tern_rel(cols: (c1, c2, c3), size: s));
BasicInstr mk_rel(WriteObjVar v, ArrayVar c1, ArrayVar c2, ArrayVar c3, Int32Expr s) = set_var(v, mk_tern_rel_from_arrays(col1: c1, col2: c2, col3: c3, size: s));

BasicInstr mk_tagged_obj(WriteObjVar v, AtomicExpr t, AtomicExpr o) = set_var(v, mk_tagged_obj(t, o));

BasicInstr mk_record(WriteObjVar v, [+SymbObj -> AtomicExpr] fs) = set_var(v, mk_record(fields: fs));

BasicInstr inst_opt_tag_rec(LocOptTagRecVar v, Symbol s, Nat i) = set_var(v, inst_opt_tag_rec(tag: s, repr_idx: i));

BasicInstr get_seq_slice(WriteObjVar v, AtomicExpr s, IntExpr f, IntExpr l)  = set_var(v, get_seq_slice(seq: s, idx_first: f, len: l));
BasicInstr append_to_seq(WriteObjVar v, AtomicExpr s, AtomicExpr e)          = set_var(v, append_to_seq(seq: s, new_elem: e));
BasicInstr update_seq_at(WriteObjVar rv, AtomicExpr s, IntExpr i, AtomicExpr v) = set_var(rv, update_seq_at(seq: s, idx: i, value: v));

BasicInstr join_seqs(WriteObjVar v, AtomicExpr l, AtomicExpr r)              = set_var(v, join_seqs(left: l, right: r));
BasicInstr rev_seq(WriteObjVar v, AtomicExpr s)                              = set_var(v, rev_seq(seq: s));

BasicInstr lookup_field(WriteObjVar v, ObjExpr e, SymbObj f)                        = set_var(v, lookup_field(e, f));
BasicInstr lookup_field(WriteObjVar v, ObjExpr e, SymbObj f, Maybe[LowLevelRepr] r) = set_var(v, lookup_field(e, f, r));

BasicInstr internal_sort(WriteObjVar v, AtomicExpr s) = set_var(v, internal_sort(set: s));

BasicInstr insert_elt(WriteObjVar v, AtomicExpr s, AtomicExpr e) = set_var(v, insert_elt(s, e));
BasicInstr remove_elt(WriteObjVar v, AtomicExpr s, AtomicExpr e) = set_var(v, remove_elt(s, e));

BasicInstr set_key_value(WriteObjVar v, AtomicExpr m, AtomicExpr k, AtomicExpr e) = set_var(v, set_key_value(map: m, key: k, value: e));
BasicInstr drop_key(WriteObjVar v, AtomicExpr m, AtomicExpr k) = set_var(v, drop_key(map: m, key: k));

BasicInstr parse_value(WriteObjVar v, AtomicExpr s)  = set_var(v, parse_value(value: s));
BasicInstr print_value(WriteObjVar v, AtomicExpr s)  = set_var(v, print_value(value: s));

BasicInstr copy_state(WriteObjVar rv, AnyDBVar dv, DBSymbol t) = set_var(rv, copy_state(var: dv, type: t));
BasicInstr copy_rel(WriteObjVar ov, [+TableVar -> AnyTable] ts, [+Nat -> Nat] p) = set_var(ov, copy_rel(tables: ts, applied_perm: p));

BasicInstr copy_persistent_state(WriteObjVar rv, AnyAutoVar av, AutoSymbol t) = set_var(rv, copy_persistent_state(var: av, type: t));

BasicInstr surr_to_value(WriteObjVar v, AnyValueStoreId s, Int32Var sv) = set_var(v, surr_to_value(s, sv));

BasicInstr read_pending_var(WriteObjVar tv, <PendingStateVar, PendingInputVar> sv) = set_var(tv, :read_pending_var(sv));

BasicInstr array_alloc(ArrayVar v, Int32Expr n) = array_alloc(var: v, size: n);
BasicInstr array_write(ArrayVar v, Int32Expr i, ObjExpr e) = array_write(var: v, idx: i, value: low_level_expr(v.repr, e));
BasicInstr array_append(ArrayVar v, Int32Var s, Int32Var c, AnyTypeExpr e) = array_append(array_var: v, size_var: s, capacity_var: c, value: e);
BasicInstr array_set_var(ArrayVar t, ArrayVar s) = array_set_var(target: t, source: s);

BasicInstr write_rec_field(LocOptTagRecVar v, Symbol s, AnyTypeExpr e, Bool b) = write_rec_field(var: v, label: s, value: e, optional: b);
BasicInstr finish_init(LocOptTagRecVar v) = finish_init(var: v);

BasicInstr get_iter(SeqItVar v, AtomicExpr s) = get_seq_iter(var: v, src: s);
BasicInstr get_iter(SetItVar v, AtomicExpr s) = get_set_iter(var: v, src: s);

BasicInstr get_iter(BinRelItVar v, AtomicExpr r, (Maybe[AtomicExpr], Maybe[AtomicExpr]) as) =
  get_bin_rel_iter(var: v, src: r, args: as);

BasicInstr get_iter(TernRelItVar v, AtomicExpr r, (Maybe[AtomicExpr], Maybe[AtomicExpr], Maybe[AtomicExpr]) as) =
  get_tern_rel_iter(var: v, src: r, args: as);

BasicInstr get_any_rel_iter(SetItVar v, AtomicExpr r, Maybe[AtomicExpr]* as) =
  if as == (nothing) then get_iter(v, r) else undefined;

BasicInstr get_any_rel_iter(BinRelItVar v, AtomicExpr r, Maybe[AtomicExpr]* as) =
  get_iter(v, r, if |as| == 2 then as else undefined);

BasicInstr get_any_rel_iter(TernRelItVar v, AtomicExpr r, Maybe[AtomicExpr]* as) =
  get_iter(v, r, if |as| == 3 then as else undefined);

BasicInstr move_forward(ItVar v) = :move_forward(v);

BasicInstr set_var(<WriteObjVar, ImplArg> v, ObjExpr e)  = set_var(var: v, value: e);
BasicInstr set_var(LocOptTagRecVar v, OptTagRecExpr e)   = set_var(var: v, value: e);

BasicInstr set_var(LocOptTagRecVar v, <InlineObj, StdObjVar, ObjNatOp> e) =
  set_var(var: v, value: cast_opt_tag_rec(v.tag, v.index, e));

BasicInstr set_bvar(BoolVar v, BoolExpr e)              = set_bvar(var: v, value: e);
BasicInstr set_ivar(IntVar v, IntExpr e)                = set_ivar(var: v, value: e);
BasicInstr set_ivar(IntVar v, <Int32Var, Int32NatOp> e) = set_ivar(var: v, value: upcast_int32(e));
BasicInstr set_ivar32(Int32Var v, Int32Expr e)          = set_ivar32(var: v, value: e);
BasicInstr set_fvar(FloatVar v, FloatExpr e)            = set_fvar(var: v, value: e);

BasicInstr set_var(<WriteObjVar, LocOptTagRecVar> v, RefObjExpr e)  = set_rc_var(var: v, value: e);

BasicInstr init_memb_var(<MembVar, SignalVar, PrevVarValue, MembObjVar, PendingInputVar, PendingStateVar> v, <blank, undefined> s) = init_memb_var(var: v, new_state: s);
BasicInstr reset_memb_var(<SignalVar, PrevVarValue, MembVar, PendingInputVar> v, <blank, undefined> s) = reset_memb_var(var: v, new_state: s);

BasicInstr clear_loc_var(LocVar v) = :clear_loc_var(v);
BasicInstr nullify_var(<StdVar, LocVar, LocOptTagRecVar> v) = :nullify_var(v);

BasicInstr make_var_undef(SignalVar v) = reset_memb_var(v, :undefined);
BasicInstr make_var_undef(LocVar v)    = clear_loc_var(v);

JumpInstr terminate(Bool b) = terminate(hard_fail: b);
JumpInstr terminate = terminate(false);

BasicInstr add_ref(ObjVar v)                     = :add_ref(v);
BasicInstr release(<ObjVar, PendingInputVar> v)  = :release(v);

BasicInstr print_obj(AtomicExpr x) = print_obj(obj: x);

JumpInstr ret_val(AnyTypeExpr e) = :ret_val(e);

BasicInstr no_op = :no_op;

Instr branch(BoolExpr cond, Instr* body, Instr* neg_body) {
  if body != () {
    if |body| == 1 {
      branch_instr = match (only(body))
        branch() i? = just(i),
        _           = nothing;

      if branch_instr != nothing {
        branch_instr = value(branch_instr);
        if branch_instr.when_false == neg_body
          return branch(and_then(cond, branch_instr.cond), branch_instr.when_true, neg_body);
      }
    }
    return branch(cond: cond, when_true: body, when_false: neg_body);
  }
  else {
    return branch(neg(cond), nonempty(neg_body), ());
  }
}

Instr branch_or_no_op(BoolExpr c, Instr* t, Instr* f) =
  if t == () and f == ()
    then no_op
    else branch(c, t, f);

Instr repeat(Instr+ b) = :repeat(b);
Instr break_loop       = :break_loop;

Instr execute_block(Instr+ b) = :execute_block(b);
Instr exit_block              = :exit_block;

Instr* opt_execute_block(Instr* b) = (execute_block(b) if b != ());

Instr try_block(LocVar v, Instr+ b) = try_block(var: v, body: b);

Instr switch_on_nat(IntExpr e, Instr*+ cs) = switch_on_nat(value: e, cases: cs);

Instr symb_switch(ObjExpr e, [+([+SymbObj], Instr+)] cs, Instr* eis) = symb_switch(value: e, cases: cs, else: eis);

Instr* opt_symb_switch(ObjExpr expr, [([+SymbObj], Instr+)] cases, Instr* else_code) {
  return else_code if cases == [];

  if |cases| == 1 {
    symbs, code = only(cases);
    if |symbs| < 3 {
      cond = or([are_eq(expr, s) : s <- symbs]);
      return (branch(cond, code, else_code));
    }
  }

  return (symb_switch(expr, cases, else_code));
}

BasicInstr call_proc(AnyWriteVar v, ObjFnName n, AnyTypeExpr* as, AnyLambdaExpr* cas) =
  call_proc(var: v, name: n, args: as, cls_args: cas, rel_auto_args: (), react_auto_args: ());

BasicInstr call_proc(ObjFnName n, AnyTypeExpr* as, AnyLambdaExpr* cas) =
  call_proc(name: n, args: as, cls_args: cas, rel_auto_args: (), react_auto_args: ());

BasicInstr call_proc(AnyWriteVar v, ObjFnName n, AnyTypeExpr* as, AnyLambdaExpr* cas, (LocDBVar, DBSymbol)* ras, LocAutoVar* vas) =
  call_proc(var: v, name: n, args: as, cls_args: cas, rel_auto_args: ras, react_auto_args: vas);

BasicInstr call_proc(ObjFnName n, AnyTypeExpr* as, AnyLambdaExpr* cas, (LocDBVar, DBSymbol)* ras, LocAutoVar* vas) =
  call_proc(name: n, args: as, cls_args: cas, rel_auto_args: ras, react_auto_args: vas);

BasicInstr call_cls(WriteObjVar v, AnyClsVar cv, AtomicExpr+ as) = call_cls(var: v, cls_var: cv, args: as);

BasicInstr queue_node_update(AutoSymbol s, BlockNodeId id)        = queue_node_update(type: s, id: id, args: ());
BasicInstr queue_node_update(AutoSymbol s, BlockNodeId id, Nat a) = queue_node_update(type: s, id: id, args: (a));

BasicInstr insert_timer(AutoSymbol a, Nat i, IntExpr t)  = insert_timer(type: a, idx: i, time: t);
BasicInstr clear_timer(AutoSymbol a, IntExpr i)          = clear_timer(type: a, idx: i);

BasicInstr auto_pre_init(AnyAutoVar v, AutoSymbol t) = auto_pre_init(var: v, type: t);
BasicInstr auto_cleanup(AnyAutoVar v, AutoSymbol t)  = auto_cleanup(var: v, type: t);

BasicInstr set_input(AnyAutoVar v, AutoSymbol t, Atom i, AtomicExpr e) = set_input(var: v, type: t, input: i, value: e);

BasicInstr clear_input(AnyAutoVar v, AutoSymbol t, Atom i) = clear_input(var: v, type: t, input: i);
BasicInstr clear_input(AutoSymbol t, Atom i)               = clear_input(type: t, input: i);

BasicInstr auto_init(AnyAutoVar v, AutoSymbol t)                   = auto_init(var: v, type: t);
BasicInstr auto_init(AutoSymbol t)                                 = auto_init(type: t);

BasicInstr auto_update_node(AutoSymbol t, BlockNodeId n)           = auto_update_node(type: t, node: n);
BasicInstr auto_update_node(AutoSymbol t, BlockNodeId n, IntVar v) = auto_update_node(type: t, node: n, time_var: v);

BasicInstr auto_apply(AnyAutoVar v, AutoSymbol t)  = auto_apply(var: v, type: t);
BasicInstr auto_apply(AutoSymbol t)                = auto_apply(type: t);

BasicInstr set_persistent_state(AnyAutoVar v, AtomicExpr e, AutoSymbol t) = set_persistent_state(auto_var: v, state: e, type: t);

BasicInstr init_db(AnyDBVar v, LocDBVar* ls, DBSymbol t)  = init_db(db_var: v, links: ls, type: t);
BasicInstr cleanup_db(AnyDBVar v, DBSymbol t)  = cleanup_db(db_var: v, type: t);
BasicInstr send_msg(AnyDBVar v, DBSymbol t, AtomicExpr m, Bool r) = send_msg(db_var: v, type: t, msg: m, is_root: r);
BasicInstr send_msg(AnyDBVar v, DBSymbol t, AtomicExpr m, Bool r, BoolVar rv) = send_msg(db_var: v, type: t, msg: m, is_root: r, res_var: rv);
BasicInstr try_update(DBSymbol t, UpdateId id, AtomicExpr* as) = try_update(type: t, update_id: id, args: as);

BasicInstr set_state(BoolVar rv, LocDBVar v, LocDBVar* ds, AtomicExpr e, DBSymbol t) = set_state(res_var: rv, db_var: v, dependees: ds, state: e, type: t);

BasicInstr invoke_auto_method(WriteObjVar rv, AutoSymbol t, MethodId id, AtomicExpr* as) =
  invoke_auto_method(res_var: rv, type: t, method_id: id, args: as);

BasicInstr invoke_auto_method(WriteObjVar rv, AnyAutoVar av, AutoSymbol t, MethodId id, AtomicExpr* as) =
  invoke_auto_method(res_var: rv, auto_var: av, type: t, method_id: id, args: as);

BasicInstr invoke_db_method(AnyWriteVar rv, DBSymbol t, MethodId id, AnyTypeExpr* as) =
  invoke_db_method(res_var: rv, type: t, method_id: id, args: as);

BasicInstr invoke_db_method(AnyWriteVar rv, AnyDBVar dv, DBSymbol t, MethodId id, AnyTypeExpr* as) =
  invoke_db_method(res_var: rv, db_var: dv, type: t, method_id: id, args: as);

BasicInstr init_value_store(ValueStoreId s)    = init_value_store(store: s);
BasicInstr cleanup_value_store(ValueStoreId s) = cleanup_value_store(store: s);

BasicInstr init_table(TableVar v, AnyTable t)    = init_table(table_var: v, table: t);
BasicInstr cleanup_table(TableVar v, AnyTable t) = cleanup_table(table_var: v, table: t);

BasicInstr get_table_iter(<TableItVar, SlaveColumnItVar> v, AnyTableVar t, Maybe[Int32Var]+ as) {
  assert (a <- as : a == nothing);
  assert arity(v) == |as|;
  return get_table_iter(it_var: v, table: t, args: as);
}

BasicInstr get_column_iter(ColumnItVar v, AnyTableVar c) = get_column_iter(it_var: v, column: c);

BasicInstr queue_deletes(TableVar tv, Maybe[Int32Var]+ as, Bool s) = queue_deletes(table_var: tv, args: as, symmetric: s);

BasicInstr lookup_or_queue_insert_value(Int32Var v, ValueStoreId s, <AtomicExpr, IntExpr> e) = lookup_or_queue_insert_value(res_var: v, store: s, value: e);
BasicInstr queue_insert_tuple(TableVar v, Int32Var+ t) = queue_insert_tuple(table_var: v, tuple: t);

BasicInstr column_insert_deferred(TableVar v, Int32Var k, AnyTypeExpr e, Bool f) =
  column_insert_deferred(table_var: v, key_surr: k, value: e, forced: f);

BasicInstr ternary_slave_column_insert_deferred(TableVar v, (Int32Var, Int32Var) ss, AnyTypeExpr e, Bool f) =
  ternary_slave_column_insert_deferred(table_var: v, surrs: ss, value: e, forced: f);

BasicInstr immediate_insert_or_add_ref(Int32Var sv, ValueStoreId s, <AtomicExpr, IntExpr> v) = immediate_insert_or_add_ref(res_var: sv, store: s, value: v);
BasicInstr immediate_insert_tuple(TableVar v, Int32Var+ as) = immediate_insert_tuple(table_var: v, tuple: as);
BasicInstr column_insert_immediate(TableVar t, Int32Var k, AnyTypeExpr v) = column_insert_immediate(table_var: t, key_surr: k, value: v);

BasicInstr push_call_info(<FnId, ProcSymbol, MethodSymbol> f, ObjExpr* as) = push_call_info(fn_name: f, args: as);
BasicInstr pop_call_info = :pop_call_info;

BasicInstr log_runtime_failure(Bool b, String f, NzNat l, Maybe[String] t, (<StdVar, ImplArg>, ObjExpr)* vs) =
  log_runtime_failure(is_assert: b, file: f, line: l, text: t, vars: vs);

////////////////////////////////////////////////////////////////////////////////

CaptClsVar capt_cls_var(Nat n) = :capt_cls_var(n);

ClsDef cls_def(NzNat a, Instr+ b) = cls_def(arity: a, body: b);

LambdaExpr lambda_expr(ClsDef c, Maybe[DBSymbol] a, ObjExpr* vs, AnyClsVar* cs) =
  lambda_expr(cls: c, capt_auto: a, capt_vars: vs, capt_cls_vars: cs);

ClsProcArg cls(ClsVar v, NzNat a) = cls(var: v, arity: a);

BoolProcDef bool_proc_def(MembTestPredId name, NzNat arity, Instr+ body) =
  bool_proc_def(
    name:  name,
    arity: arity,
    body:  body
  );

ConstBlockData time_slots_len(Atom id, Nat+ ls) = time_slots_len(expr_id: id, lengths: ls);

StdBlockNodeId        std_block_node_id(Atom id)            = :std_block_node_id(id);
CondNodeId            cond_node_id(Nat id)                  = :cond_node_id(id);
NestedAutoNodeId      nested_auto_node_id(Atom id)          = :nested_auto_node_id(id);
NestedAutoInputNodeId nested_auto_input_id(Atom a, Atom i)  = nested_auto_input_id(auto: a, input: i);

ValueStoreId value_store_id(Nat n)  = :value_store_id(n);

NestedValueStoreId nested_value_store_id(AnyDBVar v, ValueStoreId id) =
  nested_value_store_id(db_var: v, store_id: id);

CaptValueStoreId capt_value_store_id(ValueStoreId id) = :capt_value_store_id(id);

Table table(ValueStoreId+ vs, [[+Nat]] ks, NeType+ ts, Bool s) {
  assert |vs| == |ts|;
  return table(value_stores: vs, keys: ks, col_types: ts, symmetric: s);
}

MasterBinTable master_bin_table((ValueStoreId, ValueStoreId) vs, [[+Nat]] ks, (NeType, NeType) ts, Bool s) =
  master_bin_table(
    value_stores: vs,
    keys:         ks,
    col_types:    ts,
    symmetric:    s
  );

SlaveTernTable slave_tern_table(TableVar m, (ValueStoreId, ValueStoreId, ValueStoreId) vs, [[+Nat]] ks, (NeType, NeType, NeType) ts, Bool s) =
  slave_tern_table(
    master:       m,
    value_stores: vs,
    keys:         ks,
    col_types:    ts,
    symmetric:    s
  );

Column column(ValueStoreId s, ColumnRepr r, (NeType, NeType) ts) = column(value_store: s, repr: r, col_types: ts);

SlaveColumn slave_column(TableVar v, (ValueStoreId, ValueStoreId) vs, ColumnRepr r, (NeType, NeType, NeType) ts) = slave_column(master: v, value_stores: vs, repr: r, col_types: ts);

ForeignKeyType unary_binary(Nat i)  = if i :: <0..1> then :unary_binary(i)  else undefined;
ForeignKeyType unary_ternary(Nat i) = if i :: <0..2> then :unary_ternary(i) else undefined;
ForeignKeyType binary_unary(Nat i)  = if i :: <0..1> then :binary_unary(i)  else undefined;
ForeignKeyType ternary_unary(Nat i) = if i :: <0..2> then :ternary_unary(i) else undefined;

BlockForeignKey foreign_key(TableVar r1, TableVar r2, ForeignKeyType t) =
  foreign_key(origin: r1, target: r2, type: t);

CompiledMethod compiled_method(Maybe[StdVar]* as, NeType* ats, [+MembTestPredId*] mps, NeType rt, Instr* c) {
  assert |as| == |ats|;
  assert not (ps <- mps : |ps| != |ats|);
  return compiled_method(args_vars: as, args_types: ats, args_memb_preds: mps, ret_type: rt, code: c);
}

CompiledUpdate compiled_update(<StdVar, FnArg>* as, Instr* b) = compiled_update(args_vars: as, body: b);

////////////////////////////// Derived expressions /////////////////////////////

BoolExpr bool_value(ObjExpr expr) = are_eq(expr, obj_true);

BoolExpr and(BoolExpr e1, BoolExpr e2)      = and((e1, e2));
BoolExpr or(BoolExpr e1, BoolExpr e2)       = or((e1, e2));
BoolExpr and_then(BoolExpr e1, BoolExpr e2) = and_then((e1, e2));
BoolExpr or_else(BoolExpr e1, BoolExpr e2)  = or_else((e1, e2));

BoolExpr and(BoolExpr e1, BoolExpr e2, BoolExpr e3)      = and((e1, e2, e3));
BoolExpr or(BoolExpr e1, BoolExpr e2, BoolExpr e3)       = or((e1, e2, e3));
BoolExpr and_then(BoolExpr e1, BoolExpr e2, BoolExpr e3) = and_then((e1, e2, e3));
BoolExpr or_else(BoolExpr e1, BoolExpr e2, BoolExpr e3)  = or_else((e1, e2, e3));

BoolExpr is_empty_seq(ObjExpr e)  = is_eq(e, empty_seq);
BoolExpr is_empty_rel(ObjExpr e)  = is_eq(e, empty_rel);

BoolExpr is_seq(ObjExpr e)  = or(is_empty_seq(e), is_ne_seq(e));
BoolExpr is_set_value(ObjExpr e)  = or(is_empty_rel(e), is_ne_set(e)); // Renamed because of conflict with is_set() constructors

BoolExpr is_not_blank(<AnySignalVar, LocVar> v)               = neg(is_blank(v));
BoolExpr is_not_null(AnyNullableVar v)                        = neg(is_null(v));
BoolExpr is_neither_blank_nor_null(<AnySignalVar, LocVar> v)  = neg(or(is_null(v), is_blank(v)));

BoolExpr is_between(IntExpr e, IntExpr l, IntExpr u) = and(is_ge(e, l), is_le(e, u));

BoolExpr is_true(ObjExpr e)  = is_eq(e, obj_true);
BoolExpr is_false(ObjExpr e) = is_eq(e, obj_false);

BoolExpr is_bool(ObjExpr e)  = or(is_true(e), is_false(e));

BoolExpr is_even(IntExpr e) = is_eq(mod_op(e, 2), 0);
BoolExpr is_odd(IntExpr e)  = is_eq(mod_op(e, 2), 1);

SymbObj obj_true  = :object(true);
SymbObj obj_false = :object(false);

///////////////////////////// Derived instructions /////////////////////////////

Instr repeat_while(BoolExpr cond, Instr+ body) = repeat(nonempty((do_if_not(cond, break_loop)) & body));

Instr increment(IntVar v, IntExpr a)  = set_ivar(v, add(v, a));
Instr increment(IntVar v)             = increment(v, 1);
Instr decrement(IntVar v)             = increment(v, -1);

Instr increment(Int32Var v, Int32Expr e)  = set_ivar32(v, add32(v, e));
Instr increment(Int32Var v)               = increment(v, 1);

Instr do_if(BoolExpr cond, Instr* instrs)      = branch(cond, instrs, ());
Instr do_if_not(BoolExpr cond, Instr* instrs)  = branch(cond, (), instrs);

Instr do_if(BoolExpr cond, Instr instr)      = do_if(cond, (instr));
Instr do_if_not(BoolExpr cond, Instr instr)  = do_if_not(cond, (instr));

Instr* opt_do_if(BoolExpr cond, Instr* instrs) = if instrs == ()  then ()                     else
                                                 if cond == true  then instrs                 else
                                                 if cond == false then ()                     else
                                                                       (do_if(cond, instrs));

Instr branch(BoolExpr c, Instr i1, Instr i2) = branch(c, (i1), (i2));

Instr branch(BoolExpr c1, Instr+ b1, BoolExpr c2, Instr+ b2, Instr+ e) = branch(c1, b1, (branch(c2, b2, e)));

Instr break_if(BoolExpr cond)     = do_if(cond, break_loop);
Instr break_if_not(BoolExpr cond) = do_if_not(cond, break_loop);

Instr exit_block_if(BoolExpr cond)     = do_if(cond, exit_block);
Instr exit_block_if_not(BoolExpr cond) = do_if_not(cond, exit_block);

Instr ret_true  = ret_val(true);
Instr ret_false = ret_val(false);

Instr ret_true_if(BoolExpr cond)  = do_if(cond, ret_true);
Instr ret_false_if(BoolExpr cond) = do_if(cond, ret_false);

Instr ret_true_if_not(BoolExpr cond)  = do_if_not(cond, ret_true);
Instr ret_false_if_not(BoolExpr cond) = do_if_not(cond, ret_false);

// Instr ret_false_if_not_in(AtomicExpr val, SymbObj+ values) = do_if_not_in(val, values, [ret_false]);

Instr check(BoolExpr e) = do_if_not(e, terminate);
// Instr check(BoolExpr e) = no_op;

Instr check_is_bool(ObjExpr e) = check(is_bool(e));

Instr get_curr_obj(WriteObjVar v, <SetItVar, SeqItVar> it) = set_var(v, get_curr_obj(it));
Instr get_curr_arg(WriteObjVar v, SetItVar     it, Nat a)  = set_var(v, if a == 0 then get_curr_obj(it) else undefined);
Instr get_curr_arg(WriteObjVar v, BinRelItVar  it, Nat a)  = set_var(v, get_curr_arg(it, if a :: <0..1> then a else undefined));
Instr get_curr_arg(WriteObjVar v, TernRelItVar it, Nat a)  = set_var(v, get_curr_arg(it, if a :: <0..2> then a else undefined));

Instr maybe_op(Instr instr, Bool cond) = if cond then instr else no_op;

Instr block_success_if(BoolExpr c, BoolVar res_var)     = do_if(c, (set_bvar(res_var, true), exit_block));
Instr block_failure_if(BoolExpr c, BoolVar res_var)     = do_if(c, (set_bvar(res_var, false), exit_block));
Instr block_failure_if_not(BoolExpr c, BoolVar res_var) = block_failure_if(neg(c), res_var);
