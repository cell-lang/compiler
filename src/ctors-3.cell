OptTagRecRepr opt_tag_rec_repr(Symbol t, Nat i) = opt_tag_rec_repr(tag: t, index: i);

LocVar lvar(Nat n)      = :lvar(n);

ElemVar evar(Nat id, <Nat, IntVar> i)   = evar(id: id, idx: i);
ElemVar evar(Nat id, IntVar v, Nat i)   = evar(id: id, idx: add(val1: v, val2: i));

CaptVar capt_var(Nat n) = :capt_var(n);

PendingInputVar pending_input_var(Atom id)  = :pending_input_var(id);
PendingStateVar pending_state_var(Atom id)  = :pending_state_var(id);

VecVar vvar(Nat n, NzNat s) = vvar(id: n, size: s);

LocBoolVar bvar(<Symbol, Nat> id) = :bvar(id);
BoolFnArg  bool_arg(Nat id)       = :bool_arg(id);
LocBoolVar bool_arg(Symbol id)    = :bvar(id);

QualBoolVar qual_bool_var(LocAutoVar av, MembBoolVar mv) = qual_bool_var(auto_var: av, memb_var: mv);

MembBoolVar nested_db_spent(NestedDBVar v) = :nested_db_spent(v);

MembBoolVar cond_value_var(Nat n)             = :cond_value_var(n);
MembBoolVar cond_is_def_var(Nat n)            = :cond_is_def_var(n);

MembBoolVar watched_signal_up_to_date_var(Atom id)  = :watched_signal_up_to_date_var(id);

MembBoolVar up_to_date_var(BlockNodeId n)     = :up_to_date_var(n);

MembBoolVar is_new    = :is_new;

IntVar curr_time      = :curr_time;
IntVar update_time    = :update_time;

IntVar update_expr_index = :update_expr_index;

IntVar elapsed_time(LocAutoVar v) = :elapsed_time(v);

ProjdIntVar changed_output(<Nat, IntVar> i)  = changed_output(index: i);

LocIntVar ivar(<Symbol, Nat> id)  = :ivar(id);
IntFnArg  int_arg(Nat id)         = :int_arg(id);
LocIntVar int_arg(Symbol id)      = :ivar(id);

Int32Var ivar32(Nat n) = :ivar32(n);

MembIntVar update_source_var(Atom n)                            = :update_source_var(n);
MembIntVar null_locks_count_var(Atom id)                        = :null_locks_count_var(id);
MembIntVar update_count_var(Nat l)                              = :update_count_var(l);
MembIntVar nodes_to_update_var(Nat l, <Nat, IntVar> i)          = nodes_to_update_var(level: l, index: i);
MembIntVar next_trigger_time_var(Atom a)                        = :next_trigger_time_var(a);
MembIntVar curr_time_slot_var(Atom a)                           = :curr_time_slot_var(a);
MembIntVar time_triggers_count_var                              = :time_triggers_count_var;
MembIntVar trigger_times_heap_var(<0..0> i)                     = :trigger_times_heap_var(i);
MembIntVar time_varying_cond_ids_heap_var(<0..0> i)             = :time_varying_cond_ids_heap_var(i);
MembIntVar last_update_time                                     = :last_update_time;
MembIntVar elapsed_time                                         = :elapsed_time;
MembIntVar changed_outputs_count                                = :changed_outputs_count;
MembIntVar nested_auto_int_var(NestedAutoVar av, MembIntVar mv) = nested_auto_int_var(auto_var: av, memb_var: mv);

LocFloatVar fvar(<Symbol, Nat> id)  = :fvar(id);
FloatFnArg  float_arg(Nat id)       = :float_arg(id);
LocFloatVar float_arg(Symbol id)    = :fvar(id);

LocOptTagRecVar opt_tag_rec_var(<Symbol, Nat> id, Symbol s, Nat i) = opt_tag_rec_var(id: id, tag: s, index: i);

OptTagRecFnArg  opt_tag_rec_fn_arg(Nat id, Symbol s, Nat i) = opt_tag_rec_fn_arg(id: id, tag: s, index: i);
LocOptTagRecVar opt_tag_rec_fn_arg(Symbol id, Symbol s, Nat i) = opt_tag_rec_var(id: id, tag: s, index: i);

ArrayVar avar(Nat id, LowLevelEltRepr r) = avar(id: id, repr: r);

MembObjVar watched_signal_value_var(Atom id)                  = :watched_signal_value_var(id);

IntConst time_slot_length(AutoSymbol a, Atom id, IntExpr i) = time_slot_length(automaton: a, expr_id: id, time_slot: i);

MembIntVectVar nodes_to_update_vect_var(Nat l, NzNat s) = nodes_to_update_vect_var(level: l, size: s);
MembIntVectVar changed_outputs(NzNat s)                 = changed_outputs(size: s);

StreamVar svar(Nat n) = :svar(n);

SetItVar set_it_var(Nat n)          = :set_it_var(n);
SeqItVar seq_it_var(Nat n)          = :seq_it_var(n);
BinRelItVar bin_rel_it_var(Nat n)   = :bin_rel_it_var(n);
TernRelItVar tern_rel_it_var(Nat n) = :tern_rel_it_var(n);

TableItVar table_it_var(Nat id, NzNat a, Bool s) = table_it_var(id: id, arity: a, symmetric: s);

TableVar table_var(Symbol s)        = :table_var(s);
TableVar table_var(Symbol s, Nat n) = :unique_table_var(s, n);

TableVar table_var(RelVar v)        = rel_var(s?) = table_var(s);
TableVar table_var(RelVar v, Nat n) = rel_var(s?) = table_var(s, n);

QualTableVar qual_table_var(AnyDBVar db, TableVar v) = qual_table_var(db_var: db, table_var: v);

MembTestPredId memb_test(Atom a)            = :memb_test(a);
MembTestPredId memb_test(Nat n)             = :memb_test(n);
MembTestPredId memb_test(Atom a1, Atom a2)  = :memb_test(a1, a2);
MembTestPredId memb_test(Atom a, Nat n)     = :memb_test(a, n);

SubAggrFnId red_var_init(AggrFnId f, StdVar v)    = :red_var_init(f, v);
SubAggrFnId red_vars_merge(AggrFnId f, StdVar v)  = :red_vars_merge(f, v);
SubAggrFnId final_value_yield(AggrFnId f)         = :final_value_yield(f);
SubAggrFnId null_value(AggrFnId f)                = :null_value(f);

AtomicExpr empty_seq = :empty_seq;
AtomicExpr empty_rel = :empty_rel;

BoolNatOp is_symb(ObjExpr e)                              = :is_symb(e);
BoolNatOp is_int(ObjExpr e)                               = :is_int(e);
BoolNatOp is_float(ObjExpr e)                             = :is_float(e);
BoolNatOp is_ne_set(ObjExpr e)                            = :is_ne_set(e);
BoolNatOp is_ne_seq(ObjExpr e)                            = :is_ne_seq(e);
BoolNatOp is_ne_map(ObjExpr e)                            = :is_ne_map(e);
BoolNatOp is_ne_bin_rel(ObjExpr e)                        = :is_ne_bin_rel(e);
BoolNatOp is_ne_tern_rel(ObjExpr e)                       = :is_ne_tern_rel(e);
BoolNatOp is_tagged_obj(ObjExpr e)                        = :is_tagged_obj(e);
BoolNatOp are_eq(ObjExpr e1, ObjExpr e2)                  = :are_eq(e1, e2);
BoolNatOp is_lt(IntExpr e1, IntExpr e2)                   = is_lt(expr1: e1, expr2: e2);
BoolNatOp is_le(IntExpr e1, IntExpr e2)                   = is_le(expr1: e1, expr2: e2);
BoolNatOp is_gt(IntExpr e1, IntExpr e2)                   = is_lt(expr1: e2, expr2: e1);
BoolNatOp is_ge(IntExpr e1, IntExpr e2)                   = is_le(expr1: e2, expr2: e1);
BoolNatOp is_flt(FloatExpr e1, FloatExpr e2)              = :is_flt(e1, e2);
BoolNatOp is_fle(FloatExpr e1, FloatExpr e2)              = :is_fle(e1, e2);
BoolNatOp is_out_of_range(ItVar v)                        = :is_out_of_range(v);
BoolNatOp is_blank(<AnySignalVar, LocVar, PendingStateVar> v) = :is_blank(v);
BoolNatOp is_null(AnyNullableVar v)                       = :is_null(v);
BoolNatOp has_elem(ObjExpr s, ObjExpr e)                  = has_elem(set: s, elt: e);
BoolNatOp has_field(ObjExpr r, SymbObj f)                 = has_field(record: r, field: f);
BoolNatOp contains(ObjExpr r, ObjExpr+ t)                 = contains(coll: r, entry: t);
BoolNatOp table_contains(AnyTableVar tv, Maybe[Int32Var]+ vs) = table_contains(table: tv, tuple: vs);

## THESE ARE ALL DEPRECATED AND SHOULD BE REMOVED
BoolNatOp is_eq(BoolExpr e1, BoolExpr e2)       = are_eq(bool_obj(e1), bool_obj(e2));
BoolNatOp is_eq(IntExpr e1, IntExpr e2)         = are_eq(int_obj(e1), int_obj(e2));
BoolNatOp is_eq(ObjExpr e1, ObjExpr e2)         = are_eq(e1, e2);
BoolNatOp inline_is_eq(ObjExpr e1, ObjExpr e2)  = are_eq(e1, e2);


IntExpr get_int_val(ObjExpr expr) =
  int_obj(e?)       = e,
  object(<*..*> n?) = n,
  _                 = :get_int_val(expr);

IntNatOp minus(IntExpr e)                               = :minus(e);
IntNatOp add(IntExpr e1, IntExpr e2)                    = add(val1: e1, val2: e2);
IntNatOp sub(IntExpr e1, IntExpr e2)                    = sub(val1: e1, val2: e2);
IntNatOp mult(IntExpr e1, IntExpr e2)                   = mult(val1: e1, val2: e2);
IntNatOp div(IntExpr e1, IntExpr e2)                    = div(val1: e1, val2: e2);
IntNatOp mod_op(IntExpr e1, IntExpr e2)                 = mod(val1: e1, val2: e2); ## THIS SHOULD JUST BE NAMED mod, BUT THAT WOULD CONFLICT WITH THE INTEGER MOD OPERATION
IntNatOp bitwise_and(IntExpr e1, IntExpr e2)            = :bitwise_and(e1, e2);
IntNatOp bitwise_or(IntExpr e1, IntExpr e2)             = :bitwise_or(e1, e2);
IntNatOp bitwise_xor(IntExpr e1, IntExpr e2)            = :bitwise_xor(e1, e2);
IntNatOp float_bits(FloatExpr e)                        = :float_bits(e);
IntNatOp mantissa(FloatExpr e)                          = :mantissa(e);
IntNatOp dec_exp(FloatExpr e)                           = :dec_exp(e);
IntNatOp unique_nat                                     = :unique_nat;
IntNatOp rand_nat(ObjExpr e)                            = :rand_nat(get_int_val(e));
IntNatOp ticks                                          = :ticks;

Int32NatOp bool_to_bit(BoolExpr e)                        = :bool_to_bit(e);
Int32NatOp get_size(ObjExpr e)                            = :get_size(e);
Int32NatOp cast_int32(IntExpr e)                          = :cast_int32(e);
Int32NatOp add32(Int32Expr e1, Int32Expr e2)              = :add32(e1, e2);
Int32NatOp get_tuple_field(TableItVar v, Nat i)           = get_tuple_field(iter: v, field: i);
Int32NatOp lookup_value(AnyValueStoreId s, AtomicExpr e)  = lookup_value(store: s, value: e);
Int32NatOp lookup_value_ex(ValueStoreId s, AtomicExpr e)  = lookup_value_ex(store: s, value: e);

FloatExpr float_value(ObjExpr expr) =
  float_obj(e?) = e,
  _             = :float_value(expr);

FloatNatOp neg_float(FloatExpr val)                 = :neg_float(val);
FloatNatOp add_floats(FloatExpr lv, FloatExpr rv)   = :add_floats(lv, rv);
FloatNatOp sub_floats(FloatExpr lv, FloatExpr rv)   = :sub_floats(lv, rv);
FloatNatOp mult_floats(FloatExpr lv, FloatExpr rv)  = :mult_floats(lv, rv);
FloatNatOp div_floats(FloatExpr lv, FloatExpr rv)   = :div_floats(lv, rv);
FloatNatOp exp_floats(FloatExpr lv, FloatExpr rv)   = :exp_floats(lv, rv);
FloatNatOp square_root(FloatExpr value)             = :square_root(value);
FloatNatOp int_to_float(IntExpr value)              = :int_to_float(value);


ObjExpr obj_expr(BoolExpr  expr)  = bool_obj(expr);
ObjExpr obj_expr(IntExpr   expr)  = int_obj(expr);
ObjExpr obj_expr(FloatExpr expr)  = float_obj(expr);
ObjExpr obj_expr(ObjExpr   expr)  = expr;


ObjExpr bool_obj(BoolExpr expr) =
  are_eq(e1?, e2?)  = if   e1 == obj_true then e2
                      elif e2 == obj_true then e1
                                          else :bool_obj(expr),
  _               = :bool_obj(expr);


ObjExpr int_obj(IntExpr expr) =
  get_int_val(e?) = e,
  _               = :int_obj(expr);


ObjExpr float_obj(FloatExpr expr) =
  float_value(e?) = e,
  _               = :float_obj(expr);


ObjNatOp at(ObjExpr s, IntExpr i)                 = at(seq: s, idx: i);
ObjNatOp lookup(ObjExpr r, ObjExpr k)             = lookup(rel: r, key: k);
ObjNatOp lookup_field(ObjExpr e, SymbObj f)       = lookup_field(record: e, field: f, repr: nothing);
ObjNatOp get_tag(ObjExpr e)                       = :get_tag(e);
ObjNatOp get_inner_obj(ObjExpr e)                 = :get_inner_obj(e);
ObjNatOp get_curr_obj(<SetItVar, SeqItVar> it)    = :get_curr_obj(it);
ObjNatOp get_curr_arg(BinRelItVar v,  <0..1> a)   = get_curr_arg(var: v, arg: a);
ObjNatOp get_curr_arg(TernRelItVar v, <0..2> a)   = get_curr_arg(var: v, arg: a);
ObjNatOp rand_elem(ObjExpr s)                     = :rand_elem(s);

ObjNatOp lookup_field(ObjExpr e, SymbObj f, Maybe[LowLevelRepr] r) {
  assert e :: OptTagRecExpr or r == nothing;
  assert not (e :: OptTagRecExpr and r == nothing); ## JUST A TEMPORARY CHECK, IT'S PROBABLY NOT ALWAYS TRUE
  return lookup_field(record: e, field: f, repr: r);
}

BoolFnCall is_member(MembTestPredId p, AtomicExpr e)  = is_member(pred: p, obj: e);
BoolFnCall state_is_def(AnyAutoVar v, AutoSymbol t)   = state_is_def(auto_var: v, type: t);

BoolExpr neg(BoolExpr e) =
  neg(ne?)  = ne,
  _         = :neg(e);

BoolExpr and(BoolExpr+ es)      = if |es| != 1 then :and(es)      else only(es);
BoolExpr or(BoolExpr+ es)       = if |es| != 1 then :or(es)       else only(es);
BoolExpr and_then(BoolExpr+ es) = if |es| != 1 then :and_then(es) else only(es);
BoolExpr or_else(BoolExpr+ es)  = if |es| != 1 then :or_else(es)  else only(es);

BoolExpr and([+BoolExpr] es)  = and(rand_sort(es));
BoolExpr or([+BoolExpr] es)   = or(rand_sort(es));

RefObjExpr lookup_surrogate(AnyValueStoreId s, IntExpr e) = lookup_surrogate(store: s, surrogate: e);

OptTagRecExpr cast_opt_tag_rec(Symbol s, Nat i, ObjExpr e) = cast_opt_tag_rec(tag: s, index: i, expr: e);

// Basic instructions

Instr init_stream(StreamVar v)          = :init_stream(v);
Instr append(StreamVar v, AtomicExpr e) = append(stream: v, obj: e);

Instr mk_set(WriteObjVar v, StreamVar s)            = set_var(v, mk_set_from_stream(stream: s));
Instr mk_set(WriteObjVar v, VecVar es, IntExpr s)   = set_var(v, mk_set(elems: es, size: s));
Instr mk_set(WriteObjVar v, ArrayVar a)             = set_var(v, mk_set_from_array(array: a, size: nothing));
Instr mk_set(WriteObjVar v, ArrayVar a, IntExpr s)  = set_var(v, mk_set_from_array(array: a, size: just(s)));

Instr mk_seq(WriteObjVar v, StreamVar s)            = set_var(v, mk_seq_from_stream(stream: s));
Instr mk_seq(WriteObjVar v, VecVar es, IntExpr s)   = set_var(v, mk_seq(elems: es, size: s));
Instr mk_seq(WriteObjVar v, ArrayVar a)             = set_var(v, mk_seq_from_array(array: a, size: nothing));
Instr mk_seq(WriteObjVar v, ArrayVar a, IntExpr s)  = set_var(v, mk_seq_from_array(array: a, size: just(s)));

Instr build_const_int_seq(WriteObjVar v, Nat id)    = set_var(v, build_const_int_seq(seq_id: id));

Instr mk_map(WriteObjVar v, StreamVar ks, StreamVar vs)       = set_var(v, mk_map_from_streams(key_stream: ks, value_stream: vs));
Instr mk_map(WriteObjVar v, VecVar ks, VecVar vs, IntExpr s)  = set_var(v, mk_map(keys: ks, values: vs, size: s));

Instr mk_rel(WriteObjVar v, StreamVar s1, StreamVar s2)       = set_var(v, mk_bin_rel_from_streams(streams: (s1, s2)));
Instr mk_rel(WriteObjVar v, VecVar c1, VecVar c2, IntExpr s)  = set_var(v, mk_bin_rel(cols: (c1, c2), size: s));
Instr mk_rel(WriteObjVar v, ArrayVar c1, ArrayVar c2, Bool b) = set_var(v, mk_bin_rel_from_arrays(col1: c1, col2: c2, size: nothing, is_map: b));

Instr mk_rel(WriteObjVar v, StreamVar s1, StreamVar s2, StreamVar s3)   = set_var(v, mk_tern_rel_from_streams(streams: (s1, s2, s3)));
Instr mk_rel(WriteObjVar v, VecVar c1, VecVar c2, VecVar c3, IntExpr s) = set_var(v, mk_tern_rel(cols: (c1, c2, c3), size: s));
Instr mk_rel(WriteObjVar v, ArrayVar c1, ArrayVar c2, ArrayVar c3)      = set_var(v, mk_tern_rel_from_arrays(col1: c1, col2: c2, col3: c3, size: nothing));

Instr mk_tagged_obj(WriteObjVar v, AtomicExpr t, AtomicExpr o) = set_var(v, mk_tagged_obj(tag: t, obj: o));

FloatExpr float_value(ObjExpr expr) =
  float_obj(e?) = e,
  _             = :float_value(expr);

FloatNatOp neg_float(FloatExpr val)                 = :neg_float(val);
FloatNatOp add_floats(FloatExpr lv, FloatExpr rv)   = :add_floats(lv, rv);
FloatNatOp sub_floats(FloatExpr lv, FloatExpr rv)   = :sub_floats(lv, rv);
FloatNatOp mult_floats(FloatExpr lv, FloatExpr rv)  = :mult_floats(lv, rv);
FloatNatOp div_floats(FloatExpr lv, FloatExpr rv)   = :div_floats(lv, rv);
FloatNatOp exp_floats(FloatExpr lv, FloatExpr rv)   = :exp_floats(lv, rv);
FloatNatOp square_root(FloatExpr value)             = :square_root(value);
FloatNatOp int_to_float(IntExpr value)              = :int_to_float(value);

Instr mk_record(WriteObjVar v, [+SymbObj -> AtomicExpr] fs) = set_var(v, mk_record(fields: fs));

Instr inst_opt_tag_rec(LocOptTagRecVar v, Symbol s, Nat i) = set_var(v, inst_opt_tag_rec(tag: s, repr_idx: i));

Instr get_seq_slice(WriteObjVar v, AtomicExpr s, IntExpr f, IntExpr l)  = set_var(v, get_seq_slice(seq: s, idx_first: f, len: l));
Instr append_to_seq(WriteObjVar v, AtomicExpr s, AtomicExpr e)          = set_var(v, append_to_seq(seq: s, new_elem: e));
Instr update_seq_at(WriteObjVar rv, AtomicExpr s, IntExpr i, AtomicExpr v) = set_var(rv, update_seq_at(seq: s, idx: i, value: v));

Instr join_seqs(WriteObjVar v, AtomicExpr l, AtomicExpr r)              = set_var(v, join_seqs(left: l, right: r));
Instr rev_seq(WriteObjVar v, AtomicExpr s)                              = set_var(v, rev_seq(seq: s));
Instr set_at(WriteObjVar v, IntExpr i, AtomicExpr x)                    = set_at(var: v, idx: i, value: x);

Instr lookup_field(WriteObjVar v, ObjExpr e, SymbObj f)                        = set_var(v, lookup_field(e, f));
Instr lookup_field(WriteObjVar v, ObjExpr e, SymbObj f, Maybe[LowLevelRepr] r) = set_var(v, lookup_field(e, f, r));

Instr internal_sort(WriteObjVar v, AtomicExpr s) = set_var(v, internal_sort(set: s));

Instr parse_value(WriteObjVar v, AtomicExpr s)  = set_var(v, parse_value(value: s));
Instr print_value(WriteObjVar v, AtomicExpr s)  = set_var(v, print_value(value: s));

Instr copy_state(WriteObjVar rv, AnyDBVar dv, DBSymbol t) = set_var(rv, copy_state(var: dv, type: t));
Instr copy_table(WriteObjVar ov, [+TableVar -> Table] ts, Nat+ p) = set_var(ov, copy_table(tables: ts, perm: p));

Instr copy_persistent_state(WriteObjVar rv, AnyAutoVar av, AutoSymbol t) = set_var(rv, copy_persistent_state(var: av, type: t));

Instr lookup_surrogate(WriteObjVar v, AnyValueStoreId s, IntExpr e) = set_var(v, lookup_surrogate(s, e));

Instr read_pending_var(WriteObjVar tv, <PendingStateVar, PendingInputVar> sv) = set_var(tv, :read_pending_var(sv));

Instr alloc_array(ArrayVar v, Int32Expr n) = alloc_array(var: v, size: n);

Instr write_array(ArrayVar v, Int32Expr i, ObjExpr e) =
  write_array(var: v, idx: i, value: low_level_expr(v.repr, e));

Instr write_rec_field(LocOptTagRecVar v, Symbol s, AnyTypeExpr e, Bool b) = write_rec_field(var: v, label: s, value: e, optional: b);
Instr finish_init(LocOptTagRecVar v) = finish_init(var: v);

Instr get_iter(SeqItVar v, AtomicExpr s) = get_seq_iter(var: v, src: s);
Instr get_iter(SetItVar v, AtomicExpr s) = get_set_iter(var: v, src: s);

Instr get_iter(BinRelItVar v, AtomicExpr r, (Maybe[AtomicExpr], Maybe[AtomicExpr]) as) =
  get_bin_rel_iter(var: v, src: r, args: as);

Instr get_iter(TernRelItVar v, AtomicExpr r, (Maybe[AtomicExpr], Maybe[AtomicExpr], Maybe[AtomicExpr]) as) =
  get_tern_rel_iter(var: v, src: r, args: as);

Instr get_any_rel_iter(SetItVar v, AtomicExpr r, Maybe[AtomicExpr]* as) =
  if as == (nothing) then get_iter(v, r) else undefined;

Instr get_any_rel_iter(BinRelItVar v, AtomicExpr r, Maybe[AtomicExpr]* as) =
  get_iter(v, r, if |as| == 2 then as else undefined);

Instr get_any_rel_iter(TernRelItVar v, AtomicExpr r, Maybe[AtomicExpr]* as) =
  get_iter(v, r, if |as| == 3 then as else undefined);

Instr move_forward(ItVar v) = :move_forward(v);

Instr set_var(<WriteObjVar, ImplArg> v, ObjExpr e)  = set_var(var: v, value: e);
Instr set_var(LocOptTagRecVar v, OptTagRecExpr e)   = set_var(var: v, value: e);

Instr set_var(LocOptTagRecVar v, <InlineObj, StdObjVar, ObjNatOp> e) =
  set_var(var: v, value: cast_opt_tag_rec(v.tag, v.index, e));

Instr set_bvar(BoolVar v, BoolExpr e)       = set_bvar(var: v, value: e);
Instr set_ivar(IntVar v, IntExpr e)         = set_ivar(var: v, value: e);
Instr set_ivar32(Int32Var v, Int32Expr e)   = set_ivar32(var: v, value: e);
Instr set_fvar(FloatVar v, FloatExpr e)     = set_fvar(var: v, value: e);

Instr set_var(<WriteObjVar, LocOptTagRecVar> v, RefObjExpr e)  = set_rc_var(var: v, value: e);

Instr init_memb_var(<MembVar, SignalVar, PrevVarValue, MembObjVar, PendingInputVar, PendingStateVar> v, <blank, undefined> s) = init_memb_var(var: v, new_state: s);
Instr reset_memb_var(<SignalVar, PrevVarValue, MembVar, PendingInputVar> v, <blank, undefined> s) = reset_memb_var(var: v, new_state: s);

Instr clear_loc_var(LocVar v) = :clear_loc_var(v);
Instr nullify_var(<StdVar, LocVar, LocOptTagRecVar> v) = :nullify_var(v);

Instr make_var_undef(SignalVar v) = reset_memb_var(v, :undefined);
Instr make_var_undef(LocVar v)      = clear_loc_var(v);

Instr terminate(Bool b) = terminate(hard_fail: b);
Instr terminate = terminate(false);

Instr add_ref(ObjVar v)                     = :add_ref(v);
Instr release(<ObjVar, PendingInputVar> v)  = :release(v);

Instr print_obj(AtomicExpr x) = print_obj(obj: x);

Instr ret_val(AnyTypeExpr e) = :ret_val(e);

Instr no_op = :no_op;

Instr branch(BoolExpr cond, Instr* body, Instr* neg_body) {
  if body != ():
    if |body| == 1:
      branch_instr = match (only(body))
        branch() i? = just(i),
        _           = nothing;

      if branch_instr != nothing:
        branch_instr = value(branch_instr);
        if branch_instr.when_false == neg_body:
          return branch(and_then(cond, branch_instr.cond), branch_instr.when_true, neg_body);
        ;
      ;
    ;
    return branch(cond: cond, when_true: body, when_false: neg_body);

  else
    return branch(neg(cond), nonempty(neg_body), ());
  ;
}

Instr branch_or_no_op(BoolExpr c, Instr* t, Instr* f) =
  if t == () and f == ()
    then no_op
    else branch(c, t, f);

Instr repeat(Instr+ b) = :repeat(b);
Instr break_loop       = :break_loop;

Instr execute_block(Instr+ b) = :execute_block(b);
Instr exit_block              = :exit_block;

Instr* opt_execute_block(Instr* b) = (execute_block(b) if b != ());

Instr try_block(LocVar v, Instr+ b) = try_block(var: v, body: b);

Instr switch_on_nat(IntExpr e, Instr*+ cs) = switch_on_nat(value: e, cases: cs);

Instr symb_switch(ObjExpr e, [+([+SymbObj], Instr+)] cs, Instr* eis) = symb_switch(value: e, cases: cs, else: eis);

Instr* opt_symb_switch(ObjExpr expr, [([+SymbObj], Instr+)] cases, Instr* else_code) {
  return else_code if cases == [];

  if |cases| == 1:
    symbs, code = only(cases);
    if |symbs| < 3:
      cond = or([are_eq(expr, s) : s <- symbs]);
      return (branch(cond, code, else_code));
    ;
  ;

  return (symb_switch(expr, cases, else_code));
}

Instr call_proc(AnyWriteVar v, ObjFnName n, AnyTypeExpr* as, BoundCls* cas) = call_proc(var: v, name: n, args: as, cls_args: cas);
Instr call_proc(ObjFnName n, AnyTypeExpr* as, BoundCls* cas) = call_proc(name: n, args: as, cls_args: cas);

Instr call_cls(WriteObjVar v, AnyClsVar cv, AtomicExpr+ as) = call_cls(var: v, cls_var: cv, args: as);

Instr queue_update(AutoSymbol s, BlockNodeId id)        = queue_update(type: s, id: id, args: ());
Instr queue_update(AutoSymbol s, BlockNodeId id, Nat a) = queue_update(type: s, id: id, args: (a));

Instr insert_timer(AutoSymbol a, Nat i, IntExpr t)  = insert_timer(type: a, idx: i, time: t);
Instr clear_timer(AutoSymbol a, IntExpr i)          = clear_timer(type: a, idx: i);

Instr auto_pre_init(AnyAutoVar v, AutoSymbol t) = auto_pre_init(var: v, type: t);
Instr auto_cleanup(AnyAutoVar v, AutoSymbol t)  = auto_cleanup(var: v, type: t);

Instr set_input(AnyAutoVar v, AutoSymbol t, Atom i, AtomicExpr e) = set_input(var: v, type: t, input: i, value: e);

Instr clear_input(AnyAutoVar v, AutoSymbol t, Atom i) = clear_input(var: v, type: t, input: i);
Instr clear_input(AutoSymbol t, Atom i)               = clear_input(type: t, input: i);

Instr auto_init(AnyAutoVar v, AutoSymbol t)                   = auto_init(var: v, type: t);
Instr auto_init(AutoSymbol t)                                 = auto_init(type: t);

Instr auto_update_node(AutoSymbol t, BlockNodeId n)           = auto_update_node(type: t, node: n);
Instr auto_update_node(AutoSymbol t, BlockNodeId n, IntVar v) = auto_update_node(type: t, node: n, time_var: v);

Instr auto_apply(AnyAutoVar v, AutoSymbol t)  = auto_apply(var: v, type: t);
Instr auto_apply(AutoSymbol t)                = auto_apply(type: t);

Instr set_persistent_state(AnyAutoVar v, AtomicExpr e, AutoSymbol t) = set_persistent_state(auto_var: v, state: e, type: t);

Instr init_db(AnyDBVar v, LocDBVar* ls, DBSymbol t)  = init_db(db_var: v, links: ls, type: t);
Instr cleanup_db(AnyDBVar v, DBSymbol t)  = cleanup_db(db_var: v, type: t);
Instr send_msg(AnyDBVar v, DBSymbol t, AtomicExpr m, Bool r) = send_msg(db_var: v, type: t, msg: m, is_root: r);
Instr send_msg(AnyDBVar v, DBSymbol t, AtomicExpr m, Bool r, BoolVar rv) = send_msg(db_var: v, type: t, msg: m, is_root: r, res_var: rv);
Instr try_update(DBSymbol t, UpdateId id, AtomicExpr* as) = try_update(type: t, update_id: id, args: as);

Instr set_state(BoolVar rv, AnyDBVar v, AtomicExpr e, DBSymbol t) = set_state(res_var: rv, db_var: v, state: e, type: t);

Instr invoke_auto_method(WriteObjVar rv, AutoSymbol t, MethodId id, AtomicExpr* as) =
  invoke_auto_method(res_var: rv, type: t, method_id: id, args: as);

Instr invoke_auto_method(WriteObjVar rv, AnyAutoVar av, AutoSymbol t, MethodId id, AtomicExpr* as) =
  invoke_auto_method(res_var: rv, auto_var: av, type: t, method_id: id, args: as);

Instr invoke_db_method(WriteObjVar rv, DBSymbol t, MethodId id, AtomicExpr* as) =
  invoke_db_method(res_var: rv, type: t, method_id: id, args: as);

Instr invoke_db_method(WriteObjVar rv, AnyDBVar dv, DBSymbol t, MethodId id, AtomicExpr* as) =
  invoke_db_method(res_var: rv, db_var: dv, type: t, method_id: id, args: as);

Instr init_value_store(ValueStoreId s)    = init_value_store(store: s);
Instr cleanup_value_store(ValueStoreId s) = cleanup_value_store(store: s);
Instr init_table(TableVar v, Table t)     = init_table(table_var: v, table: t);
Instr cleanup_table(TableVar v, Table t)  = cleanup_table(table_var: v, table: t);

// Instr set_table(RelVar v, Table t, AtomicExpr e, Nat+ p) = set_table(relvar: v, table: t, state: e, perm: p);

Instr get_table_iter(TableItVar v, AnyTableVar t, Maybe[Int32Var]+ as) {
  assert (a <~ as : a == nothing);
  assert v.arity == |as|;
  return get_table_iter(it_var: v, table: t, args: as);
}

Instr queue_deletes(TableVar tv, Maybe[Int32Var]+ as, Bool s) = queue_deletes(table_var: tv, args: as, symmetric: s);

Instr queue_insert_value(Int32Var v, ValueStoreId s, AtomicExpr e) = queue_insert_value(res_var: v, store: s, value: e);
Instr lookup_or_queue_insert_value(Int32Var v, ValueStoreId s, AtomicExpr e) = lookup_or_queue_insert_value(res_var: v, store: s, value: e);
Instr queue_insert_tuple(TableVar v, Int32Var+ t) = queue_insert_tuple(table_var: v, tuple: t);

Instr immediate_insert_or_add_ref(Int32Var sv, ValueStoreId s, AtomicExpr v) = immediate_insert_or_add_ref(res_var: sv, store: s, value: v);
Instr immediate_insert_tuple(TableVar v, Int32Var+ as) = immediate_insert_tuple(table_var: v, tuple: as);

Instr push_call_info(<FnId, ProcSymbol> f, ObjExpr* as) = push_call_info(fn_name: f, args: as);
Instr pop_call_info = :pop_call_info;

Instr log_runtime_failure(Bool b, String f, NzNat l, Maybe[String] t, (<StdVar, ImplArg>, ObjExpr)* vs) =
  log_runtime_failure(is_assert: b, file: f, line: l, text: t, vars: vs);

////////////////////////////////////////////////////////////////////////////////

CaptClsVar capt_cls_var(Nat n) = :capt_cls_var(n);

ClsDef cls_def(NzNat a, Instr+ b) = cls_def(arity: a, body: b);

BoundCls bound_cls(ClsDef c, ObjExpr* vs, AnyClsVar* cs) = bound_cls(cls: c, capt_vars: vs, capt_cls_vars: cs);

ClsProcArg cls(ClsVar v, NzNat a) = cls(var: v, arity: a);

BoolProcDef bool_proc_def(MembTestPredId name, NzNat arity, Instr+ body) =
  bool_proc_def(
    name:  name,
    arity: arity,
    body:  body
  );

ConstBlockData time_slots_len(Atom id, Nat+ ls) = time_slots_len(expr_id: id, lengths: ls);

StdBlockNodeId        std_block_node_id(Atom id)            = :std_block_node_id(id);
CondNodeId            cond_node_id(Nat id)                  = :cond_node_id(id);
NestedAutoNodeId      nested_auto_node_id(Atom id)          = :nested_auto_node_id(id);
NestedAutoInputNodeId nested_auto_input_id(Atom a, Atom i)  = nested_auto_input_id(auto: a, input: i);

MethodId method_id(MethodSymbol s, Nat a) = method_id(symbol: s, arity: a);
UpdateId update_id(UpdateSymbol s, Nat a) = update_id(symbol: s, arity: a);

MethodId method_id(MethodSymbol s, Nat a, Nat id) = method_id(symbol: s, arity: a, id: id);
UpdateId update_id(UpdateSymbol s, Nat a, Nat id) = update_id(symbol: s, arity: a, id: id);

UpdateId main_handler        = :main_handler;
UpdateId handler_id(Nat n)   = :handler_id(n);

ValueStoreId value_store_id(Nat n)  = :value_store_id(n);

NestedValueStoreId nested_value_store_id(AnyDBVar v, ValueStoreId id) =
  nested_value_store_id(db_var: v, store_id: id);

Table table(ValueStoreId+ vs, [[+Nat]] ks, NeType+ ts, Nat+ p, Bool s) {
  assert |vs| == |ts| and |vs| == |p|;
  return table(value_stores: vs, keys: ks, col_types: ts, applied_perm: p, symmetric: s);
}

ForeignKeyType unary_binary(Nat i)  = if i :: <0..1> then :unary_binary(i)  else undefined;
ForeignKeyType unary_ternary(Nat i) = if i :: <0..2> then :unary_ternary(i) else undefined;
ForeignKeyType binary_unary(Nat i)  = if i :: <0..1> then :binary_unary(i)  else undefined;
ForeignKeyType ternary_unary(Nat i) = if i :: <0..2> then :ternary_unary(i) else undefined;

BlockForeignKey foreign_key(TableVar r1, TableVar r2, ForeignKeyType t) =
  foreign_key(origin: r1, target: r2, type: t);

CompiledMethod compiled_method(Maybe[StdVar]* as, NeType* ats, [+MembTestPredId*] mps, NeType rt, Instr* c) {
  assert |as| == |ats|;
  assert not (ps <- mps : |ps| != |ats|);
  return compiled_method(args_vars: as, args_types: ats, args_memb_preds: mps, ret_type: rt, code: c);
}

CompiledUpdate compiled_update(<StdVar, FnArg>* as, Instr* b) = compiled_update(args_vars: as, body: b);

////////////////////////////// Derived expressions /////////////////////////////

BoolExpr bool_value(ObjExpr expr) = are_eq(expr, obj_true);

BoolExpr and(BoolExpr e1, BoolExpr e2)      = and((e1, e2));
BoolExpr or(BoolExpr e1, BoolExpr e2)       = or((e1, e2));
BoolExpr and_then(BoolExpr e1, BoolExpr e2) = and_then((e1, e2));
BoolExpr or_else(BoolExpr e1, BoolExpr e2)  = or_else((e1, e2));

BoolExpr and(BoolExpr e1, BoolExpr e2, BoolExpr e3)      = and((e1, e2, e3));
BoolExpr or(BoolExpr e1, BoolExpr e2, BoolExpr e3)       = or((e1, e2, e3));
BoolExpr and_then(BoolExpr e1, BoolExpr e2, BoolExpr e3) = and_then((e1, e2, e3));
BoolExpr or_else(BoolExpr e1, BoolExpr e2, BoolExpr e3)  = or_else((e1, e2, e3));

BoolExpr is_empty_seq(ObjExpr e)  = is_eq(e, empty_seq);
BoolExpr is_empty_rel(ObjExpr e)  = is_eq(e, empty_rel);

BoolExpr is_seq(ObjExpr e)  = or(is_empty_seq(e), is_ne_seq(e));
BoolExpr is_set_value(ObjExpr e)  = or(is_empty_rel(e), is_ne_set(e)); // Renamed because of conflict with is_set() constructors

BoolExpr is_not_blank(<AnySignalVar, LocVar> v)               = neg(is_blank(v));
BoolExpr is_not_null(AnyNullableVar v)                        = neg(is_null(v));
BoolExpr is_neither_blank_nor_null(<AnySignalVar, LocVar> v)  = neg(or(is_null(v), is_blank(v)));

BoolExpr is_between(IntExpr e, IntExpr l, IntExpr u) = and(is_ge(e, l), is_le(e, u));

BoolExpr is_true(ObjExpr e)  = is_eq(e, obj_true);
BoolExpr is_false(ObjExpr e) = is_eq(e, obj_false);

BoolExpr is_bool(ObjExpr e)  = or(is_true(e), is_false(e));

BoolExpr is_even(IntExpr e) = is_eq(mod_op(e, 2), 0);
BoolExpr is_odd(IntExpr e)  = is_eq(mod_op(e, 2), 1);

SymbObj obj_true  = :object(true);
SymbObj obj_false = :object(false);

///////////////////////////// Derived instructions /////////////////////////////

Instr repeat_while(BoolExpr cond, Instr+ body) = repeat(nonempty((do_if_not(cond, break_loop)) & body));

Instr increment(IntVar v, IntExpr a)  = set_ivar(v, add(v, a));
Instr increment(IntVar v)             = increment(v, 1);
Instr decrement(IntVar v)             = increment(v, -1);

Instr increment(Int32Var v, Int32Expr e)  = set_ivar32(v, add32(v, e));
Instr increment(Int32Var v)               = increment(v, 1);

Instr do_if(BoolExpr cond, Instr* instrs)      = branch(cond, instrs, ());
Instr do_if_not(BoolExpr cond, Instr* instrs)  = branch(cond, (), instrs);

Instr do_if(BoolExpr cond, Instr instr)      = do_if(cond, (instr));
Instr do_if_not(BoolExpr cond, Instr instr)  = do_if_not(cond, (instr));

Instr* opt_do_if(BoolExpr cond, Instr* instrs) = if   instrs == ()  then ()
                                                 elif cond == true  then instrs
                                                 elif cond == false then ()
                                                                    else (do_if(cond, instrs));

Instr branch(BoolExpr c, Instr i1, Instr i2) = branch(c, (i1), (i2));

Instr branch(BoolExpr c1, Instr+ b1, BoolExpr c2, Instr+ b2, Instr+ e) = branch(c1, b1, (branch(c2, b2, e)));

Instr break_if(BoolExpr cond)     = do_if(cond, break_loop);
Instr break_if_not(BoolExpr cond) = do_if_not(cond, break_loop);

Instr exit_block_if(BoolExpr cond)     = do_if(cond, exit_block);
Instr exit_block_if_not(BoolExpr cond) = do_if_not(cond, exit_block);

Instr ret_true  = ret_val(true);
Instr ret_false = ret_val(false);

Instr ret_true_if(BoolExpr cond)  = do_if(cond, ret_true);
Instr ret_false_if(BoolExpr cond) = do_if(cond, ret_false);

Instr ret_true_if_not(BoolExpr cond)  = do_if_not(cond, ret_true);
Instr ret_false_if_not(BoolExpr cond) = do_if_not(cond, ret_false);

// Instr ret_false_if_not_in(AtomicExpr val, SymbObj+ values) = do_if_not_in(val, values, [ret_false]);

Instr check(BoolExpr e) = do_if_not(e, terminate);
// Instr check(BoolExpr e) = no_op;

Instr check_is_bool(ObjExpr e) = check(is_bool(e));

Instr get_curr_obj(WriteObjVar v, <SetItVar, SeqItVar> it) = set_var(v, get_curr_obj(it));
Instr get_curr_arg(WriteObjVar v, SetItVar     it, Nat a)  = set_var(v, if a == 0 then get_curr_obj(it) else undefined);
Instr get_curr_arg(WriteObjVar v, BinRelItVar  it, Nat a)  = set_var(v, get_curr_arg(it, if a :: <0..1> then a else undefined));
Instr get_curr_arg(WriteObjVar v, TernRelItVar it, Nat a)  = set_var(v, get_curr_arg(it, if a :: <0..2> then a else undefined));

Instr maybe_op(Instr instr, Bool cond) = if cond then instr else no_op;

Instr block_success_if(BoolExpr c, BoolVar res_var)     = do_if(c, (set_bvar(res_var, true), exit_block));
Instr block_failure_if(BoolExpr c, BoolVar res_var)     = do_if(c, (set_bvar(res_var, false), exit_block));
Instr block_failure_if_not(BoolExpr c, BoolVar res_var) = block_failure_if(neg(c), res_var);
