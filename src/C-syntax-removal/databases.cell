implicit syn_prg : SynPrg, artifact : SchemaDef {
  Database desugared_data_base {
    state_vars = [
      memb_var(v.name) -> (
        type:       desugar_plain_type(v.type),
        init_value: desugar_expr(v.init_value, [], impl_args=[])
      ) : v <- db_state_vars
    ];

    methods  = [desugar_db_method(m) : m <- lookup(methods_by_db, artifact.name, [])];
    updates  = [desugar_update(u)    : u <- lookup(updates_by_db, artifact.name, [])];
    handlers = [desugar_handler(h)   : h <- lookup(handlers_by_db, artifact.name, [])];

    rel_var_decls = [d : d <~ artifact.decls, relvars_decl() ?= d];
    attr_map = [rel_var(r.name), rel_var(a.name) : r <- rel_var_decls, a <~ r.attributes];

    db = data_base(
      name:         db_symbol(artifact.name),
      links:        (db_symbol(id) : id <- artifact.links),
      state_vars:   state_vars,
      rel_vars:     desugared_relvars,
      attr_map:     attr_map,
      foreign_keys: desugared_foreign_keys & desugared_implicit_foreign_keys,
      nested_dbs:   db_vars_types,
      methods:      methods,
      updates:      updates,
      handlers:     handlers
    );

    return transfer(db, artifact);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [ForeignKey] desugared_implicit_foreign_keys {
    relvar_decls_by_name = group_by(db_rel_vars, $.name);
    return union([desugared_keys(ds) : unused_var, ds <- relvar_decls_by_name]);


    [ForeignKey] desugared_keys([+RelVarsDecl] decls) {
      if |decls| == 1:
        // Monomorphic relation
        return desugared_keys(only(decls));
      ;
      if only([|d.col_types| : d <- decls]) != 1:
        // Multiple polymorphic relations with arity two or greater. Signatures must be disjoint
        return union([desugared_keys(d) : d <- decls]);
      ;
      // Multiple polymorphic unary relations. Signatures can overlap
      decls_by_root_type = [desugar_plain_type(only_unsafe(d.col_types)) -> d : d <- decls];
      tree = type_tree(keys(decls_by_root_type), typedefs = typedefs);
      return desugared_keys(tree, decls_by_root_type, []);
    }


    [ForeignKey] desugared_keys(TypeTree tree, [NeType -> RelVarsDecl] decls_by_root_type, [AttrRelVar] inherited_attributes) =
      union([{
        decl = decls_by_root_type(root_type);
        rem_type = neat_difference(root_type, keys(subtrees), typedefs = typedefs);
        attrs = inherited_attributes & set(decl.attributes);
        decl_keys = if rem_type != empty_type
          then desugared_keys(decl.name, (rem_type), attrs)
          else [];
        subdecls_keys = desugared_keys(subtrees, decls_by_root_type, attrs);
        return decl_keys & subdecls_keys;
      } : root_type, subtrees <- tree]);


    [ForeignKey] desugared_keys(RelVarsDecl decl) =
      desugared_keys(decl.name, (desugar_plain_type(t) : t <- decl.col_types), set(decl.attributes));


    [ForeignKey] desugared_keys(Symbol name, NeType+ col_types, [AttrRelVar] attributes) {
      // If we don't take care to handle the no-attributes case here
      // the code that follows would crash for ternary relations
      return [] if attributes == [];
      base_relvar = rel_var(name);
      args_names = (:a, :b);
      base_args = (just(args_names(i)) : t @ i <- col_types);
      base_types = (just(t) : t @ i <- col_types);
      attr_args = (base_args | nothing);
      attr_types = (base_types | nothing);
      return union([
        [ foreign_key(base_relvar, base_args, base_types, attr_relvar, attr_args),
          foreign_key(attr_relvar, attr_args, attr_types, base_relvar, base_args)
        ] : a <- attributes, attr_relvar = rel_var(a.name)
      ]);
    }
  }


  [ForeignKey] desugared_foreign_keys = [{
    used_args = [value(a) : a <~ as, a != nothing];
    src_args = (if a != nothing and not used_args(value(a)) then nothing else a : a, t <- k.src_args);
    src_types = (apply(t, desugar_plain_type) : a, t <- k.src_args);
    return foreign_key(rel_var(k.src_rel), src_args, src_types, rel_var(r), as);
  } : k <- db_foreign_keys, tgt <~ k.targets, (r?, as?) ?= tgt];


  [RelVar -> (signatures: [+NeType+], keys: [[+Nat]], symmetric: Bool)] desugared_relvars {
    relvar_decls_by_name : [Symbol -> [+RelVarsDecl]];
    relvars_sgns : [RelVar -> [+NeType+]];

    relvar_decls_by_name = group_by(db_rel_vars, $.name);
    relvars_sgns = group_by_left_arg(
      merge_rels([desugared_signatures(ds) : unused_var, ds <- relvar_decls_by_name])
    );

    root_relvars_keys = [[rel_var(v.name) -> [set(k) : k <~ v.keys] : v <- db_rel_vars]];

    attr_relvars_keys = [
      [ rel_var(arv.name) -> [
        [i : _ @ i <~ rv.col_types] if not arv.cardinality.multiple,
        [|rv.col_types|] if arv.unique
      ]]
      : rv <- db_rel_vars, arv <~ rv.attributes
    ];

    relvars_keys = merge(root_relvars_keys & attr_relvars_keys);
    assert keys(relvars_sgns) == keys(relvars_keys);

    symm_relvars = [rel_var(v.name) : v <- db_rel_vars, v.symmetric] &
                   [rel_var(arv.name) : rv <- db_rel_vars, rv.symmetric, arv <~ rv.attributes];

    return [v -> (signatures: ss, keys: relvars_keys(v), symmetric: symm_relvars(v)) : v, ss <- relvars_sgns];


    [+RelVar, NeType+] desugared_signatures([+RelVarsDecl] decls) {
      if |decls| == 1:
        // Monomorphic relation
        return desugared_signatures(only(decls));
      ;
      if only([|d.col_types| : d <- decls]) != 1:
        // Multiple polymorphic relations with arity two or greater. Signatures must be disjoint
        return nonempty_rel(merge_rels([desugared_signatures(d) : d <- decls]));
      ;
      // Multiple polymorphic unary relations. Signatures can overlap
      decls_by_root_type = [desugar_plain_type(only_unsafe(d.col_types)) -> d : d <- decls];
      tree = type_tree(keys(decls_by_root_type), typedefs = typedefs);
      return nonempty_rel(desugared_signatures(tree, decls_by_root_type, []));
    }


    [+RelVar, NeType+] desugared_signatures(RelVarsDecl decl) {
      root_sgn = (desugar_plain_type(t) : t <- decl.col_types);
      return [rel_var(decl.name) -> root_sgn] &
             [rel_var(a.name) -> (root_sgn | desugar_plain_type(a.type)) : a <~ decl.attributes];
    }


    [RelVar, NeType+] desugared_signatures(TypeTree tree, [NeType -> RelVarsDecl] decls_by_root_type, [AttrRelVar] inherited_attributes) =
      merge_rels([{
        decl = decls_by_root_type(root_type);
        rem_type = neat_difference(root_type, keys(subtrees), typedefs = typedefs);
        attrs = inherited_attributes & set(decl.attributes);
        decl_sgns = if rem_type != empty_type
          then [rel_var(decl.name) -> (rem_type)] &
               [rel_var(a.name) -> (rem_type, desugar_plain_type(a.type)) : a <- attrs]
          else [];
        subsgns = desugared_signatures(subtrees, decls_by_root_type, attrs);
        return merge_rels([decl_sgns, subsgns]);
      } : root_type, subtrees <- tree]);
  }


  Method desugar_db_method(DBMethodDef method_def) {
    args = ((desugar_plain_type(t), just(var(n))) : t, n <- method_def.args);
    ret_type = desugar_plain_type(method_def.ret_type);
    arg_vars = [var(n) : _, n <~ method_def.args];
    method_artifact = using_block_method_def(artifact.name, method_def);
    expr = desugar_expr(method_def.expr, arg_vars, artifact = method_artifact, impl_args = []);
    method = method(method_symbol(method_def.name), args, ret_type, expr);
    return transfer(method, method_def);
  }


  Update desugar_update(UpdateDef update_def) {
    args = ((desugar_plain_type(t), v) : t, v <- update_def.args);
    arg_vars = [v : _, v <~ update_def.args];
    update_artifact = using_block_update_def(artifact.name, update_def);
    body = desugar_stmts(update_def.body, arg_vars, artifact = update_artifact, impl_args = []);
    update = update(update_symbol(update_def.name), args, body);
    return transfer(update, update_def);
  }


  Handler desugar_handler(HandlerDef handler_def) {
    type = desugar_plain_type(handler_def.type);
    body = desugar_stmts(handler_def.body, [var(:this)], artifact = handler_def, impl_args = []);
    handler = handler(type, body);
    return transfer(handler, handler_def);
  }
}
