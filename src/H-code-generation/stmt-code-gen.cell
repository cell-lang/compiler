implicit program           : Program,
         options           : CompOptions,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         surrogates        : [SurrExpr -> ObjExpr]
{
  (Instr*, ObjExpr, VarGen) do_expr_opt_eval_code(DoExpr expr, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    type = expr_type(expr, init_env, typed_vars = []); ## NOT SURE ABOUT typed_vars HERE
    repr = if type != empty_type then opt_repr(type) else :object;
    return do_expr_opt_eval_code(expr, repr, init_env, init_var_gen);
  }


  (Instr*, ObjExpr, VarGen) do_expr_opt_eval_code(DoExpr expr, AnyLowLevelRepr repr, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    var, ret_var_gen = next_var(repr, init_var_gen);
    let typed_vars = expr.typed_vars, exp_break_surrs = nothing, result_var = var
      code, _, _, _ = stmts_opt_code(expr.body, init_env, ret_var_gen);
    return ((execute_block(code) if code != ()), obj_expr(var), ret_var_gen);
  }
}


type StmtCompInfo = (Instr*, Maybe[[SurrExpr -> ObjExpr]], [[SurrExpr -> ObjExpr]], VarGen);


implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         options           : CompOptions,
         context           : Context,
         typed_vars        : [StdVar -> NeType],
         surrogates        : [SurrExpr -> ObjExpr],
         exp_break_surrs   : Maybe[[SurrExpr -> ObjExpr]],
         result_var        : AnyLocVar
{
  StmtCompInfo stmts_opt_code(Statement* stmts, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    return ((), just(surrogates), [], init_var_gen) if stmts == ();

    var_gen = init_var_gen;
    code = ();
    env = init_env;
    surrs = just(surrogates);
    break_surrs = [];
    for s <- stmts {
      fail if surrs == nothing;
      stmt_code, surrs, stmt_break_surrs, var_gen = stmt_opt_code(s, env, var_gen, surrogates = value(surrs));
      code = code & stmt_code;
      break_surrs = break_surrs & stmt_break_surrs;
      env = update_env(s, env);
    }
    return (code, surrs, break_surrs, var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo stmt_opt_code(Statement stmt, [EnvVar -> Type] env, VarGen var_gen) =
    break_stmt            = break_stmt_opt_code(env, var_gen),
    fail_stmt()           = fail_stmt_opt_code(stmt, env, var_gen),
    loop_stmt(ss?)        = loop_stmt_opt_code(ss, env, var_gen),
    print_stmt(e?)        = print_stmt_opt_code(e, env, var_gen),
    return_stmt(e?)       = return_stmt_opt_code(e, env, var_gen),
    assert_stmt()         = assert_stmt_opt_code(stmt, env, var_gen),
    let_stmt()            = let_stmt_opt_code(stmt.asgnms, stmt.body, env, var_gen),
    assignment_stmt()     = assignment_stmt_opt_code(stmt.vars, stmt.value, env, var_gen),
    seq_update_stmt()     = seq_update_stmt_opt_code(stmt, env, var_gen),
    if_stmt()             = if_stmt_opt_code(stmt, env, var_gen),
    for_stmt()            = for_stmt_opt_code(stmt, env, var_gen),
    foreach_stmt()        = foreach_stmt_opt_code(stmt, env, var_gen),
    return_stmt           = ((exit_block), just(surrogates), [], var_gen),
    proc_call_stmt()      = proc_call_stmt_opt_code(stmt, env, var_gen),

    send_msg_stmt()       = send_msg_stmt_opt_code(stmt.msg, env, var_gen),
    try_update_stmt()     = try_update_stmt_opt_code(stmt.name, stmt.args, env, var_gen),
    set_memb_var_stmt()   = set_memb_var_stmt_opt_code(stmt.var, stmt.value, env, var_gen),
    delete_stmt()         = delete_stmt_opt_code(stmt.var, stmt.args, env, var_gen),
    insert_stmt()         = if is_columnar_relvar(stmt.var) then
                              columnar_relvar_insert_stmt_opt_code(stmt.var, stmt.args, false, env, var_gen)
                            else if is_ternary_slave_column(stmt.var) then
                              ternary_slave_column_insert_stmt_opt_code(stmt.var, stmt.args, false, env, var_gen)
                            else
                              insert_stmt_opt_code(stmt.var, stmt.args, env, var_gen),
    update_stmt()         = if is_columnar_relvar(stmt.var) then
                              columnar_relvar_insert_stmt_opt_code(stmt.var, stmt.args, true, env, var_gen)
                            else if is_ternary_slave_column(stmt.var) then
                              ternary_slave_column_insert_stmt_opt_code(stmt.var, stmt.args, true, env, var_gen)
                            else
                              update_stmt_opt_code(stmt.var, stmt.args, env, var_gen),

    set_input_ctrl_stmt()         = set_input_ctrl_stmt_opt_code(stmt.var, stmt.input, stmt.value, env, var_gen),
    clear_input_ctrl_stmt()       = clear_input_ctrl_stmt_opt_code(stmt.var, stmt.input, env, var_gen),
    set_elapsed_time_ctrl_stmt()  = set_elapsed_time_ctrl_stmt_opt_code(stmt.var, stmt.time, env, var_gen),
    apply_ctrl_stmt()             = apply_ctrl_stmt_opt_code(stmt.auto_var, stmt.res_var, env, var_gen),
    send_msg_ctrl_stmt()          = send_msg_ctrl_stmt_opt_code(stmt.res_var, stmt.db_var, stmt.msg, env, var_gen),
    read_state_ctrl_stmt()        = read_state_ctrl_stmt_opt_code(stmt.res_var, stmt.auto_var, env, var_gen),
    restore_state_ctrl_stmt()     = restore_state_ctrl_stmt_opt_code(stmt.res_var, stmt.auto_var, stmt.state, fetch(stmt), env, var_gen);


  StmtCompInfo send_msg_stmt_opt_code(Expr msg, [EnvVar -> Type] env, VarGen init_var_gen) {
    rel_auto_type = rel_auto_by_id(this_db_symbol);
    msg_type = expr_type(msg, env);
    target_idx = only([i : dependee @ i <- rel_auto_type.links, is_subset(msg_type, db_msg_type(dependee))]);
    target = linked_db_var(target_idx);
    code, surr, _ = opt_eval_code(msg, env, init_var_gen);
    code = (code | send_msg(target, var_type(target), surr, false));
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo try_update_stmt_opt_code(UpdateSymbol name, Expr* args, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surrs, _ = opt_eval_code(args, env, init_var_gen);
    code = (code | try_update(this_db_symbol, update_id(name, |args|), surrs));
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo set_memb_var_stmt_opt_code(MembVar var, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, _ = opt_eval_code(value, env, init_var_gen);
    pvar = pending_state_var(bare_id(var));
    code = (code | do_if_not(is_blank(pvar), terminate), set_var(pvar, surr));
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo delete_stmt_opt_code(RelVar rel_var, Maybe[Expr]+ args, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_surrs : Maybe[Int32Var]*;

    args_types = (apply(a, expr_type($, env)) : a <- args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: Maybe[NeType]+;

    symmetric = symmetric(rel_var);

    code, args_aliases, var_gen = sparse_opt_eval_code(args, env, init_var_gen);

    args_surrs = ();
    for a <- args_aliases {
      if a != nothing {
        surr, var_gen = next_int32_var(var_gen);
        args_surrs = (args_surrs | just(surr));
      }
      else {
        args_surrs = (args_surrs | nothing);
      }
    }

    assoc_surr_var, var_gen = next_int32_var(var_gen);

    fail if args_aliases == () or args_surrs == ();

    phys_rel_vars = overlapping_phys_rel_vars(rel_var, args_types);
    rel_auto = cast_database(context);
    for v <- isort(phys_rel_vars) {
      table_code = delete_code(table_var(v), args_aliases, args_surrs, args_types, assoc_surr_var, symmetric);
      attrs = [a : a <- rel_auto.attr_map(v, ?)];
      attr_args_aliases = (args_aliases | nothing);
      attr_args_surrs = (args_surrs | nothing);
      attr_args_types = (args_types | nothing);
      for a <- isort(attrs) {
        assert arity(a) == arity(rel_var) + 1;
        table_code = table_code & delete_code(table_var(a), attr_args_aliases, attr_args_surrs, attr_args_types, assoc_surr_var, symmetric);
      }
      code = code & table_code;
    }

    return (code, just(surrogates), [], init_var_gen);


    Instr* delete_code(TableVar table_var, Maybe[ObjExpr]+ args_aliases, Maybe[Int32Var]+ args_surrs, Maybe[Type]+ args_types, Int32Var assoc_surr_var, Bool symmetric) {
      if is_columnar_relvar(logical_rel_var(original_rel_var(table_var))) {
        assert not symmetric;
        fail if |args_aliases| != 2;
        arg0, arg1 = args_aliases;
        if arg0 != nothing and arg1 != nothing {
          key_store_id = table_col_store_id(table_var, 0);
          key_store_type = value_store_type(this_db_symbol, key_store_id);

          key_arg_alias = value(arg0);
          key_arg_surr = value_unsafe(args_surrs(0));
          key_arg_type = value_unsafe(args_types(0));

          has_key_check_expr = table_contains(table_var, table_info(table_var), (just(key_arg_surr), nothing), false);
          lookup_expr = column_lookup(table_var, key_arg_surr, column_repr(table_var));
          contains_tuple_check_expr = and_then((
            neg(is_eq(key_arg_surr, -1)),
            has_key_check_expr,
            are_eq(value(arg1), lookup_expr)
          ));

          code = opt_do_if(
            value_store_guard(key_store_type, key_arg_alias, key_arg_type),
            ( set_ivar32(key_arg_surr, value_to_surr(key_store_id, value_store_encoded_expr(key_store_type, key_arg_alias))),
              do_if(
                contains_tuple_check_expr,
                queue_deletes(table_var, table_info(table_var), (args_surrs(0), nothing), symmetric)
              )
            )
          );

          return code;
        }
      }

      if is_ternary_slave_column(logical_rel_var(original_rel_var(table_var))) {
        assert not symmetric;
        fail if |args_aliases| != 3;
        arg0, arg1, arg2 = args_aliases;
        if arg0 != nothing and arg1 != nothing and arg2 != nothing {
          arg0 = value(arg0);
          arg1 = value(arg1);
          arg2 = value(arg2);

          arg_0_surr = value_unsafe(args_surrs(0));
          arg_1_surr = value_unsafe(args_surrs(1));

          master_table = master_table(table_var);

          store_ids = (table_col_store_id(table_var, i) : i <= 1);
          stores_types = (value_store_type(this_db_symbol, id) : id <- store_ids);

          code = opt_do_if(
            and((value_store_guard(stores_types(i), value_unsafe(args_aliases(i)), value_unsafe(args_types(i))) : i <= 1)),
            ( set_ivar32(arg_0_surr, value_to_surr(store_ids(0), value_store_encoded_expr(stores_types(0), arg0))),
              do_if_not(
                is_eq(arg_0_surr, -1),
                ( set_ivar32(arg_1_surr, value_to_surr(store_ids(1), value_store_encoded_expr(stores_types(1), arg1))),
                  do_if_not(
                    is_eq(arg_1_surr, -1),
                    ( set_ivar32(assoc_surr_var, get_assoc_surr(master_table, (arg_0_surr, arg_1_surr))),
                      do_if(
                        and_then((
                          neg(is_eq(assoc_surr_var, -1)),
                          table_contains(table_var, table_info(table_var), (just(assoc_surr_var), nothing), false),
                          is_eq(arg2, column_lookup(table_var, assoc_surr_var, column_repr(table_var)))
                        )),
                        queue_deletes(table_var, table_info(table_var), (args_surrs(0), args_surrs(1), nothing), symmetric)
                      )
                    )
                  )
                )
              )
            )
          );

          return code;
        }
      }

      code = (queue_deletes(table_var, table_info(table_var), nonempty(args_surrs), symmetric));
      for a @ ri <- reverse(args_aliases) {
        if a != nothing {
          i = nat(|args_aliases| - ri - 1);
          arg_alias = value(a);
          arg_type = value_unsafe(args_types(i));
          store_id = table_col_store_id(table_var, i);
          store_type = value_store_type(this_db_symbol, store_id);
          arg_surr = value_unsafe(args_surrs(i));
          code = opt_do_if(
            value_store_guard(store_type, arg_alias, arg_type),
            ( set_ivar32(arg_surr, value_to_surr(store_id, value_store_encoded_expr(store_type, arg_alias))),
              do_if_not(is_eq(arg_surr, -1), code)
            )
          );
        }
      }
      return code;
    }
  }


  ## BAD BAD BAD: ALMOST IDENTICAL TO update_stmt_opt_code()
  ## WHEN CHANGING ONE, ALWAYS REMEMBER TO CHANGE THE OTHER AS WELL
  StmtCompInfo insert_stmt_opt_code(RelVar rel_var, Expr+ args, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_types = (expr_type(a, env) : a <- args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: NeType+;

    args_eval_code, args_aliases, var_gen = opt_eval_code(args, env, init_var_gen);
    fail if args_aliases == ();

    arity = |args_aliases|;
    surr_vars, var_gen = next_int32_vars(var_gen, arity);
    fail if surr_vars == ();
    is_new_val_vars, var_gen = next_bool_vars(var_gen, arity);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = nonempty(overlapping_tables(rel_var, (just(t) : t <- args_types)));

    if |candidate_tables| == 1 {
      // Easy case: there's only one table
      table_var = only(candidate_tables);

      pre_insert_code = ({
        store_id = table_col_store_id(table_var, i);
        store_type = value_store_type(this_db_symbol, store_id);
        surr_var = surr_vars(i);
        return lookup_or_queue_insert_value(surr_var, store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);

      insertion_code = (queue_insert_tuple(table_var, table_info(table_var), surr_vars));
      code = args_eval_code & pre_insert_code & insertion_code;

      return (code, just(surrogates), [], init_var_gen);
    }

    // Choosing the dispatch arguments
    signatures = [table_signature(tv) : tv <- candidate_tables];
    disp_args = optimal_dispatch_args(signatures, typedefs);

    cases = [{
      types = table_signature(tv);
      code = ({
        store_id = table_col_store_id(tv, i);
        store_type = value_store_type(this_db_symbol, store_id);
        return lookup_or_queue_insert_value(surr_vars(i), store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);
      code = (code | queue_insert_tuple(tv, table_info(tv), surr_vars), exit_block);
      return (types, code);
    } : tv <- candidate_tables];

    code = (args_eval_code | execute_block(dynamic_dispatch_code(args_aliases, cases)));

    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo columnar_relvar_insert_stmt_opt_code(RelVar rel_var, Expr+ args, Bool forced, [EnvVar -> Type] env, VarGen init_var_gen) {
    fail if |args| != 2;
    arg_0, arg_1 = args;

    arg_0_type = expr_type(arg_0, env);
    arg_1_type = expr_type(arg_1, env);

    if arg_0_type == empty_type or arg_1_type == empty_type
      return ((terminate(true)), just(surrogates), [], init_var_gen);

    args_eval_code, args_aliases, var_gen = opt_eval_code(args, env, init_var_gen);
    fail if |args_aliases| != 2;
    arg_0_alias, arg_1_alias = args_aliases;

    surr_var_0, var_gen = next_int32_var(var_gen);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = nonempty(overlapping_tables(rel_var, (just(arg_0_type), just(arg_1_type))));

    assert relvar_keys(rel_var) == [[0]];

    if |candidate_tables| == 1 {
      // Easy case: there's only one table
      table_var = only(candidate_tables);

      store_id = table_col_store_id(table_var, 0);
      store_type = value_store_type(this_db_symbol, store_id);

      enc_expr = value_store_encoded_expr(store_type, arg_0_alias);

      col_repr = column_repr(table_signature(table_var)(1));

      update_code = (
        lookup_or_queue_insert_value(surr_var_0, store_id, enc_expr),
        column_insert_deferred(table_var, surr_var_0, low_level_expr(col_repr, arg_1_alias), forced)
      );

      return (args_eval_code & update_code, just(surrogates), [], init_var_gen);
    }
    else {
      // Choosing the dispatch arguments
      signatures = [table_signature(tv) : tv <- candidate_tables];
      disp_args = optimal_dispatch_args(signatures, typedefs);

      cases = [{
        store_id = table_col_store_id(tv, 0);
        store_type = value_store_type(this_db_symbol, store_id);
        enc_expr = value_store_encoded_expr(store_type, arg_0_alias);

        col_repr = column_repr(table_signature(tv)(1));

        code = (
          lookup_or_queue_insert_value(surr_var_0, store_id, enc_expr),
          column_insert_deferred(tv, surr_var_0, low_level_expr(col_repr, arg_1_alias), forced),
          exit_block
        );
        return (table_signature(tv), code);
      } : tv <- candidate_tables];

      code = (args_eval_code | execute_block(dynamic_dispatch_code(args_aliases, cases)));

      return (code, just(surrogates), [], init_var_gen);
    }
  }


  StmtCompInfo ternary_slave_column_insert_stmt_opt_code(RelVar rel_var, Expr+ args, Bool forced, [EnvVar -> Type] env, VarGen init_var_gen) {
    fail if |args| != 3;
    arg_0, arg_1, arg_2 = args;

    arg_0_type = expr_type(arg_0, env);
    arg_1_type = expr_type(arg_1, env);
    arg_2_type = expr_type(arg_2, env);

    if arg_0_type == empty_type or arg_1_type == empty_type or arg_2_type == empty_type
      return ((terminate(true)), just(surrogates), [], init_var_gen);

    args_eval_code, args_aliases, var_gen = opt_eval_code(args, env, init_var_gen);
    fail if |args_aliases| != 3;
    arg_0_alias, arg_1_alias, arg_2_alias = args_aliases;

    surr_var_0, var_gen = next_int32_var(var_gen);
    surr_var_1, var_gen = next_int32_var(var_gen);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = nonempty(overlapping_tables(rel_var, (just(arg_0_type), just(arg_1_type), just(arg_2_type))));

    assert relvar_keys(rel_var) == [[0, 1]];

    if |candidate_tables| == 1 {
      // Easy case: there's only one table
      table_var = only(candidate_tables);

      store_id_0 = table_col_store_id(table_var, 0);
      store_id_1 = table_col_store_id(table_var, 1);
      store_type_0 = value_store_type(this_db_symbol, store_id_0);
      store_type_1 = value_store_type(this_db_symbol, store_id_1);

      enc_expr_0 = value_store_encoded_expr(store_type_0, arg_0_alias);
      enc_expr_1 = value_store_encoded_expr(store_type_1, arg_1_alias);

      col_repr = column_repr(table_signature(table_var)(2));

      update_code = (
        lookup_or_queue_insert_value(surr_var_0, store_id_0, enc_expr_0),
        lookup_or_queue_insert_value(surr_var_1, store_id_1, enc_expr_1),
        ternary_slave_column_insert_deferred(table_var, (surr_var_0, surr_var_1), low_level_expr(col_repr, arg_2_alias), forced)
      );

      return (args_eval_code & update_code, just(surrogates), [], init_var_gen);
    }
    else {
      // Choosing the dispatch arguments
      signatures = [table_signature(tv) : tv <- candidate_tables];
      disp_args = optimal_dispatch_args(signatures, typedefs);

      cases = [{
        store_id_0 = table_col_store_id(tv, 0);
        store_id_1 = table_col_store_id(tv, 1);
        store_type_0 = value_store_type(this_db_symbol, store_id_0);
        store_type_1 = value_store_type(this_db_symbol, store_id_1);
        enc_expr_0 = value_store_encoded_expr(store_type_0, arg_0_alias);
        enc_expr_1 = value_store_encoded_expr(store_type_1, arg_1_alias);

        col_repr = column_repr(table_signature(tv)(2));

        code = (
          lookup_or_queue_insert_value(surr_var_0, store_id_0, enc_expr_0),
          lookup_or_queue_insert_value(surr_var_1, store_id_1, enc_expr_1),
          ternary_slave_column_insert_deferred(tv, (surr_var_0, surr_var_1), low_level_expr(col_repr, arg_2_alias), forced),
          exit_block
        );
        return (table_signature(tv), code);
      } : tv <- candidate_tables];

      code = (args_eval_code | execute_block(dynamic_dispatch_code(args_aliases, cases)));

      return (code, just(surrogates), [], init_var_gen);
    }
  }


  ## BAD BAD BAD: ALMOST IDENTICAL TO insert_stmt_opt_code()
  ## WHEN CHANGING ONE, ALWAYS REMEMBER TO CHANGE THE OTHER AS WELL
  StmtCompInfo update_stmt_opt_code(RelVar rel_var, Expr+ args, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_types = (expr_type(a, env) : a <- args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: NeType+;

    args_eval_code, args_aliases, var_gen = opt_eval_code(args, env, init_var_gen);
    fail if args_aliases == ();

    arity = |args_aliases|;
    surr_vars, var_gen = next_int32_vars(var_gen, arity);
    fail if surr_vars == ();
    is_new_val_vars, var_gen = next_bool_vars(var_gen, arity);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = nonempty(overlapping_tables(rel_var, (just(t) : t <- args_types)));

    symmetric = symmetric(rel_var);
    keys = isort(relvar_keys(rel_var));
    deletes_args = ((maybe(v, k(i)) : v @ i <- surr_vars) : k <- keys);

    if |candidate_tables| == 1 {
      // Easy case: there's only one table
      table_var = only(candidate_tables);

      pre_insert_code = ({
        store_id = table_col_store_id(table_var, i);
        store_type = value_store_type(this_db_symbol, store_id);
        surr_var = surr_vars(i);
        return lookup_or_queue_insert_value(surr_var, store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);

      insertion_code = (
        (queue_deletes(table_var, table_info(table_var), as, symmetric) : as <- deletes_args) |
        queue_insert_tuple(table_var, table_info(table_var), surr_vars)
      );
      code = args_eval_code & pre_insert_code & insertion_code;

      return (code, just(surrogates), [], init_var_gen);
    }

    // Choosing the dispatch arguments
    signatures = [table_signature(tv) : tv <- candidate_tables];
    disp_args = optimal_dispatch_args(signatures, typedefs);

    cases = [{
      types = table_signature(tv);
      code = ({
        store_id = table_col_store_id(tv, i);
        store_type = value_store_type(this_db_symbol, store_id);
        return lookup_or_queue_insert_value(surr_vars(i), store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);
      code = code & (queue_deletes(tv, table_info(tv), as, symmetric) : as <- deletes_args);
      code = (code | queue_insert_tuple(tv, table_info(tv), surr_vars), exit_block);
      return (types, code);
    } : tv <- candidate_tables];

    code = (args_eval_code | execute_block(dynamic_dispatch_code(args_aliases, cases)));

    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo send_msg_ctrl_stmt_opt_code(StdVar res_var, LocDBVar db_var, Expr msg, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, _ = opt_eval_code(msg, env, init_var_gen);
    db_type = var_type(db_var);
    res_bvar = low_level_bvar(res_var);
    code = (code | send_msg(db_var, db_type, surr, true, res_bvar));
    surrs = update(surrogates, res_var, bool_obj(res_bvar));
    return (code, just(surrs), [], init_var_gen);
  }


  StmtCompInfo read_state_ctrl_stmt_opt_code(StdVar res_var, LocDBVar db_var, [EnvVar -> Type] env, VarGen var_gen) {
    code = (copy_state(res_var, db_var, var_type(db_var)));
    ## BUG BUG BUG: res_var HAS TO BE REMOVED FROM surrogates
    ## THIS BUG IS PROBABLY REPEATED ELSEWHERE
    return (code, just(surrogates), [], var_gen);
  }


  StmtCompInfo restore_state_ctrl_stmt_opt_code(StdVar res_var, LocDBVar db_var, Expr state, Maybe[Any] stmt_loc, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, _ = opt_eval_code(state, env, init_var_gen);
    res_bvar = low_level_bvar(res_var);
    code = (code | set_state(res_bvar, db_var, surr, var_type(db_var)));
    surrs = update(surrogates, res_var, bool_obj(res_bvar));
    return (code, just(surrs), [], init_var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo read_state_ctrl_stmt_opt_code(StdVar res_var, LocAutoVar auto_var, [EnvVar -> Type] env, VarGen init_var_gen) {
    tmp_var, _ = next_obj_var(init_var_gen);
    code = (
      branch(
        state_is_def(auto_var, var_type(auto_var)),
        ( copy_persistent_state(tmp_var, auto_var, var_type(auto_var)),
          mk_tagged_obj(res_var, object(:maybe), tmp_var)
        ),
        (set_var(res_var, object(:nothing)))
      )
    );
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo restore_state_ctrl_stmt_opt_code(StdVar res_var, LocAutoVar auto_var, Expr state, Maybe[Any] stmt_loc, [EnvVar -> Type] env, VarGen init_var_gen) {
    eval_code, surr, var_gen = opt_eval_code(state, env, init_var_gen);

    if options.debug_mode {
      file, line = file_and_line(fetch(context), stmt_loc);
      msg = "Cannot set the state of a reactive automaton that has already been initialized: " & user_repr(auto_var);
      log_instr = log_runtime_failure(true, file, line, just(msg), ());
      err_code = (log_instr);
    }
    else {
      err_code = ();
    }

    check_instr = do_if_not(qual_bool_var(auto_var, is_new), (err_code | terminate(true)));
    set_state_instr = set_persistent_state(auto_var, surr, var_type(auto_var));
    code = (check_instr) & eval_code & (set_state_instr);
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo set_input_ctrl_stmt_opt_code(LocAutoVar var, Symbol input, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);
    auto_type = var_type(var);
    code = (code | set_input(var, auto_type, input, surr));
    return (code, just(surrogates), [], var_gen);
  }


  StmtCompInfo clear_input_ctrl_stmt_opt_code(LocAutoVar var, Symbol input, [EnvVar -> Type] env, VarGen init_var_gen) {
    auto_type = var_type(var);
    return ((clear_input(var, auto_type, input)), just(surrogates), [], init_var_gen);
  }


  StmtCompInfo set_elapsed_time_ctrl_stmt_opt_code(LocAutoVar var, Expr time, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(time, env, init_var_gen);
    code = (code | set_ivar(elapsed_time(var), get_int_val(surr)));
    return (code, just(surrogates), [], var_gen);
  }


  StmtCompInfo apply_ctrl_stmt_opt_code(LocAutoVar auto_var, StdVar res_var, [EnvVar -> Type] env, VarGen init_var_gen) {
    auto_type = var_type(auto_var);
    bvar = low_level_bvar(res_var);
    res_value = if is_time_sensitive(auto_type) then are_eq(int_obj(elapsed_time(auto_var)), int_obj(0)) else true;
    code = (auto_apply(auto_var, auto_type), set_bvar(bvar, res_value));
    surrs = update(surrogates, res_var, bool_obj(bvar));
    return (code, just(surrs), [], init_var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo seq_update_stmt_opt_code(SeqUpdateStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    idx_eval_code, idx_surr, var_gen = opt_eval_code(stmt.idx, env, init_var_gen);
    val_eval_code, val_surr, var_gen = opt_eval_code(stmt.value, env, var_gen);
    tmp_var, var_gen = next_obj_var(var_gen);
    update_code = (
      update_seq_at(tmp_var, stmt.seq_var, get_int_val(idx_surr), val_surr),
      set_var(stmt.seq_var, tmp_var)
    );
    code = idx_eval_code & val_eval_code & update_code;
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo fail_stmt_opt_code(FailStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    if options.debug_mode {
      vars = ((v, lookup(surrogates, v, v)) : v <- isort(stmt.env));
      code = (log_runtime_failure(false, stmt.file, stmt.line, nothing, vars));
    }
    else {
      code = ();
    }
    return ((code | terminate), nothing, [], var_gen);
  }


  StmtCompInfo assert_stmt_opt_code(AssertStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    return ((), just(surrogates), [], var_gen) if options.ignore_assertions;

    eval_code, surr, _ = opt_eval_code(stmt.cond, env, var_gen);
    expr_vars = extern_vars(stmt.cond);
    vars = isort([v : v <- stmt.env, expr_vars(v)]) & isort([v : v <- stmt.env, not expr_vars(v)]);
    vars = ((v, lookup(surrogates, v, v)) : v <- vars);
    log_instr = log_runtime_failure(true, stmt.file, stmt.line, stmt.text, vars);
    check_instr = do_if_not(bool_value(surr), (log_instr, terminate(true)));
    return ((eval_code | check_instr), just(surrogates), [], var_gen);
  }


  StmtCompInfo print_stmt_opt_code(Expr expr, [EnvVar -> Type] env, VarGen var_gen) {
    eval_code, surr, _ = opt_eval_code(expr, env, var_gen);
    return ((eval_code | print_obj(surr)), just(surrogates), [], var_gen);
  }


  StmtCompInfo let_stmt_opt_code([ImplArg -> Expr] asgnms, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    ## THIS SHOULD BE CHECKED IN THE PROPER PLACE, BOTH IN LAYER 1 AND 2
    ## IT'S A TEMPORARY LIMITATION THAT SHOULD BE REMOVED
    assert subset(outcomes(body), [:fails, :falls_through]);

    ## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
    ord_asgnms = isort(asgnms);
    backup_vars, var_gen = next_obj_vars(init_var_gen, |ord_asgnms|);

    set_up_code = join(({
        eval_code, surr, _ = opt_eval_code(e, env, var_gen);
        backup_var = backup_vars(i);
        return (eval_code | set_var(backup_var, v), set_var(v, surr));
      } : v, e @ i <- ord_asgnms
    ));

    tear_down_code = reverse((set_var(v, backup_vars(i)) : v, _ @ i <- ord_asgnms));

    env_delta = [a -> expr_type(e, env) : a e <- asgnms];
    body_env = update(env, env_delta);

    body_code, surrs, break_surrs, var_gen = stmts_opt_code(body, body_env, var_gen);
    assert break_surrs == []; ## SEE COMMENT AT THE BEGINNING OF THIS FUNCTION

    code = set_up_code & body_code & tear_down_code;
    return (code, surrs, break_surrs, var_gen);
  }


  // If a surrogates is defined here but not in the expected list,
  // we just remove it by physically storing its value.

  // If a surrogates is defined in the expected list but not here
  // there's nothing we can do here to fix that. We just return
  // the list of surrogates we end up with and we leave it to code
  // higher up in the call stack to fix that and retry

  // Finally, if a surrogate is defined in both lists, but the
  // definitions are different, we remove it here and we leave
  // to the calling code to fix the expected list and retry

  StmtCompInfo break_stmt_opt_code([EnvVar -> Type] env, VarGen var_gen) {
    exp_surrs = value_unsafe(exp_break_surrs);
    surrs_to_drop = [v : v e <- surrogates, not exp_surrs(v, _) or exp_surrs(v, !) != e];
    fail if not surrs_to_drop :: [StdVar];
    sync_code = (set_var(v, surrogates(v, !)) : v <- isort(surrs_to_drop));
    surrs = remove_keys(surrogates, surrs_to_drop);
    return ((sync_code | break_loop), nothing, [surrs], var_gen);
  }


  // proc_call_stmt(res_var: StdVar?, proc_name: ProcSymbol, args: Expr*, rel_auto_args: LocDBVar*, react_auto_args: LocAutoVar*);
  StmtCompInfo proc_call_stmt_opt_code(ProcCallStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, args_surrs, var_gen = opt_eval_code(stmt.args, env, init_var_gen);
    rel_auto_args = ((v, var_type(v)) : v <- stmt.rel_auto_args);
    call_instr = if stmt.res_var?
      then call_proc(stmt.res_var, stmt.proc_name, args_surrs, (), rel_auto_args, stmt.react_auto_args)
      else call_proc(stmt.proc_name, args_surrs, (), rel_auto_args, stmt.react_auto_args);
    surrs = if stmt.res_var? then drop(surrogates, stmt.res_var) else surrogates;
    return ((code | call_instr), just(surrs), [], var_gen);
  }


  StmtCompInfo assignment_stmt_opt_code(Maybe[StdVar]+ vars, Expr expr, [EnvVar -> Type] env, VarGen init_var_gen) {
    value_type = expr_type(expr, env);
    return ((terminate), just(surrogates), [], init_var_gen) if value_type == empty_type;

    rw_value = expr;
    if |vars| == 1 {
      maybe_var = only(vars);
      if maybe_var != nothing {
        var = value(maybe_var);
        if typed_vars(var, _) {
          var_type = typed_vars(var);
          if is_subset(var_type, type_seq) {
            decl_elt_type = seq_elem_supertype(var_type);
            if decl_elt_type != empty_type {
              if is_subset(decl_elt_type, integer) {
                rw_value = match (expr)
                  seq_comp()    |
                  range_comp()  = annotate(expr, decl_elt_type),
                  _             = expr;
              }
            }
          }
        }
      }
    }

    repr = opt_repr(value_type);
    code, surr, var_gen = opt_eval_code(rw_value, env, init_var_gen);

    if |vars| == 1 {
      maybe_var = only(vars);
      if maybe_var != nothing {
        var = value(maybe_var);
        ll_var = low_level_var(repr, var);
        code = store_result(code, surr, ll_var);
        surrs = if var != ll_var
          then update(surrogates, var, obj_expr(ll_var))
          else remove_key(surrogates, var);
      }
      else
        surrs = surrogates;
    }
    else {
      assert repr == :object;
      types = tuple_field_supertypes(value_type, |vars|);
      reprs = (opt_repr(t) : t <- types);
      phys_vars = (apply(v, low_level_var(reprs(i), $)) : v @ i <- vars);
      code = code & (set_any_var(value(v), at(surr, i)) : v @ i <- phys_vars, v != nothing);
      surrs = remove_keys(surrogates, set(values(vars)));
      new_surrs = [
        value(v) -> obj_expr(value_unsafe(pv))
        : v @ i <- vars, v != nothing, pv = phys_vars(i), v != pv
      ];
      surrs = surrs & new_surrs;
    }

    return (code, just(surrs), [], var_gen);


    SeqCompExpr annotate(SeqCompExpr expr, NeType decl_elt_type) =
      seq_comp(
        expr:           expr.expr,
        decl_elt_type:  decl_elt_type,
        vars:           expr.vars,
        idx_var:        expr.idx_var if expr.idx_var?,
        src_expr:       expr.src_expr,
        sel_expr:       expr.sel_expr if expr.sel_expr?
      );


    RangeCompExpr annotate(RangeCompExpr expr, NeType decl_elt_type) =
      range_comp(
        expr:           expr.expr,
        decl_elt_type:  decl_elt_type,
        var:            expr.var,
        bound_expr:     expr.bound_expr,
        inclusive:      expr.inclusive,
        sel_expr:       expr.sel_expr if expr.sel_expr?
      );
  }


  StmtCompInfo return_stmt_opt_code(Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);
    code = store_result(code, surr, result_var);
    return ((code | exit_block), nothing, [], init_var_gen);
  }


  StmtCompInfo if_stmt_opt_code(IfStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    ## BUG BUG BUG: THERE'S SOMETHING WRONG WITH THE RETURNED LIST OF SURROGATES. INVESTIGATE
    // cond_type = expr_type(stmt.cond, env);
    // if cond_type == empty_type {
    //   return ((terminate(true)), just(surrogates), [], init_var_gen);
    // }
    // else if is_subset(cond_type, type_true) {
    //   return stmts_opt_code(stmt.body, env, init_var_gen);
    // }
    // else if is_subset(cond_type, type_false) {
    //   return if stmt.else != ()
    //     then stmts_opt_code(stmt.else, env, init_var_gen)
    //     else ((), just(surrogates), [], init_var_gen);
    // }

    cond_code, cond_surr, _ = opt_eval_code(stmt.cond, env, init_var_gen);
    then_env, else_env = refine_env(stmt.cond, env);

    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_var_gen
    then_code, then_surrs, then_break_surrs, var_gen = stmts_opt_code(stmt.body, then_env, init_var_gen);

    // Here I could start again from init_var_gen, but then I
    // would have to reconcile the two resulting generators
    else_code, else_surrs, else_break_surrs, var_gen = stmts_opt_code(stmt.else, else_env, var_gen);

    if then_surrs != nothing and else_surrs != nothing {
      // If both branches can fall through, we need to syncronize their lists of surrogates
      surr_vars = [v : v <- keys(env) & new_vars(stmt), v :: SurrExpr];
      surrs, then_sync_code, else_sync_code = reconcile(surr_vars, value(then_surrs), value(else_surrs));
      surrs = just(surrs);
      then_code = then_code & then_sync_code;
      else_code = else_code & else_sync_code;
    }
    else if then_surrs != nothing {
      surrs = then_surrs;
    }
    else if else_surrs != nothing {
      surrs = else_surrs;
    }
    else {
      surrs = nothing;
    }

    code = (cond_code | branch(bool_value(cond_surr), then_code, else_code));
    return (code, surrs, then_break_surrs & else_break_surrs, var_gen);
  }


  StmtCompInfo loop_stmt_opt_code(Statement+ body, [EnvVar -> Type] env, VarGen var_gen) {
    body_env = loop_stmt_body_env(body, env);
    entry_code, body_code, surrs = loop_stable_code(body, [], body_env, var_gen);
    return ((entry_code | repeat(nonempty(body_code))), just(surrs), [], var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] loop_stmt_body_env(Statement+ stmts, [EnvVar -> Type] entry_env) {
      exit_env = update_env(stmts, entry_env);
      return merge_envs(entry_env, exit_env);
    }
  }


  StmtCompInfo for_stmt_opt_code(ForStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Generating the hidden loop variable
    idx_var, var_gen = next_int_var(init_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    start_val_code, start_val_surr, var_gen = opt_eval_code(stmt.start_val, env, var_gen);
    end_val_code, end_val_surr, var_gen = opt_eval_code(stmt.end_val, env, var_gen);
    entry_code = store_result(start_val_code, start_val_surr, idx_var) & end_val_code;

    // Environment the body runs in
    body_env = for_stmt_body_env(stmt, env);

    // Compiling loop body and adjusting entry code
    local_surrs = [stmt.var -> obj_expr(idx_var) if stmt.var?];
    entry_code_fixes, body_code, surrs = loop_stable_code(stmt.body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;

    // Packing loop code in a repeat instruction
    loop_over_expr = if stmt.end_val_incl
      then is_gt(idx_var, get_int_val(end_val_surr))
      else is_ge(idx_var, get_int_val(end_val_surr));
    loop_instr = repeat(nonempty((break_if(loop_over_expr)) & body_code & (increment(idx_var))));

    return ((entry_code | loop_instr), just(surrs), [], init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] for_stmt_body_env(ForStmt stmt, [EnvVar -> Type] env) {
      start_val_type = expr_type(stmt.start_val, env);
      end_val_type = expr_type(stmt.end_val, env);
      idx_var_type = loop_var_type(start_val_type, end_val_type, stmt.end_val_incl);

      loop_var_env = [stmt.var -> idx_var_type if stmt.var?];
      exit_env = update_env(stmt.body, env & loop_var_env);
      return merge_envs(env, exit_env) & loop_var_env;
    }
  }


  StmtCompInfo foreach_stmt_opt_code(ForeachStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    iter = stmt.iter;
    return match (iter)
      coll_value_iter() = opt_code(iter, stmt.body, env, var_gen),
      rel_subset_iter() = unord_coll_iter_opt_code(iter.vars, iter.src_expr, iter.args, stmt.body, env, var_gen),
      rel_var_iter()    = if is_columnar_relvar(iter.rel_var)
                            then columnar_rel_var_iter_opt_code(iter, stmt.body, env, var_gen)
                            else rel_var_iter_opt_code(iter, stmt.body, env, var_gen);

    // type CollValueIter  = coll_value_iter(vars: Maybe[StdVar]+, idx_var: StdVar?, src_expr: Expr);
    StmtCompInfo opt_code(CollValueIter iter, Statement+ body, [EnvVar -> Type] env, VarGen var_gen) {
      if iter.idx_var? or is_subset(expr_type(iter.src_expr, env), type_seq) {
        return seq_iter_opt_code(iter, body, env, var_gen);
      }
      else {
        args = (nothing : v <- iter.vars);
        return unord_coll_iter_opt_code(iter.vars, iter.src_expr, args, body, env, var_gen);
      }
    }
  }


  StmtCompInfo seq_iter_opt_code(CollValueIter iter, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Calculating input sequence type, and returning early if the type is trivial
    seq_type = expr_type(iter.src_expr, env);
    if seq_type == empty_type
      ## just(surrogates) OR nothing?
      return ((terminate), just(surrogates), [], init_var_gen);
    else if is_subset(seq_type, empty_seq_type)
      return ((), just(surrogates), [], init_var_gen);

    // Type and representation of the elements of the input sequence
    elt_type = seq_elem_supertype(seq_type);
    fail if elt_type == empty_type;
    elt_repr = opt_repr(elt_type);

    // Evaluation of input expression
    entry_code, seq_surr, var_gen = opt_eval_code(iter.src_expr, env, init_var_gen);
    if not seq_surr :: <LocVar, StdVar> {
      seq_var, var_gen = next_obj_var(var_gen);
      entry_code = (entry_code | set_var(seq_var, seq_surr));
      seq_surr = seq_var;
    }

    // Temporary buffer for source data
    src_array_var, var_gen = next_array_var(var_gen, elt_repr);

    vars = iter.vars;
    if |vars| == 1 {
      // Simple case, no destructuring of the elements of the source sequence
      var = only(vars);
      if var != nothing {
        var = value(var);
        it_var = low_level_var(elt_repr, var);
        local_surrs = [var -> obj_expr(it_var) if var != it_var];
      }
      else {
        it_var, var_gen = next_var(elt_repr, var_gen);
        local_surrs = [];
      }
      body_code_setup = ();
    }
    else {
      // Elements of source sequence need to be destructured
      assert elt_repr == :object;
      vars_types = tuple_field_supertypes(elt_type, |vars|);
      ## REMOVE WHEN DONE
      assert vars_types == (restricted_seq_elem_supertype(elt_type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- vars_types);
      vars = [i -> value(v) : v @ i <- vars, v != nothing];
      phys_vars = [i -> low_level_var(reprs(i), v) : i v <- vars];
      local_surrs = [v -> obj_expr(pv) : i v <- vars, pv = phys_vars(i), v != pv];
      it_var, var_gen = next_obj_var(var_gen);
      body_code_setup = (set_any_var(v, at(it_var, i)) : i, v <- sort_bin_rel_by_key(phys_vars, $a));
    }

    // Index variables
    count_var, var_gen = next_int32_var(var_gen);
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    local_surrs = local_surrs & [iter.idx_var -> int_obj(hidden_idx_var)] if iter.idx_var?;

    // Environment the body runs in
    body_env = foreach_stmt_body_env(iter, body, env);

    // Compiling loop body and adjusting entry code
    entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;
    body_code = body_code_setup & body_code;

    // Mapping source to destination arrays
    read_len_instr = set_ivar32(count_var, get_size(seq_surr));
    map_instr = foreach(
      seq:        seq_surr,
      src_array:  src_array_var,
      count_var:  count_var,
      idx_var:    hidden_idx_var,
      it_var:     it_var,
      body:       body_code
    );

    return ((entry_code | read_len_instr, map_instr), just(surrs), [], init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] foreach_stmt_body_env(CollValueIter iter, Statement+ body, [EnvVar -> Type] env) {
      elt_type = seq_elem_supertype(expr_type(iter.src_expr, env));
      loop_vars_env = partial_asgnm_env_updates(iter.vars, elt_type);

      loop_vars_env = loop_vars_env & [iter.idx_var -> type_nat] if iter.idx_var?;
      exit_env = update_env(body, env & loop_vars_env);
      return merge_envs(env, exit_env) & loop_vars_env;
    }
  }


  StmtCompInfo unord_coll_iter_opt_code(Maybe[StdVar]+ vars, Expr src_expr, Maybe[Expr]+ args, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_surrs : Maybe[ObjExpr]*;

    // Calculating input sequence type, and returning early if the type is trivial
    coll_type = expr_type(src_expr, env);
    if coll_type == empty_type
      ## just(surrogates) OR nothing?
      return ((terminate), just(surrogates), [], init_var_gen);
    else if is_subset(coll_type, empty_rel_type)
      return ((), just(surrogates), [], init_var_gen);

    // Evaluation of input expression
    entry_code, coll_surr, var_gen = opt_eval_code(src_expr, env, init_var_gen);
    ## IS THIS NEEDED AT ALL? WHY WAS IT HERE IN THE FIRST PLACE?
    if not coll_surr :: <LocVar, StdVar> {
      coll_var, var_gen = next_obj_var(var_gen);
      entry_code = (entry_code | set_var(coll_var, coll_surr));
      coll_surr = coll_var;
    }

    // Evaluation of arguments
    args_eval_code, args_surrs, var_gen = sparse_opt_eval_code(args, env, var_gen);

    // Mapping the index of each iterator variable to that of the corresponding relation argument
    var_arg_idx_map = indexes(args, $ == nothing);

    // Type and representation of the arguments of the source set/relation
    local_surrs = [];
    iter_vars_setup_code = ();

    if |args| == 1 {
      fail if |vars| != 1;
      elt_type = nonempty_type(set_elem_supertype(coll_type));
      elt_repr = opt_repr(elt_type);
      it_var, var_gen = next_set_it_var(var_gen);
      var = only(vars);
      loop_vars_env = [value(var) -> elt_type if var != nothing];
      if var != nothing {
        var = value(var);
        elt_var = low_level_var(elt_repr, var);
        local_surrs = [var -> obj_expr(elt_var) if var != elt_var];
        iter_vars_setup_code = (set_any_var(elt_var, get_curr_obj(it_var)));
      }
    }
    else if |args| == 2 {
      args_types = (nonempty_type(t) : t <- bin_rel_args_supertypes(coll_type));
      args_reprs = (opt_repr(t) : t <- args_types);
      it_var, var_gen = next_bin_rel_it_var(var_gen);
      loop_vars_env = [value(v) -> args_types(i) : v @ i <- vars, v != nothing];
      for v @ i <- vars {
        if v != nothing {
          var = value(v);
          arg_idx = var_arg_idx_map(i);
          low_level_var = low_level_var(args_reprs(arg_idx), var);
          local_surrs = local_surrs & [var -> obj_expr(low_level_var) if var != low_level_var];
          fail if not arg_idx :: <0..1>;
          instr = set_any_var(low_level_var, get_curr_arg(it_var, arg_idx));
          iter_vars_setup_code = (iter_vars_setup_code | instr);
        }
      }
    }
    else {
      fail if |args| != 3;
      args_types = (nonempty_type(t) : t <- tern_rel_args_supertypes(coll_type));
      args_reprs = (opt_repr(t) : t <- args_types);
      it_var, var_gen = next_tern_rel_it_var(var_gen);
      loop_vars_env = [value(v) -> args_types(i) : v @ i <- vars, v != nothing];
      for v @ i <- vars {
        if v != nothing {
          var = value(v);
          arg_idx = var_arg_idx_map(i);
          low_level_var = low_level_var(args_reprs(arg_idx), var);
          local_surrs = local_surrs & [var -> obj_expr(low_level_var) if var != low_level_var];
          fail if not arg_idx :: <0..2>;
          instr = set_any_var(low_level_var, get_curr_arg(it_var, arg_idx));
          iter_vars_setup_code = (iter_vars_setup_code | instr);
        }
      }
    }

    // Environment the body runs in
    exit_env = update_env(body, env & loop_vars_env);
    body_env = merge_envs(env, exit_env) & loop_vars_env;

    // Compiling loop body and adjusting entry code
    entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;
    // body_code = body_code_setup & body_code;

    code = entry_code & args_eval_code & (
      get_any_rel_iter(it_var, coll_surr, args_surrs),
      repeat((
        break_if(is_out_of_range(it_var))
        ) & iter_vars_setup_code & body_code & (
        move_forward(it_var)
      ))
    );

    return (code, just(surrs), [], init_var_gen);
  }


  // type RelVarIter = rel_var_iter(vars: Maybe[StdVar]+, rel_var: AnyRelVar, args: Maybe[Expr]+);
  StmtCompInfo columnar_rel_var_iter_opt_code(RelVarIter iter, Statement+ body, [EnvVar -> Type] env, VarGen var_gen) {
    fail if not iter.args :: (Maybe[Expr], Nothing);

    arg_0 = iter.args(0);
    if arg_0 == nothing {
      fail if |iter.vars| != 2;
      return full_column_iter_code(iter.vars, iter.rel_var, body, env, var_gen);
    }
    else {
      key_arg = value(arg_0);
      value_var = only_unsafe(iter.vars);
      return one_value_iter_code(key_arg, value_var, iter.rel_var, body, env, var_gen);
    }


    StmtCompInfo one_value_iter_code(Expr key_arg, Maybe[StdVar] value_var, AnyRelVar rel_var, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
      key_arg_eval_code, key_arg_alias, var_gen = opt_eval_code(key_arg, env, init_var_gen);

      key_arg_surr, var_gen = next_int32_var(var_gen);

      // Selecting the candidate tables among those the logical relation is partitioned into
      key_arg_type = expr_type(key_arg, env);
      return ((terminate(true)), just(surrogates), [], init_var_gen) if key_arg_type == empty_type;
      candidate_tables = overlapping_tables(rel_var, (just(key_arg_type), nothing));

      // Iterating through all candidate tables
      entry_code = ();
      code = ();
      surrs = surrogates;
      for tv <- isort(candidate_tables) {
        sign = table_signature(tv);
        low_level_value_var = apply(value_var, low_level_var(low_level_repr(sign(1)), $));

        store_id = table_col_store_id(tv, 0);
        store_type = value_store_type(rel_auto_type(rel_var), unqualified(store_id));
        store_id = substitute(store_id);

        // Environment the body runs in
        sgn = table_signature(tv);
        loop_vars = [value(value_var) -> sgn(1) if value_var != nothing];
        exit_env = update_env(body, env & loop_vars);
        body_env = merge_envs(env, exit_env) & loop_vars;

        local_surrs = [value(value_var) -> obj_expr(value_unsafe(low_level_value_var)) if value_var != nothing];

        let surrogates = surrs {
          // This is not a real loop body, since it's run at most once,
          // but the machinery used for loops should work here as well
          entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);
        }

        if body_code != () {
          entry_code = entry_code & entry_code_fixes;

          code = (code |
            set_ivar32(key_arg_surr, value_to_surr(store_id, value_store_encoded_expr(store_type, key_arg_alias))),
            do_if_not(
              is_eq(key_arg_surr, -1),
              do_if(
                table_contains(tv, table_info(tv), (just(key_arg_surr), nothing), false),
                ( set_any_var(
                    value(low_level_value_var),
                    column_lookup(substitute(tv), key_arg_surr, column_repr(sign(1)))
                  ) if low_level_value_var != nothing
                ) & body_code
              )
            )
          );
        }
      }

      return (code, just(surrs), [], init_var_gen);
    }


    StmtCompInfo full_column_iter_code((Maybe[StdVar], Maybe[StdVar]) vars, AnyRelVar rel_var, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
      var_0, var_1 = vars;

      if var_0 != nothing {
        surr_var_0 = shadow_surr_var(value(var_0));
        var_gen = init_var_gen;
      }
      else {
        surr_var_0, var_gen = next_int32_var(init_var_gen);
      }

      // Selecting the candidate tables among those the logical relation is partitioned into
      // In this specific case, that means all of them
      candidate_tables = overlapping_tables(rel_var, (nothing, nothing));

      // Iterating through all candidate tables
      entry_code = ();
      code = ();
      surrs = surrogates;
      for tv <- isort(candidate_tables) {

        sign = table_signature(tv);
        vars_reprs = [value(v) -> low_level_repr(sign(i)) : v @ i <- vars, v != nothing];
        low_level_vars = [v -> low_level_var(r, v) : v r <- vars_reprs];

        store_id = table_col_store_id(tv, 0);
        store_type = value_store_type(rel_auto_type(rel_var), unqualified(store_id));
        store_id = substitute(store_id);

        col_repr = column_repr(sign(1));
        it_var, var_gen = next_column_it_var(init_var_gen, col_repr);

        vars_setup_code = (
          set_ivar32(surr_var_0, get_unknown_arg(it_var, 0)) if var_0 != nothing or var_1 != nothing,
          ## WORKAROUND FOR A BUG IN VERSION 0.1 OF THE COMPILER
          { llvar = low_level_vars(value(var_0));
            return surr_to_decoded_value(llvar, store_id, store_type, surr_var_0);
          } if var_0 != nothing,
          ## WORKAROUND FOR A BUG IN VERSION 0.1 OF THE COMPILER
          { llvar = low_level_vars(value(var_1));
            return set_any_var(llvar, column_lookup(substitute(tv), surr_var_0, col_repr));
          } if var_1 != nothing
        );

        // Environment the body runs in
        sgn = table_signature(tv);
        loop_vars = [value(v) -> sgn(i) : v @ i <- vars, v != nothing];
        exit_env = update_env(body, env & loop_vars);
        body_env = merge_envs(env, exit_env) & loop_vars;

        local_surrs = [v -> obj_expr(llv) : v llv <- low_level_vars];

        let surrogates = surrs
          entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);

        if body_code != () {
          entry_code = entry_code & entry_code_fixes; ## BUG: NOT SURE WHAT THIS IS FOR, AND WHETHER IT'S OK

          loop_code = (break_if(is_out_of_range(it_var))) & vars_setup_code & body_code & (move_forward(it_var));
          table_code = (
            get_column_iter(it_var, substitute(tv)),
            repeat(loop_code)
          );

          code = code & table_code;
        }
      }

      return (code, just(surrs), [], init_var_gen);
    }
  }

  // type RelVarIter = rel_var_iter(vars: Maybe[StdVar]+, rel_var: AnyRelVar, args: Maybe[Expr]+);
  StmtCompInfo rel_var_iter_opt_code(RelVarIter iter, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    table_args = iter.args;
    set_args = values(table_args);

    bound_args_idxs = (i : a @ i <- table_args, a != nothing);
    free_args_idxs = (i : a @ i <- table_args, a == nothing);
    arg_idx_bound_arg_idx = [i -> j : i @ j <- bound_args_idxs];

    entry_code, args_aliases, var_gen = opt_eval_code(set_args, env, init_var_gen);

    surr_vars, var_gen = next_int32_vars(var_gen, |set_args|);
    shadow_surr_vars, var_gen = next_int32_vars(var_gen, [i : v @ i <- iter.vars, v != nothing]);
    it_var, var_gen = next_table_it_var(var_gen, |table_args|, symmetric(iter.rel_var));

    surr_args = (apply(a, surr_vars(arg_idx_bound_arg_idx(i))) : a @ i <- table_args);

    symmetric = symmetric(iter.rel_var);

    // Selecting the candidate tables among those the logical relation is partitioned into
    args_types = (apply(a, expr_type($, env)) : a <- iter.args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: Maybe[NeType]+;
    candidate_tables = overlapping_tables(iter.rel_var, args_types);

    // Iterating through all candidate tables
    code = ();
    surrs = surrogates;
    for tv <- isort(candidate_tables) {
      assert (a <- surr_args : a == nothing);

      sign = table_signature(tv);
      vars_reprs = [value(v) -> low_level_repr(sign(free_args_idxs(i))) : v @ i <- iter.vars, v != nothing];
      low_level_vars = [v -> low_level_var(r, v) : v r <- vars_reprs];

      vars_setup_code = join(({
        shadow_surr_var = shadow_surr_vars(i);
        store_id = table_col_store_id(tv, free_args_idxs(i));
        store_type = value_store_type(rel_auto_type(iter.rel_var), unqualified(store_id));
        store_id = substitute(store_id);
        return (
          set_ivar32(shadow_surr_var, get_unknown_arg(it_var, i)),
          surr_to_decoded_value(low_level_vars(value(v)), store_id, store_type, shadow_surr_var)
        );
      } : v @ i <- iter.vars, v != nothing));

      // Environment the body runs in
      sgn = table_signature(tv);
      loop_vars = [value(v) -> sgn(free_args_idxs(i)) : v @ i <- iter.vars, v != nothing];
      exit_env = update_env(body, env & loop_vars);
      body_env = merge_envs(env, exit_env) & loop_vars;

      local_surrs = [v -> obj_expr(llv) : v llv <- low_level_vars];

      let surrogates = surrs
        entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);

      if body_code != () {
        entry_code = entry_code & entry_code_fixes;

        loop_code = (break_if(is_out_of_range(it_var))) & vars_setup_code & body_code & (move_forward(it_var));
        table_code = (
          get_table_iter(it_var, substitute(tv), nonempty(surr_args)),
          repeat(nonempty(loop_code))
        );

        for e @ i <- reverse(args_aliases) {
          idx = rat(bound_args_idxs, i);
          arg_type = value_unsafe(args_types(idx));
          store_id = table_col_store_id(tv, idx);
          store_type = value_store_type(rel_auto_type(iter.rel_var), unqualified(store_id));
          store_id = substitute(store_id);
          surr_var = rat(surr_vars, i);
          table_code = opt_do_if(
            value_store_guard(store_type, e, arg_type),
            ( set_ivar32(surr_var, value_to_surr(store_id, value_store_encoded_expr(store_type, e))),
              do_if_not(is_eq(surr_var, -1), table_code)
            )
          );
        }

        code = code & table_code;
      }
    }

    return (entry_code & code, just(surrs), [], init_var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  ([SurrExpr -> ObjExpr], Instr*, Instr*) reconcile([SurrExpr] surr_vars, [SurrExpr -> ObjExpr] surrs1, [SurrExpr -> ObjExpr] surrs2) {
    // Reconciling the surrogates
    sync_vars = [v : v <- surr_vars, lookup(surrs1, v, v) == lookup(surrs2, v, v)];
    unsync_vars = surr_vars - sync_vars;
    fail if not unsync_vars :: [StdVar];
    surrs = [v -> surrs1(v, !) : v <- sync_vars, surrs1(v, _)];

    // Syncronization code
    sync_code_1 = ();
    sync_code_2 = ();
    for v <- isort(unsync_vars) {
      sync_code_1 = (sync_code_1 | set_var(v, surrs1(v, !))) if surrs1(v, _);
      sync_code_2 = (sync_code_2 | set_var(v, surrs2(v, !))) if surrs2(v, _);
    }

    return (surrs, sync_code_1, sync_code_2);
  }


  // The list of surrogates we return is the one we have:
  //   1) Just before the loop starts
  //   2) When the loop breaks
  //   3) After any iteraction of the loop terminates

  // That means that if the loop body never breaks or terminates we'll just
  // return the entry environment.

  // Since we can only remove surrogates from the initial list, then the
  // returned one is always a subset of it, and we can start with the initial
  // entry list and keep removing surrogates from it until everything matches

  (Instr*, Instr*, [SurrExpr -> ObjExpr])
  loop_stable_code(Statement+ stmts, [SurrExpr -> ObjExpr] local_surrs, [EnvVar -> Type] env, VarGen var_gen) {
    ## MAYBE HERE I COULD EXPLICITLY PASS A LIST OF VARIABLES THAT ARE
    ## EXPECTED TO SURVIVE THE LOOP INSTEAD OF TRYING TO FIGURE THAT OUT SOMEHOW
    surr_vars = [v : v _ <- env, v :: SurrExpr, not local_surrs(v, _)];
    entry_surrs = surrogates;
    entry_code = ();

    loop {
      body_surrs = entry_surrs & local_surrs;
      let surrogates = body_surrs, exp_break_surrs = just(body_surrs)
        body_code, exit_surrs, break_surrs, _ = stmts_opt_code(stmts, env, var_gen);

      // Finding out what variables get out of sync after one iteraction of the loop
      out_of_sync_vars = [v : v e <- entry_surrs, is_out_of_sync(v, e, exit_surrs, break_surrs)];

      // If no variable is out of sync, then we're done
      if out_of_sync_vars == [] {
        return (entry_code, body_code, entry_surrs) if exit_surrs == nothing;
        exit_surrs = value(exit_surrs);
        for v <- isort(surr_vars) {
          assert not entry_surrs(v, _) or (exit_surrs(v, _) and entry_surrs(v, !) == exit_surrs(v, !));
          if not entry_surrs(v, _) and exit_surrs(v, _) {
            fail if not v :: StdVar;
            body_code = (body_code | set_var(v, exit_surrs(v, !)));
          }
        }
        return (entry_code, body_code, entry_surrs);
      }

      // Removing the unsyncronized variables from the initial list of surrogates
      // by physically storing them into their corresponding variables
      for v <- isort(out_of_sync_vars) {
        fail if not v :: StdVar;
        entry_code = (entry_code | set_var(v, entry_surrs(v, !)));
      }
      entry_surrs = remove_keys(entry_surrs, out_of_sync_vars);
    }


    Bool is_out_of_sync(SurrExpr var, ObjExpr entry_surr, Maybe[[SurrExpr -> ObjExpr]] maybe_exit_surrs, [[SurrExpr -> ObjExpr]] break_surrs) {
      if maybe_exit_surrs != nothing {
        exit_surrs = value(maybe_exit_surrs);
        return true if not exit_surrs(var, _) or exit_surrs(var, !) != entry_surr;
      }
      return (surrs <- break_surrs : not surrs(var, _) or surrs(var, !) != entry_surr);
    }
  }
}
