implicit program           : Program,
         options           : CompOptions,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         surrogates        : [SurrExpr -> ObjExpr]
{
  (Instr*, ObjExpr, VarGen) do_expr_opt_eval_code(DoExpr expr, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    type = expr_type(expr, init_env, typed_vars = []); ## NOT SURE ABOUT typed_vars HERE
    repr = if type != empty_type then opt_repr(type) else :object;
    return do_expr_opt_eval_code(expr, repr, init_env, init_var_gen);
  }


  (Instr*, ObjExpr, VarGen) do_expr_opt_eval_code(DoExpr expr, AnyLowLevelRepr repr, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    var, ret_var_gen = next_var(repr, init_var_gen);
    let typed_vars = expr.typed_vars, exp_break_surrs = nothing, result_var = var:
      code, unused_var_1, unused_var_2, unused_var_3 = stmts_opt_code(expr.body, init_env, ret_var_gen);
    ;
    return ((execute_block(code) if code != ()), obj_expr(var), ret_var_gen);
  }
}


type StmtCompInfo = (Instr*, Maybe[[SurrExpr -> ObjExpr]], [[SurrExpr -> ObjExpr]], VarGen);


implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         options           : CompOptions,
         context           : Context,
         typed_vars        : [StdVar -> NeType],
         surrogates        : [SurrExpr -> ObjExpr],
         exp_break_surrs   : Maybe[[SurrExpr -> ObjExpr]],
         result_var        : AnyLocVar
{
  StmtCompInfo stmts_opt_code(Statement* stmts, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    return ((), just(surrogates), [], init_var_gen) if stmts == ();

    var_gen = init_var_gen;
    code = ();
    env = init_env;
    surrs = just(surrogates);
    break_surrs = [];
    for s <- stmts:
      fail if surrs == nothing;
      stmt_code, surrs, stmt_break_surrs, var_gen = stmt_opt_code(s, env, var_gen, surrogates = value(surrs));
      code = code & stmt_code;
      break_surrs = break_surrs & stmt_break_surrs;
      env = update_env(s, env);
    ;
    return (code, surrs, break_surrs, var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo stmt_opt_code(Statement stmt, [EnvVar -> Type] env, VarGen var_gen) =
    break_stmt            = break_stmt_opt_code(env, var_gen),
    fail_stmt()           = fail_stmt_opt_code(stmt, env, var_gen),
    loop_stmt(ss?)        = loop_stmt_opt_code(ss, env, var_gen),
    print_stmt(e?)        = print_stmt_opt_code(e, env, var_gen),
    return_stmt(e?)       = return_stmt_opt_code(e, env, var_gen),
    assert_stmt()         = assert_stmt_opt_code(stmt, env, var_gen),
    let_stmt()            = let_stmt_opt_code(stmt.asgnms, stmt.body, env, var_gen),
    assignment_stmt()     = assignment_stmt_opt_code(stmt.vars, stmt.value, env, var_gen),
    seq_update_stmt()     = seq_update_stmt_opt_code(stmt, env, var_gen),
    if_stmt()             = if_stmt_opt_code(stmt, env, var_gen),
    for_stmt()            = for_stmt_opt_code(stmt, env, var_gen),
    foreach_stmt()        = foreach_stmt_opt_code(stmt, env, var_gen),
    return_stmt           = ((exit_block), just(surrogates), [], var_gen),
    proc_call_stmt()      = proc_call_stmt_opt_code(stmt, env, var_gen),

    send_msg_stmt()       = send_msg_stmt_opt_code(stmt.target, stmt.msg, env, var_gen),
    try_update_stmt()     = try_update_stmt_opt_code(stmt.name, stmt.args, env, var_gen),
    set_memb_var_stmt()   = set_memb_var_stmt_opt_code(stmt.var, stmt.value, env, var_gen),
    delete_stmt()         = delete_stmt_opt_code(stmt.var, stmt.args, env, var_gen),
    insert_stmt()         = insert_stmt_opt_code(stmt.var, stmt.args, env, var_gen),
    update_stmt()         = update_stmt_opt_code(stmt.var, stmt.args, env, var_gen),

    set_input_ctrl_stmt()         = set_input_ctrl_stmt_opt_code(stmt.var, stmt.input, stmt.value, env, var_gen),
    clear_input_ctrl_stmt()       = clear_input_ctrl_stmt_opt_code(stmt.var, stmt.input, env, var_gen),
    set_elapsed_time_ctrl_stmt()  = set_elapsed_time_ctrl_stmt_opt_code(stmt.var, stmt.time, env, var_gen),
    apply_ctrl_stmt()             = apply_ctrl_stmt_opt_code(stmt.auto_var, stmt.res_var, env, var_gen),
    send_msg_ctrl_stmt()          = send_msg_ctrl_stmt_opt_code(stmt.res_var, stmt.db_var, stmt.msg, env, var_gen),
    read_state_ctrl_stmt()        = read_state_ctrl_stmt_opt_code(stmt.res_var, stmt.auto_var, env, var_gen),
    restore_state_ctrl_stmt()     = restore_state_ctrl_stmt_opt_code(stmt.res_var, stmt.auto_var, stmt.state, fetch(stmt), env, var_gen);


  StmtCompInfo send_msg_stmt_opt_code(NestedDBVar target, Expr msg, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, unused_var = opt_eval_code(msg, env, init_var_gen);
    spent_var = nested_db_spent(target);
    code = (
      code |
      do_if(spent_var, terminate),
      send_msg(target, var_type(target), surr, false),
      set_bvar(spent_var, true)
    );
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo try_update_stmt_opt_code(UpdateSymbol name, Expr* args, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surrs, unused_var = opt_eval_code(args, env, init_var_gen);
    code = (code | try_update(this_db_symbol, update_id(name, |args|), surrs));
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo set_memb_var_stmt_opt_code(MembVar var, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, unused_var = opt_eval_code(value, env, init_var_gen);
    pvar = pending_state_var(bare_id(var));
    code = (code | do_if_not(is_blank(pvar), terminate), set_var(pvar, surr));
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo delete_stmt_opt_code(RelVar rel_var, Maybe[Expr]+ args, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_surrs : Maybe[Int32Var]*;

    args_types = (apply(a, expr_type($, env)) : a <- args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: Maybe[NeType]+;

    symmetric = symmetric(rel_var);

    code, args_aliases, var_gen = sparse_opt_eval_code(args, env, init_var_gen);

    args_surrs = ();
    for a <- args_aliases:
      if a != nothing:
        surr, var_gen = next_int32_var(var_gen);
        args_surrs = (args_surrs | just(surr));
      else
        args_surrs = (args_surrs | nothing);
      ;
    ;

    fail if args_aliases == () or args_surrs == ();

    phys_rel_vars = overlapping_phys_rel_vars(rel_var, args_types);
    rel_auto = cast_database(context);
    for v <- isort(phys_rel_vars):
      table_code = delete_code(table_var(v), args_aliases, args_surrs, symmetric);
      attrs = [a : a <- rel_auto.attr_map(v, ?)];
      attr_args_aliases = (args_aliases | nothing);
      attr_args_surrs = (args_surrs | nothing);
      for a <- isort(attrs):
        assert arity(a) == arity(rel_var) + 1;
        table_code = table_code & delete_code(table_var(a), attr_args_aliases, attr_args_surrs, symmetric);
      ;
      code = code & table_code;
    ;

    return (code, just(surrogates), [], init_var_gen);


    Instr* delete_code(TableVar table_var, Maybe[ObjExpr]+ args_aliases, Maybe[Int32Var]+ args_surrs, Bool symmetric) {
      code = (queue_deletes(table_var, nonempty(args_surrs), symmetric));
      for a @ ri <- reverse(args_aliases):
        if a != nothing:
          i = nat(|args_aliases| - ri - 1);
          store_id = table_col_store_id(table_var, i);
          store_type = value_store_type(this_db_symbol, store_id);
          arg_surr = value_unsafe(args_surrs(i));
          code = (
            set_ivar32(arg_surr, value_to_surr(store_id, value_store_encoded_expr(store_type, value(a)))),
            do_if_not(is_eq(arg_surr, -1), code)
          );
        ;
      ;
      return code;
    }
  }


  ## BAD BAD BAD: ALMOST IDENTICAL TO update_stmt_opt_code()
  ## WHEN CHANGING ONE, ALWAYS REMEMBER TO CHANGE THE OTHER AS WELL
  StmtCompInfo insert_stmt_opt_code(RelVar rel_var, Expr+ args, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_types = (expr_type(a, env) : a <- args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: NeType+;

    args_eval_code, args_aliases, var_gen = opt_eval_code(args, env, init_var_gen);
    fail if args_aliases == ();

    arity = |args_aliases|;
    surr_vars, var_gen = next_int32_vars(var_gen, arity);
    fail if surr_vars == ();
    is_new_val_vars, var_gen = next_bool_vars(var_gen, arity);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = nonempty(overlapping_tables(rel_var, (just(t) : t <- args_types)));

    if |candidate_tables| == 1:
      // Easy case: there's only one table
      table_var = only(candidate_tables);

      pre_insert_code = ({
        store_id = table_col_store_id(table_var, i);
        store_type = value_store_type(this_db_symbol, store_id);
        surr_var = surr_vars(i);
        return lookup_or_queue_insert_value(surr_var, store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);

      insertion_code = (queue_insert_tuple(table_var, surr_vars));
      code = args_eval_code & pre_insert_code & insertion_code;

      return (code, just(surrogates), [], init_var_gen);
    ;

    // Choosing the dispatch arguments
    signatures = [table_signature(tv) : tv <- candidate_tables];
    disp_args = optimal_dispatch_args(signatures, typedefs);

    cases = [{
      types = table_signature(tv);
      code = ({
        store_id = table_col_store_id(tv, i);
        store_type = value_store_type(this_db_symbol, store_id);
        return lookup_or_queue_insert_value(surr_vars(i), store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);
      code = (code | queue_insert_tuple(tv, surr_vars), exit_block);
      return (types, code);
    } : tv <- candidate_tables];

    code = (args_eval_code | execute_block(dynamic_dispatch_code(args_aliases, cases)));

    return (code, just(surrogates), [], init_var_gen);
  }


  ## BAD BAD BAD: ALMOST IDENTICAL TO insert_stmt_opt_code()
  ## WHEN CHANGING ONE, ALWAYS REMEMBER TO CHANGE THE OTHER AS WELL
  StmtCompInfo update_stmt_opt_code(RelVar rel_var, Expr+ args, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_types = (expr_type(a, env) : a <- args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: NeType+;

    args_eval_code, args_aliases, var_gen = opt_eval_code(args, env, init_var_gen);
    fail if args_aliases == ();

    arity = |args_aliases|;
    surr_vars, var_gen = next_int32_vars(var_gen, arity);
    fail if surr_vars == ();
    is_new_val_vars, var_gen = next_bool_vars(var_gen, arity);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = nonempty(overlapping_tables(rel_var, (just(t) : t <- args_types)));

    symmetric = symmetric(rel_var);
    keys = isort(relvar_keys(rel_var));
    deletes_args = ((maybe(v, k(i)) : v @ i <- surr_vars) : k <- keys);

    if |candidate_tables| == 1:
      // Easy case: there's only one table
      table_var = only(candidate_tables);

      pre_insert_code = ({
        store_id = table_col_store_id(table_var, i);
        store_type = value_store_type(this_db_symbol, store_id);
        surr_var = surr_vars(i);
        return lookup_or_queue_insert_value(surr_var, store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);

      insertion_code = (
        (queue_deletes(table_var, as, symmetric) : as <- deletes_args) |
        queue_insert_tuple(table_var, surr_vars)
      );
      code = args_eval_code & pre_insert_code & insertion_code;

      return (code, just(surrogates), [], init_var_gen);
    ;

    // Choosing the dispatch arguments
    signatures = [table_signature(tv) : tv <- candidate_tables];
    disp_args = optimal_dispatch_args(signatures, typedefs);

    cases = [{
      types = table_signature(tv);
      code = ({
        store_id = table_col_store_id(tv, i);
        store_type = value_store_type(this_db_symbol, store_id);
        return lookup_or_queue_insert_value(surr_vars(i), store_id, value_store_encoded_expr(store_type, e));
      } : e @ i <- args_aliases);
      code = code & (queue_deletes(tv, as, symmetric) : as <- deletes_args);
      code = (code | queue_insert_tuple(tv, surr_vars), exit_block);
      return (types, code);
    } : tv <- candidate_tables];

    code = (args_eval_code | execute_block(dynamic_dispatch_code(args_aliases, cases)));

    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo send_msg_ctrl_stmt_opt_code(StdVar res_var, LocDBVar db_var, Expr msg, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, unused_var = opt_eval_code(msg, env, init_var_gen);
    db_type = var_type(db_var);
    res_bvar = low_level_bvar(res_var);
    code = (code | send_msg(db_var, db_type, surr, true, res_bvar));
    surrs = update(surrogates, res_var, bool_obj(res_bvar));
    return (code, just(surrs), [], init_var_gen);
  }


  StmtCompInfo read_state_ctrl_stmt_opt_code(StdVar res_var, LocDBVar db_var, [EnvVar -> Type] env, VarGen var_gen) {
    code = (copy_state(res_var, db_var, var_type(db_var)));
    return (code, just(surrogates), [], var_gen);
  }


  StmtCompInfo restore_state_ctrl_stmt_opt_code(StdVar res_var, LocDBVar db_var, Expr state, Maybe[Any] stmt_loc, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, unused_var = opt_eval_code(state, env, init_var_gen);
    res_bvar = low_level_bvar(res_var);
    code = (code | set_state(res_bvar, db_var, surr, var_type(db_var)));
    surrs = update(surrogates, res_var, bool_obj(res_bvar));
    return (code, just(surrs), [], init_var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo read_state_ctrl_stmt_opt_code(StdVar res_var, LocAutoVar auto_var, [EnvVar -> Type] env, VarGen init_var_gen) {
    tmp_var, unused_var = next_obj_var(init_var_gen);
    code = (
      branch(
        state_is_def(auto_var, var_type(auto_var)),
        ( copy_persistent_state(tmp_var, auto_var, var_type(auto_var)),
          mk_tagged_obj(res_var, object(:maybe), tmp_var)
        ),
        (set_var(res_var, object(:nothing)))
      )
    );
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo restore_state_ctrl_stmt_opt_code(StdVar res_var, LocAutoVar auto_var, Expr state, Maybe[Any] stmt_loc, [EnvVar -> Type] env, VarGen init_var_gen) {
    eval_code, surr, var_gen = opt_eval_code(state, env, init_var_gen);

    if options.debug_mode:
      file, line = file_and_line(fetch(context), stmt_loc);
      msg = "Cannot set the state of a reactive automaton that has already been initialized: " & user_repr(auto_var);
      log_instr = log_runtime_failure(true, file, line, just(msg), ());
      err_code = (log_instr);
    else
      err_code = ();
    ;

    check_instr = do_if_not(qual_bool_var(auto_var, is_new), (err_code | terminate(true)));
    set_state_instr = set_persistent_state(auto_var, surr, var_type(auto_var));
    code = (check_instr) & eval_code & (set_state_instr);
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo set_input_ctrl_stmt_opt_code(LocAutoVar var, Symbol input, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);
    auto_type = var_type(var);
    code = (code | set_input(var, auto_type, input, surr));
    return (code, just(surrogates), [], var_gen);
  }


  StmtCompInfo clear_input_ctrl_stmt_opt_code(LocAutoVar var, Symbol input, [EnvVar -> Type] env, VarGen init_var_gen) {
    auto_type = var_type(var);
    return ((clear_input(var, auto_type, input)), just(surrogates), [], init_var_gen);
  }


  StmtCompInfo set_elapsed_time_ctrl_stmt_opt_code(LocAutoVar var, Expr time, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(time, env, init_var_gen);
    code = (code | set_ivar(elapsed_time(var), get_int_val(surr)));
    return (code, just(surrogates), [], var_gen);
  }


  StmtCompInfo apply_ctrl_stmt_opt_code(LocAutoVar auto_var, StdVar res_var, [EnvVar -> Type] env, VarGen init_var_gen) {
    auto_type = var_type(auto_var);
    bvar = low_level_bvar(res_var);
    res_value = if is_time_sensitive(auto_type) then are_eq(int_obj(elapsed_time(auto_var)), int_obj(0)) else true;
    code = (auto_apply(auto_var, auto_type), set_bvar(bvar, res_value));
    surrs = update(surrogates, res_var, bool_obj(bvar));
    return (code, just(surrs), [], init_var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo seq_update_stmt_opt_code(SeqUpdateStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    idx_eval_code, idx_surr, var_gen = opt_eval_code(stmt.idx, env, init_var_gen);
    val_eval_code, val_surr, var_gen = opt_eval_code(stmt.value, env, var_gen);
    tmp_var, var_gen = next_obj_var(var_gen);
    update_code = (
      update_seq_at(tmp_var, stmt.seq_var, get_int_val(idx_surr), val_surr),
      set_var(stmt.seq_var, tmp_var)
    );
    code = idx_eval_code & val_eval_code & update_code;
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo fail_stmt_opt_code(FailStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    if options.debug_mode:
      vars = ((v, lookup(surrogates, v, v)) : v <- isort(stmt.env));
      code = (log_runtime_failure(false, stmt.file, stmt.line, nothing, vars));
    else
      code = ();
    ;
    return ((code | terminate), nothing, [], var_gen);
  }


  StmtCompInfo assert_stmt_opt_code(AssertStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    return ((), just(surrogates), [], var_gen) if options.ignore_assertions;

    eval_code, surr, unused_var = opt_eval_code(stmt.cond, env, var_gen);
    expr_vars = extern_vars(stmt.cond);
    vars = isort([v : v <- stmt.env, expr_vars(v)]) & isort([v : v <- stmt.env, not expr_vars(v)]);
    vars = ((v, lookup(surrogates, v, v)) : v <- vars);
    log_instr = log_runtime_failure(true, stmt.file, stmt.line, stmt.text, vars);
    check_instr = do_if_not(bool_value(surr), (log_instr, terminate(true)));
    return ((eval_code | check_instr), just(surrogates), [], var_gen);
  }


  StmtCompInfo print_stmt_opt_code(Expr expr, [EnvVar -> Type] env, VarGen var_gen) {
    eval_code, surr, unused_var = opt_eval_code(expr, env, var_gen);
    return ((eval_code | print_obj(surr)), just(surrogates), [], var_gen);
  }


  StmtCompInfo let_stmt_opt_code([ImplArg -> Expr] asgnms, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    ## THIS SHOULD BE CHECKED IN THE PROPER PLACE, BOTH IN LAYER 1 AND 2
    ## IT'S A TEMPORARY LIMITATION THAT SHOULD BE REMOVED
    assert subset(outcomes(body), [:fails, :falls_through]);

    ## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
    ord_asgnms = isort(asgnms);
    backup_vars, var_gen = next_obj_vars(init_var_gen, |ord_asgnms|);

    set_up_code = join(({
        eval_code, surr, unused_var = opt_eval_code(e, env, var_gen);
        backup_var = backup_vars(i);
        return (eval_code | set_var(backup_var, v), set_var(v, surr));
      } : v, e @ i <- ord_asgnms
    ));

    tear_down_code = reverse((set_var(v, backup_vars(i)) : v, unused_var @ i <- ord_asgnms));

    env_delta = [a -> expr_type(e, env) : a, e <- asgnms];
    body_env = update(env, env_delta);

    body_code, surrs, break_surrs, var_gen = stmts_opt_code(body, body_env, var_gen);
    assert break_surrs == []; ## SEE COMMENT AT THE BEGINNING OF THIS FUNCTION

    code = set_up_code & body_code & tear_down_code;
    return (code, surrs, break_surrs, var_gen);
  }


  // If a surrogates is defined here but not in the expected list,
  // we just remove it by physically storing its value.

  // If a surrogates is defined in the expected list but not here
  // there's nothing we can do here to fix that. We just return
  // the list of surrogates we end up with and we leave it to code
  // higher up in the call stack to fix that and retry

  // Finally, if a surrogate is defined in both lists, but the
  // definitions are different, we remove it here and we leave
  // to the calling code to fix the expected list and retry

  StmtCompInfo break_stmt_opt_code([EnvVar -> Type] env, VarGen var_gen) {
    exp_surrs = value_unsafe(exp_break_surrs);
    surrs_to_drop = [v : v, e <- surrogates, not exp_surrs(v, *) or exp_surrs(v, !!) != e];
    fail if not surrs_to_drop :: [StdVar];
    sync_code = (set_var(v, surrogates(v, !!)) : v <- isort(surrs_to_drop));
    surrs = remove_keys(surrogates, surrs_to_drop);
    return ((sync_code | break_loop), nothing, [surrs], var_gen);
  }


  // proc_call_stmt(res_var: StdVar?, proc_name: ProcSymbol, args: Expr*);
  StmtCompInfo proc_call_stmt_opt_code(ProcCallStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, args_surrs, var_gen = opt_eval_code(stmt.args, env, init_var_gen);
    call_instr = if stmt.res_var?
      then call_proc(stmt.res_var, stmt.proc_name, args_surrs, ())
      else call_proc(stmt.proc_name, args_surrs, ());
    return ((code | call_instr), just(surrogates), [], var_gen);
  }


  StmtCompInfo assignment_stmt_opt_code(StdVar+ vars, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    type = expr_type(value, env);
    return ((terminate), just(surrogates), [], init_var_gen) if type == empty_type;

    repr = opt_repr(type);
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);

    if |vars| == 1:
      var = only(vars);
      ll_var = low_level_var(repr, var);
      code = store_result(code, surr, ll_var);
      surrs = if var != ll_var
        then update(surrogates, var, obj_expr(ll_var))
        else remove_key(surrogates, var);

    else
      assert repr == :object;
      types = tuple_field_supertypes(type, |vars|);
      ## REMOVE WHEN DONE
      assert types == (restricted_seq_elem_supertype(type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- types);
      phys_vars = (low_level_var(reprs(i), v) : v @ i <- vars);
      code = code & (set_any_var(v, at(surr, i)) : v @ i <- phys_vars);
      surrs = remove_keys(surrogates, set(vars));
      surrs = surrs & [v -> obj_expr(pv) : v @ i <~ vars, pv = phys_vars(i), v != pv];
    ;

    return (code, just(surrs), [], var_gen);
  }


  StmtCompInfo return_stmt_opt_code(Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);
    code = store_result(code, surr, result_var);
    return ((code | exit_block), nothing, [], init_var_gen);
  }


  StmtCompInfo if_stmt_opt_code(IfStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    cond_type = expr_type(stmt.cond, env);
    if cond_type == empty_type:
      return ((terminate(true)), just(surrogates), [], init_var_gen);
    elif is_subset(cond_type, type_true):
      return stmts_opt_code(stmt.body, env, init_var_gen);
    elif is_subset(cond_type, type_false):
      return if stmt.else != ()
        then stmts_opt_code(stmt.else, env, init_var_gen)
        else ((), just(surrogates), [], init_var_gen);
    ;

    cond_code, cond_surr, unused_var = opt_eval_code(stmt.cond, env, init_var_gen);
    then_env, else_env = refine_env(stmt.cond, env);

    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_var_gen
    then_code, then_surrs, then_break_surrs, var_gen = stmts_opt_code(stmt.body, then_env, init_var_gen);

    // Here I could start again from init_var_gen, but then I
    // would have to reconcile the two resulting generators
    else_code, else_surrs, else_break_surrs, var_gen = stmts_opt_code(stmt.else, else_env, var_gen);

    if then_surrs != nothing and else_surrs != nothing:
      // If both branches can fall through, we need to syncronize their lists of surrogates
      surr_vars = [v : v <- keys(env) & new_vars(stmt), v :: SurrExpr];
      surrs, then_sync_code, else_sync_code = reconcile(surr_vars, value(then_surrs), value(else_surrs));
      surrs = just(surrs);
      then_code = then_code & then_sync_code;
      else_code = else_code & else_sync_code;

    elif then_surrs != nothing:
      surrs = then_surrs;

    elif else_surrs != nothing:
      surrs = else_surrs;

    else
      surrs = nothing;
    ;

    code = (cond_code | branch(bool_value(cond_surr), then_code, else_code));
    return (code, surrs, then_break_surrs & else_break_surrs, var_gen);
  }


  StmtCompInfo loop_stmt_opt_code(Statement+ body, [EnvVar -> Type] env, VarGen var_gen) {
    body_env = loop_stmt_body_env(body, env);
    entry_code, body_code, surrs = loop_stable_code(body, [], body_env, var_gen);
    return ((entry_code | repeat(nonempty(body_code))), just(surrs), [], var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] loop_stmt_body_env(Statement+ stmts, [EnvVar -> Type] entry_env) {
      exit_env = update_env(stmts, entry_env);
      return merge_envs(entry_env, exit_env);
    }
  }


  StmtCompInfo for_stmt_opt_code(ForStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Generating the hidden loop variable
    idx_var, var_gen = next_int_var(init_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    start_val_code, start_val_surr, var_gen = opt_eval_code(stmt.start_val, env, var_gen);
    end_val_code, end_val_surr, var_gen = opt_eval_code(stmt.end_val, env, var_gen);
    entry_code = store_result(start_val_code, start_val_surr, idx_var) & end_val_code;

    // Environment the body runs in
    body_env = for_stmt_body_env(stmt, env);

    // Compiling loop body and adjusting entry code
    local_surrs = [stmt.var -> obj_expr(idx_var) if stmt.var?];
    entry_code_fixes, body_code, surrs = loop_stable_code(stmt.body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;

    // Packing loop code in a repeat instruction
    loop_over_expr = if stmt.end_val_incl
      then is_gt(idx_var, get_int_val(end_val_surr))
      else is_ge(idx_var, get_int_val(end_val_surr));
    loop_instr = repeat(nonempty((break_if(loop_over_expr)) & body_code & (increment(idx_var))));

    return ((entry_code | loop_instr), just(surrs), [], init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] for_stmt_body_env(ForStmt stmt, [EnvVar -> Type] env) {
      start_val_type = expr_type(stmt.start_val, env);
      end_val_type = expr_type(stmt.end_val, env);
      idx_var_type = loop_var_type(start_val_type, end_val_type, stmt.end_val_incl);

      loop_var_env = [stmt.var -> idx_var_type if stmt.var?];
      exit_env = update_env(stmt.body, env & loop_var_env);
      return merge_envs(env, exit_env) & loop_var_env;
    }
  }


  StmtCompInfo foreach_stmt_opt_code(ForeachStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    iter = stmt.iter;
    return match (iter)
      coll_value_iter() = opt_code(iter, stmt.body, env, var_gen),
      rel_subset_iter() = unord_coll_iter_opt_code(iter.vars, iter.src_expr, iter.args, stmt.body, env, var_gen),
      rel_var_iter()    = rel_var_iter_opt_code(iter, stmt.body, env, var_gen);

    // type CollValueIter  = coll_value_iter(vars: Maybe[StdVar]+, idx_var: StdVar?, src_expr: Expr);
    StmtCompInfo opt_code(CollValueIter iter, Statement+ body, [EnvVar -> Type] env, VarGen var_gen) {
      if iter.idx_var? or is_subset(expr_type(iter.src_expr, env), type_seq):
        return seq_iter_opt_code(iter, body, env, var_gen);
      else
        args = (nothing : v <- iter.vars);
        return unord_coll_iter_opt_code(iter.vars, iter.src_expr, args, body, env, var_gen);
      ;
    }
  }


  StmtCompInfo seq_iter_opt_code(CollValueIter iter, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Calculating input sequence type, and returning early if the type is trivial
    seq_type = expr_type(iter.src_expr, env);
    if seq_type == empty_type:
      ## just(surrogates) OR nothing?
      return ((terminate), just(surrogates), [], init_var_gen);
    elif is_subset(seq_type, empty_seq_type):
      return ((), just(surrogates), [], init_var_gen);
    ;

    // Type and representation of the elements of the input sequence
    elt_type = seq_elem_supertype(seq_type);
    fail if elt_type == empty_type;
    elt_repr = opt_repr(elt_type);

    // Evaluation of input expression
    entry_code, seq_surr, var_gen = opt_eval_code(iter.src_expr, env, init_var_gen);
    if not seq_surr :: <LocVar, StdVar>:
      seq_var, var_gen = next_obj_var(var_gen);
      entry_code = (entry_code | set_var(seq_var, seq_surr));
      seq_surr = seq_var;
    ;

    // Temporary buffer for source data
    src_array_var, var_gen = next_array_var(var_gen, elt_repr);

    vars = iter.vars;
    if |vars| == 1:
      // Simple case, no destructuring of the elements of the source sequence
      var = only(vars);
      if var != nothing:
        var = value(var);
        it_var = low_level_var(elt_repr, var);
        local_surrs = [var -> obj_expr(it_var) if var != it_var];
      else
        it_var, var_gen = next_obj_var(var_gen);
        local_surrs = [];
      ;
      body_code_setup = ();

    else
      // Elements of source sequence need to be destructured
      assert elt_repr == :object;
      vars_types = tuple_field_supertypes(elt_type, |vars|);
      ## REMOVE WHEN DONE
      assert vars_types == (restricted_seq_elem_supertype(elt_type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- vars_types);
      vars = [i -> value(v) : v @ i <~ vars, v != nothing];
      phys_vars = [i -> low_level_var(reprs(i), v) : i, v <- vars];
      local_surrs = [v -> obj_expr(pv) : i, v <- vars, pv = phys_vars(i), v != pv];
      it_var, var_gen = next_obj_var(var_gen);
      body_code_setup = (set_any_var(v, at(it_var, i)) : i, v <- sort_bin_rel_by_key(phys_vars, $a));
    ;

    // Index variables
    count_var, var_gen = next_int32_var(var_gen);
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    local_surrs = local_surrs & [iter.idx_var -> int_obj(hidden_idx_var)] if iter.idx_var?;

    // Environment the body runs in
    body_env = foreach_stmt_body_env(iter, body, env);

    // Compiling loop body and adjusting entry code
    entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;
    body_code = body_code_setup & body_code;

    // Mapping source to destination arrays
    read_len_instr = set_ivar32(count_var, get_size(seq_surr));
    map_instr = foreach(
      seq:        seq_surr,
      src_array:  src_array_var,
      count_var:  count_var,
      idx_var:    hidden_idx_var,
      it_var:     it_var,
      body:       body_code
    );

    return ((entry_code | read_len_instr, map_instr), just(surrs), [], init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] foreach_stmt_body_env(CollValueIter iter, Statement+ body, [EnvVar -> Type] env) {
      elt_type = seq_elem_supertype(expr_type(iter.src_expr, env));
      loop_vars_env = partial_asgnm_env_updates(iter.vars, elt_type);

      loop_vars_env = loop_vars_env & [iter.idx_var -> type_nat] if iter.idx_var?;
      exit_env = update_env(body, env & loop_vars_env);
      return merge_envs(env, exit_env) & loop_vars_env;
    }
  }


  StmtCompInfo unord_coll_iter_opt_code(Maybe[StdVar]+ vars, Expr src_expr, Maybe[Expr]+ args, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    args_surrs : Maybe[ObjExpr]*;

    // Calculating input sequence type, and returning early if the type is trivial
    coll_type = expr_type(src_expr, env);
    if coll_type == empty_type:
      ## just(surrogates) OR nothing?
      return ((terminate), just(surrogates), [], init_var_gen);
    elif is_subset(coll_type, empty_rel_type):
      return ((), just(surrogates), [], init_var_gen);
    ;

    // Evaluation of input expression
    entry_code, coll_surr, var_gen = opt_eval_code(src_expr, env, init_var_gen);
    ## IS THIS NEEDED AT ALL? WHY WAS IT HERE IN THE FIRST PLACE?
    if not coll_surr :: <LocVar, StdVar>:
      coll_var, var_gen = next_obj_var(var_gen);
      entry_code = (entry_code | set_var(coll_var, coll_surr));
      coll_surr = coll_var;
    ;

    // Evaluation of arguments
    args_eval_code, args_surrs, var_gen = sparse_opt_eval_code(args, env, var_gen);

    // Mapping the index of each iterator variable to that of the corresponding relation argument
    var_arg_idx_map = indexes(args, $ == nothing);

    // Type and representation of the arguments of the source set/relation
    local_surrs = [];
    iter_vars_setup_code = ();

    if |args| == 1:
      fail if |vars| != 1;
      elt_type = nonempty_type(set_elem_supertype(coll_type));
      elt_repr = opt_repr(elt_type);
      it_var, var_gen = next_set_it_var(var_gen);
      var = only(vars);
      loop_vars_env = [value(var) -> elt_type if var != nothing];
      if var != nothing:
        var = value(var);
        elt_var = low_level_var(elt_repr, var);
        local_surrs = [var -> obj_expr(elt_var) if var != elt_var];
        iter_vars_setup_code = (set_any_var(elt_var, get_curr_obj(it_var)));
      ;

    elif |args| == 2:
      args_types = (nonempty_type(t) : t <- bin_rel_args_supertypes(coll_type));
      args_reprs = (opt_repr(t) : t <- args_types);
      it_var, var_gen = next_bin_rel_it_var(var_gen);
      loop_vars_env = [value(v) -> args_types(i) : v @ i <~ vars, v != nothing];
      for v @ i <- vars:
        if v != nothing:
          var = value(v);
          arg_idx = var_arg_idx_map(i);
          low_level_var = low_level_var(args_reprs(arg_idx), var);
          local_surrs = local_surrs & [var -> obj_expr(low_level_var) if var != low_level_var];
          fail if not arg_idx :: <0..1>;
          instr = set_any_var(low_level_var, get_curr_arg(it_var, arg_idx));
          iter_vars_setup_code = (iter_vars_setup_code | instr);
        ;
      ;

    else
      fail if |args| != 3;
      args_types = (nonempty_type(t) : t <- tern_rel_args_supertypes(coll_type));
      args_reprs = (opt_repr(t) : t <- args_types);
      it_var, var_gen = next_tern_rel_it_var(var_gen);
      loop_vars_env = [value(v) -> args_types(i) : v @ i <~ vars, v != nothing];
      for v @ i <- vars:
        if v != nothing:
          var = value(v);
          arg_idx = var_arg_idx_map(i);
          low_level_var = low_level_var(args_reprs(arg_idx), var);
          local_surrs = local_surrs & [var -> obj_expr(low_level_var) if var != low_level_var];
          fail if not arg_idx :: <0..2>;
          instr = set_any_var(low_level_var, get_curr_arg(it_var, arg_idx));
          iter_vars_setup_code = (iter_vars_setup_code | instr);
        ;
      ;
    ;

    // Environment the body runs in
    exit_env = update_env(body, env & loop_vars_env);
    body_env = merge_envs(env, exit_env) & loop_vars_env;

    // Compiling loop body and adjusting entry code
    entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;
    // body_code = body_code_setup & body_code;

    code = entry_code & args_eval_code & (
      get_any_rel_iter(it_var, coll_surr, args_surrs),
      repeat((
        break_if(is_out_of_range(it_var))
        ) & iter_vars_setup_code & body_code & (
        move_forward(it_var)
      ))
    );

    return (code, just(surrs), [], init_var_gen);
  }


  // type RelVarIter = rel_var_iter(vars: Maybe[StdVar]+, rel_var: AnyRelVar, args: Maybe[Expr]+);
  StmtCompInfo rel_var_iter_opt_code(RelVarIter iter, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    table_args = iter.args;
    set_args = values(table_args);

    bound_args_idxs = (i : a @ i <- table_args, a != nothing);
    free_args_idxs = (i : a @ i <- table_args, a == nothing);
    arg_idx_bound_arg_idx = [i -> j : i @ j <~ bound_args_idxs];

    entry_code, args_aliases, var_gen = opt_eval_code(set_args, env, init_var_gen);

    surr_vars, var_gen = next_int32_vars(var_gen, |set_args|);
    shadow_surr_vars, var_gen = next_int32_vars(var_gen, [i : v @ i <~ iter.vars, v != nothing]);
    it_var, var_gen = next_table_it_var(var_gen, |table_args|, symmetric(iter.rel_var));

    surr_args = (apply(a, surr_vars(arg_idx_bound_arg_idx(i))) : a @ i <- table_args);


## REMOVE WHEN TESTED
old_filtered_idxs = idxs_into_filtered_seq((a != nothing : a <- table_args));
old_unfiltered_idxs = (i : a @ i <- table_args, a != nothing);
old_blank_idxs = (i : a @ i <- table_args, a == nothing);
old_surr_args = (apply(mi, surr_vars($)) : mi <- old_filtered_idxs);
assert bound_args_idxs == old_unfiltered_idxs;
assert free_args_idxs == old_blank_idxs;
assert surr_args == old_surr_args;


    symmetric = symmetric(iter.rel_var);

    // Selecting the candidate tables among those the logical relation is partitioned into
    args_types = (apply(a, expr_type($, env)) : a <- iter.args);
    return ((terminate(true)), just(surrogates), [], init_var_gen) if not args_types :: Maybe[NeType]+;
    candidate_tables = overlapping_tables(iter.rel_var, args_types);

    // Iterating through all candidate tables
    code = ();
    surrs = surrogates;
    for tv <- isort(candidate_tables):
      assert (a <~ surr_args : a == nothing);

      vars_setup_code = join(({
        shadow_surr_var = shadow_surr_vars(i);
        store_id = table_col_store_id(tv, free_args_idxs(i));
        store_type = value_store_type(rel_auto_type(iter.rel_var), unqualified(store_id));
        store_id = substitute(store_id);
        return (
          set_ivar32(shadow_surr_var, get_unknown_arg(it_var, i)),
          surr_to_decoded_value(value(v), store_id, store_type, shadow_surr_var)
        );
      } : v @ i <- iter.vars, v != nothing));

      // Environment the body runs in
      sgn = table_signature(tv);
      loop_vars = [value(v) -> sgn(free_args_idxs(i)) : v @ i <~ iter.vars, v != nothing];
      exit_env = update_env(body, env & loop_vars);
      body_env = merge_envs(env, exit_env) & loop_vars;

      ## IGNORING LOW LEVEL REPRESENTATION FOR NOW. THIS OPTIMIZATION WILL BE PART OF RELEASE 0.4
      // args_reprs = (opt_repr(t) : t <- args_types);
      // low_level_vars = [
      //   var -> low_level_var(args_reprs(i), var)
      //   : v @ i <~ iter.vars, v != nothing, var = value(v)
      // ];
      // local_surrs = [v -> obj_expr(lv) : v, lv <- low_level_vars];
      local_surrs = [];

      let surrogates = surrs:
        entry_code_fixes, body_code, surrs = loop_stable_code(body, local_surrs, body_env, var_gen);
      ;

      if body_code != ():
        entry_code = entry_code & entry_code_fixes;

        loop_code = (break_if(is_out_of_range(it_var))) & vars_setup_code & body_code & (move_forward(it_var));
        table_code = (
          get_table_iter(it_var, substitute(tv), nonempty(surr_args)),
          repeat(nonempty(loop_code))
        );

        for e @ i <- reverse(args_aliases):
assert |args_types| == |table_args|;
assert |args_aliases| == |set_args|;
assert |bound_args_idxs| == |set_args|;
assert not (j <~ bound_args_idxs : table_args(j) == nothing or args_types(j) == nothing);

          idx = rat(bound_args_idxs, i);
          arg_type = value_unsafe(args_types(idx));
          store_id = table_col_store_id(tv, idx);
          store_type = value_store_type(rel_auto_type(iter.rel_var), unqualified(store_id));
          store_id = substitute(store_id);
          surr_var = rat(surr_vars, i);
          table_code = opt_do_if(
            value_store_guard(store_type, e, arg_type),
            ( set_ivar32(surr_var, value_to_surr(store_id, value_store_encoded_expr(store_type, e))),
              do_if_not(is_eq(surr_var, -1), table_code)
            )
          );
        ;

        code = code & table_code;
      ;
    ;

    return (entry_code & code, just(surrs), [], init_var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  ([SurrExpr -> ObjExpr], Instr*, Instr*) reconcile([SurrExpr] surr_vars, [SurrExpr -> ObjExpr] surrs1, [SurrExpr -> ObjExpr] surrs2) {
    // Reconciling the surrogates
    sync_vars = [v : v <- surr_vars, lookup(surrs1, v, v) == lookup(surrs2, v, v)];
    unsync_vars = surr_vars - sync_vars;
    fail if not unsync_vars :: [StdVar];
    surrs = [v -> surrs1(v, !!) : v <- sync_vars, surrs1(v, *)];

    // Syncronization code
    sync_code_1 = ();
    sync_code_2 = ();
    for v <- isort(unsync_vars):
      sync_code_1 = (sync_code_1 | set_var(v, surrs1(v, !!))) if surrs1(v, *);
      sync_code_2 = (sync_code_2 | set_var(v, surrs2(v, !!))) if surrs2(v, *);
    ;

    return (surrs, sync_code_1, sync_code_2);
  }


  // The list of surrogates we return is the one we have:
  //   1) Just before the loop starts
  //   2) When the loop breaks
  //   3) After any iteraction of the loop terminates

  // That means that if the loop body never breaks or terminates we'll just
  // return the entry environment.

  // Since we can only remove surrogates from the initial list, then the
  // returned one is always a subset of it, and we can start with the initial
  // entry list and keep removing surrogates from it until everything matches

  (Instr*, Instr*, [SurrExpr -> ObjExpr])
  loop_stable_code(Statement+ stmts, [SurrExpr -> ObjExpr] local_surrs, [EnvVar -> Type] env, VarGen var_gen) {
    ## MAYBE HERE I COULD EXPLICITLY PASS A LIST OF VARIABLES THAT ARE
    ## EXPECTED TO SURVIVE THE LOOP INSTEAD OF TRYING TO FIGURE THAT OUT SOMEHOW
    surr_vars = [v : v, unused_var <- env, v :: SurrExpr, not local_surrs(v, *)];
    entry_surrs = surrogates;
    entry_code = ();

    loop
      body_surrs = entry_surrs & local_surrs;
      let surrogates = body_surrs, exp_break_surrs = just(body_surrs):
        body_code, exit_surrs, break_surrs, unused_var = stmts_opt_code(stmts, env, var_gen);
      ;

      // Finding out what variables get out of sync after one iteraction of the loop
      out_of_sync_vars = [v : v, e <- entry_surrs, is_out_of_sync(v, e, exit_surrs, break_surrs)];

      // If no variable is out of sync, then we're done
      if out_of_sync_vars == []:
        return (entry_code, body_code, entry_surrs) if exit_surrs == nothing;
        exit_surrs = value(exit_surrs);
        for v <- isort(surr_vars):
          assert not entry_surrs(v, *) or (exit_surrs(v, *) and entry_surrs(v, !!) == exit_surrs(v, !!));
          if not entry_surrs(v, *) and exit_surrs(v, *):
            fail if not v :: StdVar;
            body_code = (body_code | set_var(v, exit_surrs(v, !!)));
          ;
        ;
        return (entry_code, body_code, entry_surrs);
      ;

      // Removing the unsyncronized variables from the initial list of surrogates
      // by physically storing them into their corresponding variables
      for v <- isort(out_of_sync_vars):
        fail if not v :: StdVar;
        entry_code = (entry_code | set_var(v, entry_surrs(v, !!)));
      ;
      entry_surrs = remove_keys(entry_surrs, out_of_sync_vars);
    ;


    Bool is_out_of_sync(SurrExpr var, ObjExpr entry_surr, Maybe[[SurrExpr -> ObjExpr]] maybe_exit_surrs, [[SurrExpr -> ObjExpr]] break_surrs) {
      if maybe_exit_surrs != nothing:
        exit_surrs = value(maybe_exit_surrs);
        return true if not exit_surrs(var, *) or exit_surrs(var, !!) != entry_surr;
      ;
      return (surrs <- break_surrs : not surrs(var, *) or surrs(var, !!) != entry_surr);
    }
  }
}
