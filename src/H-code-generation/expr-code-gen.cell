implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         cluster           : Expr+,
         types             : Type+,
         environments      : [EnvVar -> Type]+,
         surrogates        : [SurrExpr -> ObjExpr],
         expr_id           : Nat,
         options           : CompOptions {

  Type subexpr_type(Expr) =
    expr_ref(id?) = types(id);

  Expr expand_subexpr(Expr) =
    expr_ref(id?) = cluster(id);

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, VarGen) opt_eval_info(Expr expr, AnyLocVar res_var, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    eval_code = store_result(eval_code, surr_expr, res_var);
    return (eval_code, var_gen);
  }


  (Instr*, ObjExpr*, VarGen) opt_eval_info((), VarGen var_gen) = ((), (), var_gen);

  (Instr*, ObjExpr+, VarGen) opt_eval_info(Expr+ exprs, VarGen init_var_gen) {
    var_gen = init_var_gen;
    code = ();
    surrs = ();
    for e <- exprs {
      expr_code, surr, var_gen = opt_eval_info(e, var_gen);
      code = code & expr_code;
      surrs = (surrs | surr);
    }
    return (code, nonempty(surrs), var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, ObjExpr, VarGen) opt_eval_info(<undefined>, VarGen var_gen) {
    return ((terminate), :invalid_var, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(LeafObj expr, VarGen var_gen) {
    ll_expr = match (expr)
      object(<+>)       = expr,
      object(<*..*> n?) = int_obj(n);
    return ((), ll_expr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(FloatLit expr, VarGen var_gen) {
    return ((), float_obj(expr), var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(Var var, VarGen var_gen) {
    return ((), eval_var(var, var_subst_map, surrogates), var_gen);
  }


  // output_is_def(var: LocAutoVar, output: Symbol)
  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsDefExpr expr, VarGen var_gen) {
    var = qual_signal_var(expr.var, signal_var(expr.output));
    return ((), bool_obj(is_not_null(var)), var_gen);
  }


  // output_is_set(var: LocAutoVar, output: Symbol)
  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsSetExpr expr, VarGen var_gen) {
    var = qual_signal_var(expr.var, signal_var(expr.output));
    return ((do_if(is_null(var), terminate)), bool_obj(is_not_blank(var)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(ExprRef expr, VarGen var_gen) {
    id = untag(expr);
    return opt_eval_info(cluster(id), var_gen, expr_id = id);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(RecExpr expr, VarGen var_gen) =
    seq_expr(ses?)      |
    tuple_expr(ses?)    = seq_expr_opt_eval_info(ses, var_gen),
    seq_tail_expr()     = seq_tail_expr_opt_eval_info(expr.seq, expr.tail, var_gen),
    set_expr(ses?)      = set_expr_opt_eval_info(ses, var_gen),
    map_expr(es?)       = map_expr_opt_eval_info(es, var_gen),
    bin_rel_expr(es?)   = bin_rel_expr_opt_eval_info(es, var_gen),
    tern_rel_expr(es?)  = tern_rel_expr_opt_eval_info(es, var_gen),
    tag_obj_expr()      = tag_obj_expr_opt_eval_info(expr, var_gen),
    fn_call()           = fn_call_opt_eval_info(expr, var_gen),
    cls_call()          = cls_call_opt_eval_info(expr.name, expr.args, var_gen),
    builtin_call()      = builtin_call_opt_eval_info(expr, var_gen),
    size_expr()         = size_expr_opt_eval_info(expr.coll, var_gen),
    rel_var_size_expr() = rel_var_size_expr_opt_eval_info(expr.rel_var, expr.args, var_gen),
    unary_pseudo_call() = unary_pseudo_call_opt_eval_info(expr.target, expr.arg, var_gen),
    rel_memb_test()     = rel_memb_test_opt_eval_info(expr.rel, expr.args, var_gen),
    rel_lookup()        = rel_lookup_opt_eval_info(expr, var_gen),
    relvar_memb_test()  = relvar_memb_test_opt_eval_info(expr.rel_var, expr.args, var_gen),
    relvar_lookup()     = if is_columnar_relvar(expr.rel_var) then
                            columnar_relvar_lookup_opt_eval_info(expr.rel_var, expr.args, var_gen)
                          else if is_ternary_slave_column(expr.rel_var) then
                            ternary_slave_column_lookup_opt_eval_info(expr.rel_var, expr.args, var_gen)
                          else
                            relvar_lookup_opt_eval_info(expr.rel_var, expr.args, var_gen),
    and_expr()          = and_expr_opt_eval_info(expr.left, expr.right, var_gen),
    or_expr()           = or_expr_opt_eval_info(expr.left, expr.right, var_gen),
    not_expr(e?)        = not_expr_opt_eval_info(e, var_gen),
    eq()                = eq_expr_opt_eval_info(expr.left, expr.right, var_gen),
    membership()        = membership_opt_eval_info(expr.obj, expr.type, var_gen),
    accessor()          = accessor_opt_eval_info(expr.expr, expr.field, var_gen),
    accessor_test()     = accessor_test_opt_eval_info(expr.expr, expr.field, var_gen),
    aggr_fn_call()      = aggr_fn_call_opt_eval_info(expr, var_gen),
    auto_method_call()  = auto_method_call_opt_eval_info(expr, var_gen),
    db_method_call()    = db_method_call_opt_eval_info(expr, var_gen),
    if_expr()           = if_expr_opt_eval_info(expr, var_gen),
    match_expr()        = match_expr_opt_eval_info(expr, var_gen),
    do_expr()           = do_expr_opt_eval_code(expr, environments(expr_id), var_gen),
    ex_qual()           = ex_qual_opt_eval_info(expr.source, expr.cond, var_gen),
    set_comp()          = set_comp_opt_eval_info(expr.expr, expr.source, var_gen),
    map_comp()          = map_comp_opt_eval_info(expr, var_gen),
    bin_rel_comp()      = bin_rel_comp_opt_eval_info(expr, var_gen),
    tern_rel_comp()     = tern_rel_comp_opt_eval_info(expr, var_gen),
    seq_comp()          = seq_comp_opt_eval_info(expr, var_gen),
    range_comp()        = range_comp_opt_eval_info(expr, var_gen);


  (Instr*, ObjExpr, VarGen) rel_var_size_expr_opt_eval_info(AnyRelVar rel_var, Maybe[Expr]+ args, VarGen init_var_gen) {
    ## THIS SHOULD BE USING int64, NOT int32
    bound_args_idxs = (i : a @ i <- args, a != nothing);
    free_args_idxs = (i : a @ i <- args, a == nothing);
    arg_idx_bound_arg_idx = [i -> j : i @ j <- bound_args_idxs];

    set_args = (value(a) : a <- args, a != nothing);
    eval_code, args_aliases, var_gen = opt_eval_info(set_args, init_var_gen);

    res_var, ret_var_gen = next_int32_var(init_var_gen);
    surr_vars, var_gen = next_int32_vars(ret_var_gen, |set_args|);
    // it_var, var_gen = next_table_it_var(var_gen, |args|, symmetric(rel_var));

    surr_args = (apply(a, surr_vars(arg_idx_bound_arg_idx(i))) : a @ i <- args);

    // Selecting the candidate tables among those the logical relation is partitioned into
    args_types = (apply(a, subexpr_type) : a <- args);
    return ((), :invalid_var, init_var_gen) if not args_types :: Maybe[NeType]+;
    candidate_tables = overlapping_tables(rel_var, args_types);

    symmetric = symmetric(rel_var);

    code = (eval_code | set_ivar32(res_var, 0));
    for t @ i <- isort(candidate_tables) {
      count_expr = get_count(substitute(t), table_info(t), surr_args, symmetric);
      count_expr = add32(res_var, count_expr) if i > 0;
      table_code = (set_ivar32(res_var, count_expr));
      for e @ j <- reverse(args_aliases) {
        idx = rat(bound_args_idxs, j);
        arg_type = value_unsafe(args_types(idx));
        store_id = table_col_store_id(t, idx);
        store_type = value_store_type(rel_auto_type(rel_var), unqualified(store_id));
        store_id = substitute(store_id);
        surr_var = rat(surr_vars, j);
        assert |candidate_tables| > 1 or value_store_guard(store_type, e, arg_type) == true;
        table_code = opt_do_if(
          value_store_guard(store_type, e, arg_type),
          ( set_ivar32(surr_var, value_to_surr(store_id, store_type, value_store_encoded_expr(store_type, e))),
            do_if_not(are_eq(int_obj(surr_var), int_obj(-1)), table_code)
          )
        );
      }
      code = code & table_code;
    }

    return (code, int_obj(res_var), ret_var_gen);
  }


  // relvar_memb_test(rel_var: AnyRelVar, args: Maybe[Expr]+);
  (Instr*, ObjExpr, VarGen) relvar_memb_test_opt_eval_info(AnyRelVar rel_var, Maybe[Expr]+ args, VarGen init_var_gen) {
    bound_args = (value(a) : a <- args, a != nothing);
    bound_args_idxs = (i : a @ i <- args, a != nothing);
    arg_idx_bound_arg_idx = [i -> j : i @ j <- bound_args_idxs];

    eval_code, args_aliases, var_gen = opt_eval_info(bound_args, init_var_gen);

    res_var, ret_var_gen = next_bool_var(init_var_gen);
    surr_vars, var_gen = next_int32_vars(ret_var_gen, |bound_args|);
    assoc_surr_var, var_gen = next_int32_var(var_gen);
    unknown_arg_surr_var, var_gen = next_int32_var(var_gen);

    surr_args = (apply(a, surr_vars(arg_idx_bound_arg_idx(i))) : a @ i <- args);

    symmetric = symmetric(rel_var);

    // Selecting the candidate tables among those the logical relation is partitioned into
    args_types = (apply(a, subexpr_type) : a <- args);
    return ((), :invalid_var, init_var_gen) if not args_types :: Maybe[NeType]+;
    candidate_tables = overlapping_tables(rel_var, args_types);

    code = (eval_code | set_bvar(res_var, false));
    for tv @ i <- isort(candidate_tables) {
      subst_table_var = substitute(tv);
      target_table_info = table_info(tv);
      if is_ternary_slave_column(rel_var) {
        assert surr_args(2) == nothing;
        master_table = master_table(tv);
        master_table_info = cast_master_bin_table(table_info(master_table));
        master_table = substitute(master_table);
        arg_0 = surr_args(0);
        arg_1 = surr_args(1);
        master_args = (arg_0, arg_1);

        slave_table_contains_expr = table_contains(subst_table_var, target_table_info, (just(assoc_surr_var), nothing), false);

        if arg_0 != nothing and arg_1 != nothing {
          table_code = (
            branch(
              table_contains(master_table, table_info(master_table), master_args, symmetric),
              ( set_ivar32(assoc_surr_var, get_assoc_surr(master_table, master_table_info, (value(arg_0), value(arg_1)))),
                set_bvar(res_var, slave_table_contains_expr)
              ),
              (set_bvar(res_var, false))
            )
          );
        }
        else {
          iter = get_table_foreach_iter(master_table, master_table_info, master_args, (nothing, nothing), assoc_surr_var);
          body_instr = do_if(slave_table_contains_expr, (set_bvar(res_var, true), break_loop));
          table_code = (set_bvar(res_var, false), foreach(iter, (body_instr)));
        }
      }
      else
        table_code = (set_bvar(res_var, table_contains(subst_table_var, target_table_info, surr_args, symmetric)));

      for e @ j <- reverse(args_aliases) {
        idx = rat(bound_args_idxs, j);
        arg_type = value_unsafe(args_types(idx));
        store_id = table_col_store_id(tv, idx);
        store_type = value_store_type(rel_auto_type(rel_var), unqualified(store_id));
        store_id = substitute(store_id);
        surr_var = rat(surr_vars, j);
        table_code = opt_do_if(
          value_store_guard(store_type, e, arg_type),
          ( set_ivar32(surr_var, value_to_surr(store_id, store_type, value_store_encoded_expr(store_type, e))),
            do_if_not(are_eq(int_obj(surr_var), int_obj(-1)), table_code)
          )
        );
      }

      table_code = (do_if_not(res_var, table_code)) if i != 0;
      code = code & table_code;
    }

    return (code, bool_obj(res_var), ret_var_gen);
  }


  // relvar_lookup(rel_var: AnyRelVar, args: Maybe[Expr]+)
  (Instr*, ObjExpr, VarGen) relvar_lookup_opt_eval_info(AnyRelVar rel_var, Maybe[Expr]+ maybe_args, VarGen init_var_gen) {
    ## IMPLEMENT IMPLEMENT IMPLEMENT
    assert |maybe_args| > 1; // Excluding rel_var(!)

    args = [i -> value(a) : a @ i <- maybe_args, a != nothing];
    target_idx = first_unused_idx(args);
    arity = nz_nat(|args| + 1);
    args_idxs = ord_idxs(args);
    ord_args = values_ord_by_idx(args);

    // The result is garanteed to be unique if there's a key that does
    // not contain the argument that is being looked up
    is_unique = (k <- relvar_keys(rel_var) : not k(target_idx));

    res_surr_var, var_gen = next_int32_var(init_var_gen);

    res_repr = opt_repr(types(expr_id));
    res_var, ret_var_gen = next_var(res_repr, init_var_gen);

    // Evaluation of arguments
    args_eval_code, args_aliases, var_gen = opt_eval_info(ord_args, ret_var_gen);

    def_surr_vars, var_gen = next_int32_vars(var_gen, |args|);
    def_surr_vars_map = [i -> def_surr_vars(j) : i @ j <- args_idxs];

    // Selecting the candidate tables among those the logical relation is partitioned into
    args_types = [i -> subexpr_type(e) : i e <- args];
    return ((), :invalid_var, init_var_gen) if not args_types :: [Nat -> NeType];
    candidate_tables = overlapping_tables(rel_var, maybe_seq(args_types, arity));

    // Iterating through all the candidate tables
    lookup_code = join(({
      surr_vars = def_surr_vars;
      surr_vars_map = def_surr_vars_map;
      if maybe_args :: (Just[ExprRef], Nothing) {
        arg1 = expand_subexpr(value(maybe_args(0)));
        if arg1 :: StdVar {
          surr_var = shadow_surr_var(arg1);
          surr_vars = (surr_var);
          surr_vars_map = [0 -> surr_var];
        }
      }

      res_store_id = table_col_store_id(tv, target_idx);
      res_store_type = value_store_type(rel_auto_type(rel_var), unqualified(res_store_id));
      res_store_id = substitute(res_store_id);
      code = (
        set_ivar32(res_surr_var, table_lookup(substitute(tv), cast_any_surr_table(table_info(tv)), maybe_seq(surr_vars_map, arity), symmetric(rel_var))),
        do_if_not(is_eq(res_surr_var, -1), (
          surr_to_decoded_value(res_var, res_store_id, res_store_type, res_surr_var),
          exit_block
        ))
      );

      for ri < |args_aliases| {
        i = |args_aliases| - ri - 1;
        arg_alias = args_aliases(i);

        arg_type = subexpr_type(ord_args(i));

        store_id = table_col_store_id(tv, args_idxs(i));
        store_type = value_store_type(rel_auto_type(rel_var), unqualified(store_id));
        store_id = substitute(store_id);
        surr_var = surr_vars(i);

        code = opt_do_if(
          value_store_guard(store_type, arg_alias, arg_type),
          ( set_ivar32(surr_var, value_to_surr(store_id, store_type, value_store_encoded_expr(store_type, arg_alias))),
            do_if_not(is_eq(surr_var, -1), code)
          )
        );
      }

      return code;
    } : tv <- isort(candidate_tables)));

    return ((args_eval_code | execute_block((lookup_code | terminate))), obj_expr(res_var), ret_var_gen);
  }


  // relvar_lookup(rel_var: AnyRelVar, args: Maybe[Expr]+)
  (Instr*, ObjExpr, VarGen) columnar_relvar_lookup_opt_eval_info(AnyRelVar rel_var, Maybe[Expr]+ maybe_args, VarGen init_var_gen) {
    fail if not maybe_args :: (Just[ExprRef], Nothing);

    arg = value(maybe_args(0));
    arg_type = subexpr_type(arg);
    return ((), :invalid_var, init_var_gen) if arg_type == empty_type;

    res_type = types(expr_id);
    res_repr = opt_repr(res_type);

    res_var, ret_var_gen = next_var(res_repr, init_var_gen);

    // Evaluation of arguments
    arg_eval_code, arg_alias, var_gen = opt_eval_info(arg, ret_var_gen);

    // Argument surrogate
    exp_arg = expand_subexpr(arg);
    if exp_arg :: StdVar
      arg_surr_var = shadow_surr_var(exp_arg);
    else
      arg_surr_var, var_gen = next_int32_var(var_gen);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = overlapping_tables(rel_var, (just(arg_type), nothing));

    ## TEST IT WITH POLYMORPHIC TABLES AND WITH CLOSURES

    if |candidate_tables| == 1 {
      table = only(candidate_tables);
      subst_table = substitute(table);

      arg_store_id = table_col_store_id(table, 0);
      arg_store_type = value_store_type(rel_auto_type(rel_var), unqualified(arg_store_id));
      arg_store_id = substitute(arg_store_id);

      code = (
        arg_eval_code |
        set_ivar32(arg_surr_var, value_to_surr(arg_store_id, arg_store_type, value_store_encoded_expr(arg_store_type, arg_alias))),
        check(neg(is_eq(arg_surr_var, -1))),
        set_any_var(res_var, column_lookup(subst_table, table_info(table), arg_surr_var))
      );

      return (code, obj_expr(res_var), ret_var_gen);
    }
    else {
      cases = [{
        subst_tv = substitute(tv);

        arg_store_id = table_col_store_id(tv, 0);
        arg_store_type = value_store_type(rel_auto_type(rel_var), unqualified(arg_store_id));
        arg_store_id = substitute(arg_store_id);

        sign = table_signature(tv);
        enc_expr = value_store_encoded_expr(arg_store_type, arg_alias);

        code = (
          set_ivar32(arg_surr_var, value_to_surr(arg_store_id, arg_store_type, enc_expr)),
          check(neg(is_eq(arg_surr_var, -1))),
          set_any_var(res_var, column_lookup(subst_tv, table_info(tv), arg_surr_var))
        );

        return ((sign(0)), code);
      } : tv <- candidate_tables];

      code = arg_eval_code & dynamic_dispatch_code((arg_alias), cases);
      return (code, obj_expr(res_var), ret_var_gen);
    }
  }


  // relvar_lookup(rel_var: AnyRelVar, args: Maybe[Expr]+)
  (Instr*, ObjExpr, VarGen) ternary_slave_column_lookup_opt_eval_info(AnyRelVar rel_var, Maybe[Expr]+ maybe_args, VarGen init_var_gen) {
    fail if not maybe_args :: (Just[ExprRef], Just[ExprRef], Nothing);

    arg_0 = value(maybe_args(0));
    arg_1 = value(maybe_args(1));
    arg_0_type = subexpr_type(arg_0);
    arg_1_type = subexpr_type(arg_1);
    return ((), :invalid_var, init_var_gen) if arg_0_type == empty_type or arg_1_type == empty_type;

    res_type = types(expr_id);
    res_repr = opt_repr(res_type);

    res_var, ret_var_gen = next_var(res_repr, init_var_gen);

    // Evaluation of arguments
    args_eval_code, args_aliases, var_gen = opt_eval_info((arg_0, arg_1), ret_var_gen);

    // Argument surrogates
    exp_arg_0 = expand_subexpr(arg_0);
    if exp_arg_0 :: StdVar
      arg_0_surr_var = shadow_surr_var(exp_arg_0);
    else
      arg_0_surr_var, var_gen = next_int32_var(var_gen);

    exp_arg_1 = expand_subexpr(arg_1);
    if exp_arg_1 :: StdVar
      arg_1_surr_var = shadow_surr_var(exp_arg_1);
    else
      arg_1_surr_var, var_gen = next_int32_var(var_gen);

    assoc_surr_var, var_gen = next_int32_var(var_gen);

    // Selecting the candidate tables among those the logical relation is partitioned into
    candidate_tables = overlapping_tables(rel_var, (just(arg_0_type), just(arg_1_type), nothing));

    cases = [{
      master_table = master_table(tv);
      master_table_info = cast_master_bin_table(table_info(master_table));

      arg_0_store_id = table_col_store_id(tv, 0);
      arg_0_store_type = value_store_type(rel_auto_type(rel_var), unqualified(arg_0_store_id));
      arg_0_store_id = substitute(arg_0_store_id);

      arg_1_store_id = table_col_store_id(tv, 1);
      arg_1_store_type = value_store_type(rel_auto_type(rel_var), unqualified(arg_1_store_id));
      arg_1_store_id = substitute(arg_1_store_id);

      sign = table_signature(tv);

      enc_expr_0 = value_store_encoded_expr(arg_0_store_type, args_aliases(0));
      enc_expr_1 = value_store_encoded_expr(arg_1_store_type, args_aliases(1));

      code = (
        set_ivar32(arg_0_surr_var, value_to_surr(arg_0_store_id, arg_0_store_type, enc_expr_0)),
        check(neg(is_eq(arg_0_surr_var, -1))),
        set_ivar32(arg_1_surr_var, value_to_surr(arg_1_store_id, arg_1_store_type, enc_expr_1)),
        check(neg(is_eq(arg_1_surr_var, -1))),
        set_ivar32(assoc_surr_var, get_assoc_surr(substitute(master_table), master_table_info, (arg_0_surr_var, arg_1_surr_var))),
        check(neg(is_eq(assoc_surr_var, -1))),
        set_any_var(res_var, column_lookup(substitute(tv), table_info(tv), assoc_surr_var))
      );

      return ((sign(0), sign(1)), code);
    } : tv <- candidate_tables];

    ## TEST IT WITH POLYMORPHIC TABLES AND WITH CLOSURES

    if |cases| == 1
      _, lookup_code = only(cases);
    else
      lookup_code = dynamic_dispatch_code(args_aliases, cases);

    return (args_eval_code & lookup_code, obj_expr(res_var), ret_var_gen);
  }


  // type FnCallExpr = fn_call(fn_id: FnFamilyId, args: Expr*, ...);
  // db_method_call(var: AnyDBVar?, name: MethodSymbol, args: Expr*)
  (Instr*, ObjExpr, VarGen) db_method_call_opt_eval_info(DBMethodCall expr, VarGen init_var_gen) {
    // Actual arguments' types
    args_types = (subexpr_type(a) : a <- expr.args);

    // Low-level signature of the target method
    rel_auto_id = if expr.var? then var_type(expr.var) else this_db_symbol;
    method_id, low_level_sign = low_level_sign(rel_auto_id, expr.name, args_types);

    // Result variable and returned variable generator
    res_var, ret_var_gen = next_var(low_level_sign.ret_value, init_var_gen);

    // Evaluation of the arguments
    args_eval_code, args_surrs, _ = opt_eval_info(expr.args, ret_var_gen);

    // Low-level actual arguments
    low_level_args = (low_level_expr(low_level_sign.args(i), s) : s @ i <- args_surrs);

    // Evaluation code for the call only
    method_call_instr = invoke_db_method(
      res_var:    res_var,
      db_var:     expr.var if expr.var?,
      type:       if expr.var? then var_type(expr.var) else this_db_symbol,
      method_id:  method_id,
      args:       low_level_args
    );

    return ((args_eval_code | method_call_instr), obj_expr(res_var), ret_var_gen);
  }


  // aggr_fn_call(fn_id: PlainAggrFnId, expr: Expr, clause: RelVarClause, cond: Expr?, extra_args: Expr*);
  (Instr*, ObjExpr, VarGen) aggr_fn_call_opt_eval_info(AggrFnCallExpr expr, VarGen init_var_gen) {
    aggr_fns = aggr_functs(expr.fn_id, |expr.extra_args|);
    elt_type = subexpr_type(expr.expr);
    aggr_fn = only([f : f <- aggr_fns, is_subset(elt_type, f.elt_type)]);

    res_var, ret_var_gen = next_var(opt_repr(aggr_fn.type), init_var_gen);
    var_is_first, var_gen = next_bool_var(ret_var_gen);

    extra_args_code, extra_args_surrs, var_gen = opt_eval_info(expr.extra_args, var_gen);
    extra_args_reprs = (opt_repr(t) : _, t <- aggr_fn.extra_args);
    extra_args = (low_level_expr(r, e) : e, r <- zip(extra_args_surrs, extra_args_reprs));

    red_vars = aggr_fn.red_vars;
    ord_red_vars = isort(keys(red_vars));
    red_vars_reprs = [v -> opt_repr(info.type) : v info <- red_vars];

    // For each of the physical representations we've to deal with, we'll set
    // aside a temporary variable to be used to store the result of <expr.expr>
    tmp_vars_by_repr = [];
    for r <- isort(values(red_vars_reprs)) {
      tmp_var, var_gen = next_var(r, var_gen);
      tmp_vars_by_repr = tmp_vars_by_repr & [r -> tmp_var];
    }

    // For each reduction variables, we reserve an accumulator
    red_vars_accs = [];
    for v <- ord_red_vars {
      phys_var, var_gen = next_var(red_vars_reprs(v), var_gen);
      red_vars_accs = red_vars_accs & [v -> phys_var];
    }

    input_repr = opt_repr(aggr_fn.elt_type);
    input_var, var_gen = next_var(input_repr, var_gen);

    bottom_actions = ({
      repr = red_vars_reprs(v);
      tmp_var = tmp_vars_by_repr(repr);
      acc_var = red_vars_accs(v);
      init_fn = red_var_init(aggr_fn.id, v);
      merge_fn = red_vars_merge(aggr_fn.id, v);
      code = branch(
        var_is_first,
        ( call_proc(acc_var, init_fn, (input_var) & extra_args, ()),
          set_bvar(var_is_first, false) if i == |ord_red_vars| - 1
        ),
        ( call_proc(tmp_var, init_fn, (input_var) & extra_args, ()),
          call_proc(acc_var, merge_fn, (acc_var, tmp_var) & extra_args, ())
        )
      );
      return yield_value_action(input_var, expr.expr, (code));
    } : v @ i <- ord_red_vars);

    action = yield_actions(nonempty(bottom_actions));
    action = cond_yield_action(expr.cond, action) if expr.cond?;
    cls = expr.clause;
    action = relvar_yield_action(cls.vars, cls.rel_var, cls.args, action);

    code = extra_args_code &
           (set_bvar(var_is_first, true)) &
           (fake_init_var(red_vars_accs(v)) : v <- ord_red_vars) &
           ( yield_action_opt_code(action, var_gen) |
             branch(
               var_is_first,
               (call_proc(res_var, null_value(aggr_fn.id), extra_args, ())),
               (call_proc(
                  res_var,
                  final_value_yield(aggr_fn.id),
                  (red_vars_accs(v) : v <- ord_red_vars) & extra_args,
                  ()
                 )
               )
             )
           );

    return (code, obj_expr(res_var), ret_var_gen);
  }


  // auto_method_call(var: AnyAutoVar?, name: MethodSymbol, args: Expr*)
  (Instr*, ObjExpr, VarGen) auto_method_call_opt_eval_info(AutoMethodCall expr, VarGen init_var_gen) {
    code, args_surrs, var_gen = opt_eval_info(expr.args, init_var_gen);
    res_var, var_gen = next_obj_var(init_var_gen);
    invoke_method_instr = invoke_auto_method(
      res_var:    res_var,
      auto_var:   expr.var if expr.var?,
      type:       if expr.var? then var_type(expr.var) else this_auto_symbol,
      method_id:  method_id(expr.name, |expr.args|),
      args:       args_surrs
    );
    code = (code | invoke_method_instr);
    return (code, res_var, var_gen);
  }


  // ex_qual(source: Clause, cond: Expr)
  (Instr*, ObjExpr, VarGen) ex_qual_opt_eval_info(Clause source, Expr cond, VarGen init_var_gen) {
    res_var, var_gen = next_bool_var(init_var_gen);

    bottom_action = yield_value_action(res_var, cond, (exit_block_if(res_var)));
    action = yield_action(source, bottom_action);
    code = yield_action_opt_code(action, var_gen);

    code = (set_bvar(res_var, false), execute_block(nonempty(code)));
    return (code, obj_expr(res_var), var_gen);
  }


  // set_comp(expr: Expr, source: Clause);
  (Instr*, ObjExpr, VarGen) set_comp_opt_eval_info(Expr expr, Clause source, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info((expr), source, var_gen);
    return ((code | mk_set(res_var, only_unsafe(strms))), res_var, var_gen);
  }


  // map_comp(key_expr: Expr, value_expr: Expr, source: Clause)
  (Instr*, ObjExpr, VarGen) map_comp_opt_eval_info(MapCompExpr expr, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info((expr.key_expr, expr.value_expr), expr.source, var_gen);
    assert |strms| == 2;
    return ((code | mk_map(res_var, strms(0), strms(1))), res_var, var_gen);
  }


  // bin_rel_comp(exprs: (Expr, Expr), source: Clause)
  (Instr*, ObjExpr, VarGen) bin_rel_comp_opt_eval_info(BinRelCompExpr expr, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info(expr.exprs, expr.source, var_gen);
    assert |strms| == 2;
    return ((code | mk_rel(res_var, strms(0), strms(1))), res_var, var_gen);
  }


  // tern_rel_comp(exprs: (Expr, Expr, Expr), source: Clause)
  (Instr*, ObjExpr, VarGen) tern_rel_comp_opt_eval_info(TernRelCompExpr expr, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info(expr.exprs, expr.source, var_gen);
    assert |strms| == 3;
    return ((code | mk_rel(res_var, strms(0), strms(1), strms(2))), res_var, var_gen);
  }


  (Instr*, StreamVar*) rel_comp_partial_eval_info(Expr+ exprs, Clause source, VarGen init_var_gen) {
    arg_vars,  var_gen = next_obj_vars(init_var_gen, |exprs|);
    strm_vars, var_gen = next_stream_vars(var_gen, |exprs|);

    args_info = nonempty(zip(exprs, arg_vars, strm_vars));

    bottom_action = yield_actions((yield_value_action(v, e, (append(sv, v))) : e, v, sv <- args_info));
    action = yield_action(source, bottom_action);
    nested_code = yield_action_opt_code(action, var_gen);

    code = (init_stream(v) : v <- strm_vars) & nested_code;
    return (code, strm_vars);
  }


  // match_expr(exprs: Expr+, cases: (ptrns: Pattern+, expr: Expr)+);
  (Instr*, ObjExpr, VarGen) match_expr_opt_eval_info(MatchExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate(true)), :invalid_var, init_var_gen) if type == empty_type;
    repr = opt_repr(type);
    res_var, var_gen = next_var(repr, init_var_gen);
    ret_var_gen = var_gen;

    if |expr.exprs| == 1 {
      match_expr = only(expr.exprs);
      match_expr_type = subexpr_type(match_expr);
      match_expr_code, match_expr_surr, var_gen = opt_eval_info(match_expr, var_gen);

      cases = ({
          ptrn = only_unsafe(c.ptrns);
          ptrn_env = generate_env(ptrn, match_expr_type);
          vars_reprs = [v -> low_level_var(opt_repr(t), v) : v t <- ptrn_env];
          surrs = surrogates & [v -> obj_expr(pv) : v pv <- vars_reprs];
          code, surr, _ = opt_eval_info(c.expr, var_gen, surrogates = surrs);
          code = (store_result(code, surr, res_var) | exit_block);
          return (ptrn, code, vars_reprs);
        } : c <- expr.cases
      );

      match_code = single_ptrn_match_expr_opt_code(match_expr_surr, match_expr_type, cases);
      return (match_expr_code & match_code, obj_expr(res_var), ret_var_gen);
    }
    else {
      exprs_types = (subexpr_type(e) : e <- expr.exprs);
      exprs_eval_code, exprs_surrs, var_gen = opt_eval_info(expr.exprs, var_gen);

      cases_code = ({
          ptrns_env = merge((generate_env(p, exprs_types(i)) : p @ i <- c.ptrns));
          vars_reprs = [v -> low_level_var(opt_repr(t), v) : v t <- ptrns_env];
          surrs = surrogates & [v -> obj_expr(pv) : v pv <- vars_reprs];
          code, surr, _ = opt_eval_info(c.expr, var_gen, surrogates = surrs);
          code = (store_result(code, surr, res_var) | exit_block);
          for p, t, s <- reverse(zip(c.ptrns, exprs_types, exprs_surrs))
            code = opt_ptrn_match_code(p, s, t, code, vars_reprs = vars_reprs);
          return code;
        } : c <- expr.cases
      );

      code = (exprs_eval_code | execute_block((join(cases_code) | terminate)));
      return (code, obj_expr(res_var), ret_var_gen);
    }
  }


  // rel_lookup(rel: Expr, args: [Nat -> Expr]);
  (Instr*, ObjExpr, VarGen) rel_lookup_opt_eval_info(RelLookup expr, VarGen init_var_gen) {
    arity = |expr.args|;
    target_idx = index_only(expr.args, nothing);

    // Physical representation of the result and variable that stores it
    type = types(expr_id);
    return ((terminate), :invalid_var, init_var_gen) if type == empty_type;

    repr = opt_repr(type);
    res_var, ret_var_gen = next_var(repr, init_var_gen);

    // Evaluation of all subexpressions
    code, rel_surr, var_gen = opt_eval_info(expr.rel, ret_var_gen);
    args_surrs = [];
    for a @ i <- expr.args {
      if a != nothing {
        arg_code, arg_surr, var_gen = opt_eval_info(value(a), var_gen);
        code = code & arg_code;
        args_surrs = args_surrs & [i -> arg_surr];
      }
    }
    assert |args_surrs| == arity - 1;

    if arity == 1 {
      code = (code | check(is_eq(get_size(rel_surr), 1)), set_any_var(res_var, only_elt(rel_surr)));
    }
    else if arity == 2 {
      arg_surr = only(values(args_surrs));
      if target_idx == 1 {
        code = (code | set_any_var(res_var, lookup(rel_surr, arg_surr)));
      }
      else {
        it_var, var_gen = next_bin_rel_it_var(var_gen);
        code = (code |
          get_iter(it_var, rel_surr, (nothing, just(arg_surr))),
          check(neg(is_out_of_range(it_var))),
          set_any_var(res_var, get_curr_arg(it_var, 0)),
          move_forward(it_var),
          check(is_out_of_range(it_var))
        );
      }
    }
    else {
      assert arity == 3;
      it_var, var_gen = next_tern_rel_it_var(var_gen);
      code = (code |
        get_any_rel_iter(it_var, rel_surr, maybe_seq(args_surrs, 3)),
        check(neg(is_out_of_range(it_var))),
        set_any_var(res_var, get_curr_arg(it_var, target_idx)),
        move_forward(it_var),
        check(is_out_of_range(it_var))
      );
    }

    return (code, obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) rel_memb_test_opt_eval_info(Expr rel, Maybe[Expr]+ args, VarGen init_var_gen) {
    args_surrs : Maybe[ObjExpr]*; ## WHY IS THIS NEEDED? IS THIS A BUG IN THE TYPECHECKER?

    res_var, ret_var_gen = next_bool_var(init_var_gen);

    code, rel_surr, var_gen = opt_eval_info(rel, ret_var_gen);

    args_surrs = ();
    for a <- args {
      if a != nothing {
        arg_code, arg_surr, var_gen = opt_eval_info(value(a), var_gen);
        code = code & arg_code;
        args_surrs = (args_surrs | just(arg_surr));
      }
      else {
        args_surrs = (args_surrs | nothing);
      }
    }

    code = (code | set_bvar(res_var, rel_obj_contains(rel_surr, nonempty(args_surrs))));
    return (code, obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_tail_expr_opt_eval_info(Expr seq, Expr+ tail, VarGen init_var_gen) {
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    code, seq_surr, var_gen = opt_eval_info(seq, ret_var_gen);
    for e @ i <- tail {
      elt_code, elt_surr, _ = opt_eval_info(e, var_gen);
      src_seq = if i == 0 then seq_surr else res_var;
      code = (code & elt_code | append_to_seq(res_var, src_seq, elt_surr));
    }
    return (code, res_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) membership_opt_eval_info(Expr obj, NeType type, VarGen init_var_gen) {
    res_var, ret_var_gen = next_bool_var(init_var_gen);
    code, surr, var_gen = opt_eval_info(obj, ret_var_gen);

    if is_subset(type, integer) and surr :: <int_obj(IntExpr)>
      check_expr = int_memb_check(expand_int_type(type, typedefs), _untag_(surr));
    else
      check_expr = is_member(memb_test_preds_map(type, !), surr);

    return ((code | set_bvar(res_var, check_expr)), obj_expr(res_var), ret_var_gen);


    BoolExpr int_memb_check(AnyIntType type, IntExpr expr) =
      integer         = true,
      low_ints()      = is_le(expr, type.max),
      high_ints()     = is_le(type.min, expr),
      int_range()     = and((is_le(type.min, expr), is_le(expr, max(type)))),
      union_type(ts?) = or((int_memb_check(t, expr) : t <- isort(ts)));
  }


  (Instr*, ObjExpr, VarGen) accessor_opt_eval_info(Expr expr, SymbObj field, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_info(expr, init_var_gen);
    target_type = subexpr_type(expr);
    maybe_field_repr = nothing;
    if is_subset(target_type, tag_obj_type(atom_type, type_any)) {
      tag_type = tag_supertype(target_type);
      if is_symb_singl_type(tag_type) {
        tag_obj = only_symb(tag_type);
        tag = untag(tag_obj);
        tag_type = symb_type(tag_obj);
        opt_types = if optimized_tagged_records_types(tag, _)
          then optimized_tagged_records_types(tag, !)
          else ();
        for t @ i <- opt_types {
          if is_subset(target_type, tag_obj_type(tag_type, t)) {
            surr = cast_opt_tag_rec(tag, i, surr) if not surr :: OptTagRecVar;
            fields_reprs = untag(optimized_tagged_records(tag, !)(i));
            maybe_field_repr = just(fields_reprs(untag(field), !).repr);
            break;
          }
        }
      }
    }

    type = types(expr_id);
    repr = if type != empty_type then low_level_repr(type) else :object;
    res_var, var_gen = next_var(repr, var_gen);
    code = (code | set_any_var(res_var, lookup_field(surr, field, maybe_field_repr)));

    return (code, obj_expr(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) accessor_test_opt_eval_info(Expr expr, SymbObj field, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_info(expr, init_var_gen);
    return (code, bool_obj(has_field(surr, field)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) record_opt_eval_info(SymbObj+ labels, Expr+ values, VarGen init_var_gen) {
    var, var_gen = next_obj_var(init_var_gen);
    code, surrs, var_gen = opt_eval_info(values, var_gen);
    code = (code | mk_record(var, [l -> surrs(i) : l @ i <- labels]));
    return (code, var, var_gen);
  }


  (Instr*, ObjExpr, VarGen) tag_obj_expr_opt_eval_info(TagObjExpr expr, VarGen init_var_gen) {
    tag_type = subexpr_type(expr.tag);
    if is_symb_singl_type(tag_type) {
      // The tag is a known symbol
      tag = untag(only_symb(tag_type));
      may_need_conv = false;
      if optimized_tagged_records(tag, _) {
        // There's at least one optimized representation for values with such tag
        reprs = optimized_tagged_records(tag, !);
        obj_expr = expr.obj;
        obj_type = subexpr_type(obj_expr);
        for repr @ repr_idx <- reprs {
          repr_type = low_level_repr_type(repr);
          if is_subset(obj_type, repr_type)
            // The tagged value has an optimized representation
            // assert not may_need_conv; ## SEE COMMENT BELOW
            return opt_rec_eval_info(tag, obj_expr, repr, repr_idx, init_var_gen);
          else if not are_ptype_disjoint(obj_type, repr_type)
            ## THIS DOESN'T MAKE MUCH SENSE. obj_type AND repr_type ARE NEVER
            ## GOING TO BE PTYPE DISJOINT, BECAUSE THEY ARE BOTH RECORDS
            ## WE NEED A BETTER CHECK, FOR EXAMPLE WE COULD SEE IF
            ## THEIR SET OF FIELDS ARE COMPATIBLE
            may_need_conv = true;
        }
      }
      // The tagged value may or may not have an optimized representation
      code, value_surr, var_gen = opt_eval_info(expr.obj, init_var_gen);
      var, var_gen = next_obj_var(var_gen);
      creation_instr = if may_need_conv
        then call_proc(var, :tag_rec_conv(tag), (value_surr), ())
        else mk_tagged_obj(var, object(tag), value_surr);
      code = (code | creation_instr);
      return (code, var, var_gen);
    }
    else {
      // The symbol is not known at compile time
      tag_code, tag_surr, var_gen = opt_eval_info(expr.tag, init_var_gen);
      value_code, value_surr, var_gen = opt_eval_info(expr.obj, var_gen);
      var, var_gen = next_obj_var(var_gen);
      ## HERE WE COULD CHECK IF THE TARGET OBJECT NEEDS TO BE OPTIMIZED
      code = (tag_code & value_code | call_proc(var, :any_tag_obj_conv, (tag_surr, value_surr), ()));
      return (code, var, var_gen);
    }


    (Instr*, ObjExpr, VarGen) opt_rec_eval_info(Symbol tag, Expr rec_expr_ref, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      rec_expr = expand_subexpr(rec_expr_ref);
      if rec_expr :: MapExpr {
        // The expression that defines the tagged value is a map expression
        fields = isort(untag(rec_expr));
        keys_types = (subexpr_type(f.key) : f <- fields);
        if not (t <- keys_types : not is_symb_singl_type(t)) {
          // Every key in the map expression is a known symbol
          labels = (untag(only_symb(t)) : t <- keys_types);
          return direct_opt_rec_eval_info(tag, labels, rec_expr, repr, repr_idx, init_var_gen);
        }
      }

      // Generic creation: evaluating the record expression first, then
      // passing it on to the representation-specific conversion function
      code, value_surr, var_gen = opt_eval_info(rec_expr, init_var_gen);
      var, var_gen = next_opt_tag_rec_var(var_gen, tag, repr_idx);
      code = (code | call_proc(var, :tag_rec_repr_conv(tag, repr_idx), (value_surr), ()));
      return (code, var, var_gen);
    }


    (Instr*, ObjExpr, VarGen) direct_opt_rec_eval_info(Symbol tag, Symbol+ labels, MapExpr rec_expr, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      low_level_fields = untag(repr);
      var, var_gen = next_opt_tag_rec_var(init_var_gen, tag, repr_idx);
      surrs = ();
      conds = ();
      code = (inst_opt_tag_rec(var, tag, repr_idx));
      var_gen = init_var_gen;
      for f @ i <- isort(untag(rec_expr)) {
        label = labels(i);
        field = low_level_fields(label, !);

        if f.cond? {
          cond_code, cond_surr, var_gen = opt_eval_info(f.cond, var_gen);
          code = code & cond_code;
          maybe_cond = just(bool_value(cond_surr));
        }
        else {
          maybe_cond = nothing;
        }

        field_code, surr, var_gen = opt_eval_info(f.value, var_gen);
        set_field_instr = write_rec_field(var, label, low_level_expr(field.repr, surr), field.optional);
        field_code = (field_code | set_field_instr);
        if maybe_cond != nothing {
          cond_surr = value(maybe_cond);
          field_code = (do_if(value(maybe_cond), field_code));
        }

        code = code & field_code;
      }
      code = (code | finish_init(var));

      return (code, var, var_gen);
    }
  }


  // seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) seq_comp_opt_eval_info(SeqCompExpr expr, VarGen init_var_gen) {
    // Generating the result variable and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    var_gen = ret_var_gen;

    // Calculating source type, and returning early if the type is trivial
    src_type = subexpr_type(expr.src_expr);
    if src_type == empty_type
      return ((terminate), :invalid_var, init_var_gen);
    else if is_subset(src_type, empty_seq_type)
      return ((), empty_seq, init_var_gen);

    // Types of elements of source and destination sequences
    src_elt_type = seq_elem_supertype(src_type);
    elt_type = subexpr_type(expr.expr);
    fail if src_elt_type == empty_type or elt_type == empty_type;

    // Low-level representation of elements of source and destination sequences
    src_repr = opt_repr(src_elt_type);
    elt_repr = low_level_elt_repr(if expr.decl_elt_type? then expr.decl_elt_type else elt_type);

    // Evaluation of source expression
    eval_code, src_surr, var_gen = opt_eval_info(expr.src_expr, var_gen);
    if not src_surr :: <LocVar, StdVar> {
      src_var, var_gen = next_obj_var(var_gen);
      eval_code = (eval_code | set_var(src_var, src_surr));
      src_surr = src_var;
    }

    // Temporary buffer for source data
    src_array_var, var_gen = next_array_var(var_gen, src_repr);

    // Allocation of destination array
    array_size_var, var_gen = next_int32_var(var_gen);
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    eval_code = (eval_code |
      set_ivar32(array_size_var, get_size(src_surr)),
      array_alloc(array_var, array_size_var)
    );

    vars = expr.vars;
    if |vars| == 1 {
      maybe_var = only(vars);
      body_code = ();
      surrs = surrogates;
      if maybe_var != nothing {
        var = value(maybe_var);
        it_var = low_level_var(src_repr, var);
        surrs = surrs & [var -> obj_expr(it_var) if var != it_var];
      }
      else
        it_var, var_gen = next_var(src_repr, var_gen);
    }
    else {
      assert src_repr == :object;
      vars_types = tuple_field_supertypes(src_elt_type, |vars|);
      ## REMOVE WHEN DONE
      assert vars_types == (restricted_seq_elem_supertype(src_elt_type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- vars_types);
      phys_vars = (apply(v, low_level_var(reprs(i), $)) : v @ i <- vars);
      new_surrs = [
        value(v) -> obj_expr(value_unsafe(pv))
        : v @ i <- vars, pv = phys_vars(i), v != pv, v != nothing
      ];
      surrs = surrogates & new_surrs;
      it_var, var_gen = next_obj_var(var_gen);
      body_code = (set_any_var(value(v), at(it_var, i, :object)) : v @ i <- phys_vars, v != nothing);
    }

    // Index variables
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    surrs = surrs & [expr.idx_var -> int_obj(hidden_idx_var)] if expr.idx_var?;

    // Finalizing loop body
    if expr.sel_expr? {
      // Generating and initializing the write cursor
      next_free_slot_idx_var, var_gen = next_int32_var(var_gen);
      loop_init_code = (set_ivar32(next_free_slot_idx_var, 0));

      // Evaluation of filter condition
      cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.sel_expr, var_gen, surrogates = surrs);

      // Evaluation of result element expression
      elt_eval_code, elt_surr, var_gen = opt_eval_info(expr.expr, var_gen, surrogates = surrs);

      // Loop body
      write_array_instr = array_write(array_var, next_free_slot_idx_var, elt_surr);
      incr_idx_instr = increment(next_free_slot_idx_var);
      cond_code = (elt_eval_code | write_array_instr, incr_idx_instr);
      body_code = (body_code & cond_eval_code | do_if(bool_value(cond_surr), cond_code));

      // Sequence creation
      mk_seq_instr = mk_seq(res_var, array_var, next_free_slot_idx_var, array_size_var);
    }
    else {
      // Nothing to initialize
      loop_init_code = ();

      // Evaluation of the expression that yields a new element
      elt_eval_code, elt_surr, var_gen = opt_eval_info(expr.expr, var_gen, surrogates = surrs);

      // Loop body
      body_code = (body_code & elt_eval_code | array_write(array_var, hidden_idx_var, elt_surr));

      // Sequence creation
      mk_seq_instr = mk_seq(res_var, array_var, array_size_var);
    }

    // Mapping source to destination arrays
    map_instr_iter = seq_iter(
      seq:        src_surr,
      src_array:  src_array_var,
      tmp_buffer: array_var,
      count_var:  array_size_var,
      idx_var:    hidden_idx_var,
      it_var:     it_var
    );
    map_instr = foreach(map_instr_iter, body_code);

    eval_code = (eval_code & loop_init_code | map_instr, mk_seq_instr);
    return (eval_code, res_var, ret_var_gen);
  }


  // range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) range_comp_opt_eval_info(RangeCompExpr expr, VarGen init_var_gen) {
    // Generating the result and hidden loop variables and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    idx_var, var_gen = next_int32_var(ret_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    code, bound_surr, var_gen = opt_eval_info(expr.bound_expr, var_gen);
    if not bound_surr :: <Var, int_obj(<IntVar, upcast_int32(Int32Var)>)> {
      bound_var, var_gen = next_int_var(var_gen);
      code = store_result(code, bound_surr, bound_var);
      bound_surr = bound_var;
    }
    else {
      bound_surr = get_int_val(bound_surr);
    }

    // Type and low-level representation of the elements of the output sequence
    elt_type = nonempty_type(subexpr_type(expr.expr));
    elt_repr = low_level_elt_repr(if expr.decl_elt_type? then expr.decl_elt_type else elt_type);

    // Allocation of destination array
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    size_expr = if expr.inclusive then add(bound_surr, 1) else bound_surr;
    if not is_subset(subexpr_type(expr.bound_expr), type_nat) {
      if size_expr :: IntVar {
        instr = do_if(is_lt(size_expr, 0), set_ivar(size_expr, 0));
      }
      else if size_expr :: <upcast_int32(Int32Var)> {
        size_var = match (size_expr) upcast_int32(v?) = v;
        instr = do_if(is_lt(size_expr, 0), set_ivar32(size_var, 0));
      }
      else {
        size_var, var_gen = next_int_var(var_gen);
        instr = branch(
          is_ge(size_expr, 0),
          (set_ivar(size_var, size_expr)),
          (set_ivar(size_var, 0))
        );
        size_expr = size_var;
      }
      code = (code | instr);
    }
    code = (code | array_alloc(array_var, cast_int32(size_expr)));

    let surrogates = surrogates & [value(expr.var) -> obj_expr(idx_var) if expr.var != nothing] {
      if expr.sel_expr? {
        // Creating and initializing the target cursor
        target_idx_var, var_gen = next_int32_var(var_gen);
        code = (code | set_ivar32(target_idx_var, 0));

        // Evaluating the condition. No need to save the variable generator
        cond_eval_code, cond_surr, _ = opt_eval_info(expr.sel_expr, var_gen);

        // Evaluating the expression that yields a new element
        eval_code, elt_surr, _ = opt_eval_info(expr.expr, var_gen);

        // Conditional array write
        write_instr = array_write(array_var, target_idx_var, elt_surr);
        cond_write_instr = do_if(bool_value(cond_surr), (eval_code | write_instr, increment(target_idx_var)));

        // Body code and sequence creation instruction
        body_code = (cond_eval_code | cond_write_instr);
        mk_seq_instr = mk_seq(res_var, array_var, target_idx_var, cast_int32(size_expr));
      }
      else {
        // Evaluating the expression that yields a new element
        eval_code, elt_surr, _ = opt_eval_info(expr.expr, var_gen);

        // Body code and sequence creation instruction
        write_instr = array_write(array_var, idx_var, elt_surr);
        body_code = (eval_code | write_instr);
        mk_seq_instr = mk_seq(res_var, array_var, cast_int32(size_expr));
      }
    }

    // Final body code
    break_cond = if expr.inclusive
      then is_gt(upcast_int32(idx_var), bound_surr)
      else is_ge(upcast_int32(idx_var), bound_surr);
    body_code = ((break_if(break_cond)) & body_code | increment(idx_var));

    // Final code
    code = (code | set_ivar32(idx_var, 0), repeat(body_code), mk_seq_instr);
    return (code, res_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) if_expr_opt_eval_info(IfExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate), :invalid_var, init_var_gen) if type == empty_type;
    repr = opt_repr(type);

    cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.cond, init_var_gen);

    res_var, var_gen = next_var(repr, var_gen);
    then_eval_code, _ = opt_eval_info(expr.then, res_var, var_gen);
    else_eval_code, _ = opt_eval_info(expr.else, res_var, var_gen);

    eval_code = (cond_eval_code | branch(bool_value(cond_surr), then_eval_code, else_eval_code));
    return (eval_code, obj_expr(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) eq_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    left_eval_code, left_surr, var_gen = opt_eval_info(left, init_var_gen);
    right_eval_code, right_surr, var_gen = opt_eval_info(right, var_gen);

    eval_code = left_eval_code & right_eval_code;
    return (eval_code, bool_obj(is_eq(left_surr, right_surr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) and_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == () {
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = and_then(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    }

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, _ = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, _ = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) or_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == () {
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = or_else(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    }

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, _ = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, _ = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if_not(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) not_expr_opt_eval_info(Expr expr, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    return (eval_code, bool_obj(neg(bool_value(surr_expr))), var_gen);
  }


  (Instr*, ObjExpr, VarGen) unary_pseudo_call_opt_eval_info(Expr target, Expr arg, VarGen init_var_gen) {
    target_type = subexpr_type(target);
    return ((terminate), :invalid_var, init_var_gen) if target_type == empty_type;


    target_eval_code, target_surr, var_gen = opt_eval_info(target, init_var_gen);
    arg_eval_code, arg_surr, var_gen = opt_eval_info(arg, var_gen);
    code = target_eval_code & arg_eval_code;

    if is_subset(target_type, type_seq) {
      elt_type = seq_elem_supertype(target_type);
      elt_likely_repr = if elt_type != empty_type then low_level_elt_repr(elt_type) else :object;
      type = types(expr_id);
      return ((terminate), :invalid_var, init_var_gen) if type == empty_type;
      repr = opt_repr(type);
      res_var, var_gen = next_var(repr, var_gen);
      code = (code | set_any_var(res_var, at(target_surr, get_int_val(arg_surr), elt_likely_repr)));
      expr_surr = obj_expr(res_var);
    }
    else if is_subset(target_type, type_set) {
      expr_surr = bool_obj(rel_obj_contains(target_surr, (just(arg_surr))));
    }
    else if is_subset(target_type, type_bin_rel) {
      type = types(expr_id);
      return ((terminate), :invalid_var, init_var_gen) if type == empty_type;
      repr = opt_repr(type);
      res_var, var_gen = next_var(repr, var_gen);
      code = (code | set_any_var(res_var, lookup(target_surr, arg_surr)));
      expr_surr = obj_expr(res_var);
    }
    else {
      assert is_subset(target_type, atom_type);
      expr_surr, var_gen = next_obj_var(var_gen);
      ## HERE WE COULD CHECK IF THE TARGET OBJECT NEEDS TO BE OPTIMIZED
      code = (code | call_proc(expr_surr, :any_tag_obj_conv, (target_surr, arg_surr), ()));
    }

    return (code, expr_surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) size_expr_opt_eval_info(Expr collection, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(collection, init_var_gen);
    return (eval_code, int_obj(get_size(surr_expr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_expr_opt_eval_info(SubExpr* elts, VarGen init_var_gen) {
    // Empty sequence
    return ((), empty_seq, init_var_gen) if elts == ();

    // Types of the elements of the sequence
    ord_elts_types = (subexpr_type(if is_cond_expr(e) then e.expr else e) : e <- elts);
    elts_types = set(ord_elts_types);
    elts_type = union_superset(elts_types);

    // Unreachable expression
    return ((terminate), :invalid_var, init_var_gen) if elts_types(empty_type) or elts_type == empty_type;

    // Elements representation
    elt_repr = low_level_elt_repr(elts_type);

    // Sequence and array variables
    seq_var, var_gen = next_obj_var(init_var_gen);
    elts_var, var_gen = next_array_var(var_gen, elt_repr);

    // Both seq_var and elts_var must survive the evaluation of the expression
    ret_var_gen = var_gen;

    // Dealing with the important special case of sequences of literal integers
    if is_subset(elts_type, integer) and not (e <- elts : is_cond_expr(e)) {
      if not (t <- elts_types : t == empty_type or not is_singleton(t)) {
        int_seq = (only_integer(t) : t <- ord_elts_types);
        if int_seqs_ids(int_seq, _) {
          seq_id = int_seqs_ids(int_seq, !);
          code = (build_const_int_seq(seq_var, seq_id));
          return (code, seq_var, ret_var_gen);
        }
      }
    }

    conds = (e.cond : e <- elts, is_cond_expr(e));
    if conds == () {
      // Easy case, no conditional inclusions
      if |elts| > 1 and |elts| <= 4 {
        // Here we use a tuple expr
        code = ();
        elts_aliases = ();
        for e @ i <- elts {
          fail if is_cond_expr(e); ## ANY BETTER WAY TO DO THIS?
          fail if not i :: Int32;
          elt_eval_code, elt_alias, var_gen = opt_eval_info(e, var_gen);
          code = code & elt_eval_code;
          elts_aliases = (elts_aliases | elt_alias);
        }
        code = (code | set_any_var(seq_var, tuple_to_obj(low_level_tuple_expr(nonempty(elts_aliases)))));
        return (code, seq_var, ret_var_gen);
      }
      else {
        code = (array_alloc(elts_var, int32(|elts|)));
        for e @ i <- elts {
          fail if is_cond_expr(e); ## ANY BETTER WAY TO DO THIS?
          fail if not i :: Int32;
          elt_eval_code, elt_surr, _ = opt_eval_info(e, var_gen);
          code = code & (elt_eval_code | array_write(elts_var, i, elt_surr));
        }
        return ((code | mk_seq(seq_var, elts_var, int32(|elts|))), seq_var, ret_var_gen);
      }
    }

    // Evaluating conditions and final array size
    min_size = int32(|elts| - |conds|);
    conds_code, cond_vars, size_var, var_gen = conds_eval_info(conds, min_size, var_gen);
    idx_var, var_gen = next_int32_var(var_gen);

    // Allocation of destination array
    code = (array_alloc(elts_var, size_var));

    // Computation of all array elements
    cond_expr_idx = 0;
    for e @ i <- elts {
      fail if not i :: Int32; ## ANY BETTER WAY TO DO THIS?
      is_last = i == |elts| - 1;
      if is_cond_expr(e) { // Conditional inclusion expression
        elt_code, elt_surr, _ = opt_eval_info(e.expr, var_gen);
        if cond_expr_idx == 0 {
          // If it's the first conditional expression, we statically know the
          // destination array index. After that we need to use the cursor
          // variable, unless this is the last element in the sequence
          cond = cond_vars(cond_expr_idx);
          elt_code = (elt_code | array_write(elts_var, i, elt_surr));
          if not is_last {
            elt_code = (elt_code | set_ivar32(idx_var, int32(i+1)));
            elt_instr = branch(cond, elt_code, (set_ivar32(idx_var, i)));
          }
          else {
            elt_instr = do_if(cond, elt_code);
          }
        }
        else {
          elt_code = (elt_code | array_write(elts_var, idx_var, elt_surr));
          elt_code = (elt_code | increment(idx_var)) if not is_last;
          elt_instr = do_if(cond_vars(cond_expr_idx), elt_code);
        }
        code = (code | elt_instr);
        cond_expr_idx = cond_expr_idx + 1;
      }
      else { // Non-conditional expression
        elt_eval_code, elt_surr, _ = opt_eval_info(e, var_gen);
        // Until we reach the first conditional element we statically know the
        // destination array index. After that we need to use the cursor variable
        write_code = if cond_expr_idx == 0
          then (array_write(elts_var, i, elt_surr))
          else (array_write(elts_var, idx_var, elt_surr), increment(idx_var) if not is_last);
        code = code & elt_eval_code & write_code;
      }
    }

    // Creation of the wrapping sequence object
    code = (code | mk_seq(seq_var, elts_var, size_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_var, 0), (set_var(seq_var, empty_seq)), code)) if min_size == 0;

    return (conds_code & code, seq_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) set_expr_opt_eval_info([SubExpr] elts, VarGen init_var_gen) {
    // Empty set
    return ((), empty_rel, init_var_gen) if elts == [];

    // Set object and array variables.
    set_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    elts_var, var_gen = next_array_var(ret_var_gen, :object);

    exprs = isort([e : e <- elts, not is_cond_expr(e)]);
    cond_exprs = isort([e : e <- elts, is_cond_expr(e)]);

    // Evaluating of conditions and final array size
    min_size = int32(|exprs|);
    conds = (e.cond : e <- cond_exprs);
    conds_code, cond_vars, size_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination array
    size_expr = if cond_exprs == () then min_size else size_var;
    code = (array_alloc(elts_var, size_expr));

    // Non-conditional elements
    for e @ i <- exprs {
      eval_code, surr, _ = opt_eval_info(e, var_gen);
      code = (code & eval_code | array_write(elts_var, int32(i), surr));
    }

    if |cond_exprs| == 1 {
      // Just one conditional element, no need to have an index variable
      elt_code, surr, _ = opt_eval_info(only(cond_exprs).expr, var_gen);
      elt_code = (elt_code | array_write(elts_var, min_size, surr));
      code = (code | do_if(cond_vars(0), elt_code));
    }
    else if |cond_exprs| > 1 {
      // More than one conditional element, we need to keep track of the next array slot
      size_idx_var, var_gen = next_int32_var(var_gen);
      for e @ i <- cond_exprs {
        cond = cond_vars(i);
        elt_code, surr, _ = opt_eval_info(e.expr, var_gen);
        elt_code = (elt_code | array_write(elts_var, if i == 0 then min_size else size_idx_var, surr));
        is_last = i == |cond_exprs| - 1;
        if i == 0 {
          elt_code = (elt_code | set_ivar32(size_idx_var, int32(min_size + 1)));
          elt_instr = branch(cond, elt_code, (set_ivar32(size_idx_var, min_size)));
        }
        else {
          elt_code = (elt_code | increment(size_idx_var)) if not is_last;
          elt_instr = do_if(cond, elt_code);
        }
        code = (code | elt_instr);
      }
    }

    // Creation of the set object
    code = (code | mk_set(set_obj_var, elts_var, size_expr));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_var, 0), (set_var(set_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, set_obj_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) map_expr_opt_eval_info([+(key: Expr, value: Expr, cond: Expr?)] entries, VarGen var_gen) {
    // Checking if the expression is actually a record,
    // and if so building a record object instead
    if not (e <- entries : e.cond?) {
      ord_entries = isort(entries);
      keys_types = (subexpr_type(e.key) : e <- ord_entries);
      if not (t <- keys_types : not is_symb_singl_type(t)) {
        labels = (only_symb(t) : t <- keys_types);
        if duplicates(labels) == []
          return record_opt_eval_info(labels, (e.value : e <- ord_entries), var_gen);
      }
    }

    // Separating conditional entries from unconditional ones
    uncond_entries = isort([(e.key, e.value) : e <- entries, not e.cond?]);
    cond_entries = isort([(e.key, e.value, e.cond) : e <- entries, e.cond?]);

    return bin_rel_expr_opt_eval_info(uncond_entries, cond_entries, true, var_gen);
  }


  (Instr*, ObjExpr, VarGen) bin_rel_expr_opt_eval_info([+(args: (Expr, Expr), cond: Expr?)] entries, VarGen var_gen) {
    // Separating conditional entries from unconditional ones
    uncond_entries = isort([e.args : e <- entries, not e.cond?]);
    cond_entries = isort([(left(e.args), right(e.args), e.cond) : e <- entries, e.cond?]);

    return bin_rel_expr_opt_eval_info(uncond_entries, cond_entries, false, var_gen);
  }


  (Instr*, ObjExpr, VarGen) bin_rel_expr_opt_eval_info((Expr, Expr)* uncond_entries, (Expr, Expr, Expr)* cond_entries, Bool is_map, VarGen init_var_gen) {
    // Binary relation object and array variables.
    rel_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    col1_var, var_gen = next_array_var(ret_var_gen, :object);
    col2_var, var_gen = next_array_var(var_gen, :object);

    // Evaluating of conditions and final array size
    min_size = int32(|uncond_entries|);
    conds = (c : _, _, c <- cond_entries);
    conds_code, cond_vars, size_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination arrays
    size_expr = if cond_entries == () then min_size else size_var;
    code = (array_alloc(col1_var, size_expr), array_alloc(col2_var, size_expr));

    // Non-conditional elements
    for a1, a2 @ i <- uncond_entries
      code = code & write_entry_code(a1, a2, col1_var, col2_var, int32(i), var_gen);

    if |cond_entries| == 1 {
      // Just one conditional entry, no need to have an index variable
      arg1, arg2, _ = only(cond_entries);
      entry_code = write_entry_code(arg1, arg2, col1_var, col2_var, min_size, var_gen);
      code = (code | do_if(cond_vars(0), entry_code));
    }
    else if |cond_entries| > 1 {
      // More than one conditional element, we need to keep track of the next array slot
      size_idx_var, var_gen = next_int32_var(var_gen);
      for a1, a2, _ @ i <- cond_entries {
        cond = cond_vars(i);
        idx = if i == 0 then min_size else size_idx_var;
        entry_code = write_entry_code(a1, a2, col1_var, col2_var, idx, var_gen);
        is_last = i == |cond_entries| - 1;
        if i == 0 {
          entry_code = (entry_code | set_ivar32(size_idx_var, int32(min_size+1)));
          entry_instr = branch(cond, entry_code, (set_ivar32(size_idx_var, min_size)));
        }
        else {
          entry_code = (entry_code | increment(size_idx_var)) if not is_last;
          entry_instr = do_if(cond, entry_code);
        }
        code = (code | entry_instr);
      }
    }

    // Creation of the map object
    code = (code | mk_rel(rel_obj_var, col1_var, col2_var, size_expr, is_map));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_var, 0), (set_var(rel_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, rel_obj_var, ret_var_gen);


    Instr* write_entry_code(Expr arg1, Expr arg2, ArrayVar col1, ArrayVar col2, Int32Expr idx, VarGen var_gen) {
      eval_code, surr, _ = opt_eval_info(arg1, var_gen);
      arg1_code = (eval_code | array_write(col1, idx, surr));
      eval_code, surr, _ = opt_eval_info(arg2, var_gen);
      arg2_code = (eval_code | array_write(col2, idx, surr));
      return arg1_code & arg2_code;
    }
  }


  (Instr*, ObjExpr, VarGen) tern_rel_expr_opt_eval_info([+(args: (Expr, Expr, Expr), cond: Expr?)] entries, VarGen init_var_gen) {
    // Binary relation object and array variables.
    rel_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    col1_var, var_gen = next_array_var(ret_var_gen, :object);
    col2_var, var_gen = next_array_var(var_gen, :object);
    col3_var, var_gen = next_array_var(var_gen, :object);

    // Separating conditional entries from unconditional ones
    uncond_entries = isort([e : e <- entries, not e.cond?]);
    cond_entries = isort([e : e <- entries, e.cond?]);

    // Evaluating of conditions and final array size
    min_size = int32(|uncond_entries|);
    conds = (e.cond : e <- cond_entries);
    conds_code, cond_vars, size_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination arrays
    size_expr = if cond_entries == () then min_size else size_var;
    code = (array_alloc(v, size_expr) : v <- (col1_var, col2_var, col3_var));

    // Non-conditional elements
    for e @ i <- uncond_entries
      code = code & write_entry_code(e.args, col1_var, col2_var, col3_var, int32(i), var_gen);

    if |cond_entries| == 1 {
      // Just one conditional entry, no need to have an index variable
      entry = only(cond_entries);
      entry_code = write_entry_code(entry.args, col1_var, col2_var, col3_var, min_size, var_gen);
      code = (code | do_if(cond_vars(0), entry_code));
    }
    else if |cond_entries| > 1 {
      // More than one conditional element, we need to keep track of the next array slot
      size_idx_var, var_gen = next_int32_var(var_gen);
      for e @ i <- cond_entries {
        cond = cond_vars(i);
        idx = if i == 0 then min_size else size_idx_var;
        entry_code = write_entry_code(e.args, col1_var, col2_var, col3_var, idx, var_gen);
        is_last = i == |cond_entries| - 1;
        if i == 0 {
          entry_code = (entry_code | set_ivar32(size_idx_var, int32(min_size+1)));
          entry_instr = branch(cond, entry_code, (set_ivar32(size_idx_var, min_size)));
        }
        else {
          entry_code = (entry_code | increment(size_idx_var)) if not is_last;
          entry_instr = do_if(cond, entry_code);
        }
        code = (code | entry_instr);
      }
    }

    // Creation of the map object
    code = (code | mk_rel(rel_obj_var, col1_var, col2_var, col3_var, size_expr));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_var, 0), (set_var(rel_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, rel_obj_var, ret_var_gen);


    Instr* write_entry_code((Expr, Expr, Expr) args, ArrayVar col1, ArrayVar col2, ArrayVar col3, Int32Expr idx, VarGen var_gen) {
      arg1, arg2, arg3 = args;
      eval_code, surr, _ = opt_eval_info(arg1, var_gen);
      arg1_code = (eval_code | array_write(col1, idx, surr));
      eval_code, surr, _ = opt_eval_info(arg2, var_gen);
      arg2_code = (eval_code | array_write(col2, idx, surr));
      eval_code, surr, _ = opt_eval_info(arg3, var_gen);
      arg3_code = (eval_code | array_write(col3, idx, surr));
      return arg1_code & arg2_code & arg3_code;
    }
  }


  // fn_call(fn_id: FnFamilyId, args: Expr*, cls_args: AnyClsExpr*, impl_args: [ImplArg -> Expr])
  (Instr*, ObjExpr, VarGen) fn_call_opt_eval_info(FnCallExpr expr, VarGen init_var_gen) {
    env = environments(expr_id);

    // Actual arguments' types
    args_types = (subexpr_type(a) : a <- expr.args);

    // Actual types of closure arguments
    cls_types = inst_cls_args_types(expr.fn_id, args_types, expr.cls_args, env, typed_vars = []);

    // Low-level signature of the target function
    fn_id, low_level_sign = low_level_sign(expr.fn_id, args_types);

    // Result variable and returned variable generator
    res_var, ret_var_gen = next_var(low_level_sign.ret_value, init_var_gen);

    // Dealing with implicit arguments
    ord_impl_args = isort(keys(expr.impl_args));
    backup_vars, var_gen = next_obj_vars(ret_var_gen, |ord_impl_args|);
    tear_down_code = (set_var(a, backup_vars(i)) : a @ i <- ord_impl_args);
    set_up_code = join(({
        eval_code, surr, _ = opt_eval_info(expr.impl_args(a, !), var_gen);
        return (eval_code | set_var(backup_vars(i), a), set_var(a, surr));
      } : a @ i <- ord_impl_args
    ));

    // Evaluation of the arguments
    args_eval_code, args_surrs, _ = opt_eval_info(expr.args, var_gen);

    // Low-level actual arguments
    low_level_args = (low_level_expr(low_level_sign.args(i), s) : s @ i <- args_surrs);

    // Evaluation code for the call only
    cls_args = (opt_comp_cls(a, t, env, surrogates) : a, t <- zip(expr.cls_args, cls_types));
    eval_code = (args_eval_code | call_proc(res_var, fn_id, low_level_args, cls_args));

    return (set_up_code & eval_code & tear_down_code, obj_expr(res_var), ret_var_gen);
  }


  // cls_call(name: ClsVar, args: Expr+)
  (Instr*, ObjExpr, VarGen) cls_call_opt_eval_info(ClsVar name, Expr+ args, VarGen init_var_gen) {
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    eval_code, surrs, var_gen = opt_eval_info(args, ret_var_gen);
    final_name = lookup(cls_var_subst_map, name, name);
    code = (eval_code | call_cls(res_var, final_name, surrs));
    return (code, res_var, ret_var_gen);
  }


  // builtin_call(name: BuiltIn, args: Expr+);
  (Instr*, ObjExpr, VarGen) builtin_call_opt_eval_info(BuiltinCall expr, VarGen init_var_gen) {
    // Argument types
    args_types = (subexpr_type(a) : a <- expr.args);

    // Evaluation of the arguments
    args_eval_code, args_surrs, var_gen = opt_eval_info(expr.args, init_var_gen);

    // Builtin call
    code, surr, var_gen = eval_info(expr.name, nonempty(args_surrs), nonempty(args_types), var_gen);

    return (args_eval_code & code, surr, var_gen);


    (Instr*, ObjExpr, VarGen) eval_info(BuiltIn name, ObjExpr+ args, Type+ args_types, VarGen init_var_gen) =
      slice   |
      cat     |
      rev     |
      isort   |
      insert  |
      remove  |
      put     |
      drop    |
      parse   |
      print   = { res_var, var_gen = next_obj_var(init_var_gen);
                  instr = eval_instr(name, args, args_types, res_var);
                  return ((instr), res_var, var_gen);
                },
      _       = ((), eval_expr(name, args), init_var_gen);


    Instr eval_instr(BuiltIn name, ObjExpr+ args, Type+ args_types, LocVar res_var) =
      slice         = get_seq_slice(res_var, args(0), get_int_val(args(1)), get_int_val(args(2))),
      cat           = eval_cat_instr(args(0), args(1), args_types(0), args_types(1), res_var),
      rev           = rev_seq(res_var, args(0)),
      isort         = internal_sort(res_var, args(0)),
      insert        = insert_elt(res_var, args(0), args(1)),
      remove        = remove_elt(res_var, args(0), args(1)),
      put           = set_key_value(res_var, args(0), args(1), args(2)),
      drop          = drop_key(res_var, args(0), args(1)),
      parse         = parse_value(res_var, args(0)),
      print         = print_value(res_var, args(0));


    Instr eval_cat_instr(ObjExpr left_arg, ObjExpr right_arg, Type left_arg_type, Type right_arg_type, LocVar res_var) {
      if is_subset(left_arg_type, type_int_seq) and is_subset(right_arg_type, type_int_seq)
        return join_int_seqs(res_var, left_arg, right_arg);
      if is_subset(left_arg_type, type_float_seq) and is_subset(right_arg_type, type_float_seq)
        return join_float_seqs(res_var, left_arg, right_arg);
      return join_seqs(res_var, left_arg, right_arg);
    }


    ObjExpr eval_expr(BuiltIn name, ObjExpr+ args) =
      neg       |
      add       |
      sub       |
      mult      |
      div       |
      mod       |
      and       |
      or        |
      xor       = int_obj(int_op_eval_info(name, (get_int_val(a) : a <- args))),
      lt        |
      le        = bool_obj(bool_op_eval_info(name, (get_int_val(a) : a <- args))),
      flt       |
      fle       = bool_obj(floats_to_bool_op_eval_info(name, (float_value(a) : a <- args))),
      bits      |
      round     = int_obj(int_op_eval_info(name, float_value(args(0)))),
      fneg      |
      fadd      |
      fsub      |
      fmult     |
      fdiv      |
      fexp      |
      fsqrt     = float_obj(float_op_eval_info(name, (float_value(a) : a <- args))),
      float     = float_obj(int_to_float(get_int_val(args(0)))),
      tag       = get_tag(args(0)),
      untag     = get_inner_obj(args(0)),

      rand_nat  = int_obj(rand_nat(args(0))),
      counter   = int_obj(unique_nat),
      ticks     = int_obj(ticks);



    BoolExpr bool_op_eval_info(BuiltIn, IntExpr+ args) =
      lt  = is_lt(args(0), args(1)),
      le  = is_le(args(0), args(1));

    BoolExpr floats_to_bool_op_eval_info(BuiltIn, FloatExpr+ args) =
      flt   = is_flt(args(0), args(1)),
      fle   = is_fle(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, IntExpr+ args) =
      neg   = minus(args(0)),
      add   = add(args(0), args(1)),
      sub   = sub(args(0), args(1)),
      mult  = mult(args(0), args(1)),
      div   = div(args(0), args(1)),
      mod   = mod_op(args(0), args(1)),
      and   = bitwise_and(args(0), args(1)),
      or    = bitwise_or(args(0), args(1)),
      xor   = bitwise_xor(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, FloatExpr arg) =
      bits      = float_bits(arg),
      round     = round(arg);

    FloatExpr float_op_eval_info(BuiltIn, FloatExpr+ args) =
      fneg  = neg_float(args(0)),
      fadd  = add_floats(args(0), args(1)),
      fsub  = sub_floats(args(0), args(1)),
      fmult = mult_floats(args(0), args(1)),
      fdiv  = div_floats(args(0), args(1)),
      fexp  = exp_floats(args(0), args(1)),
      fsqrt = square_root(args(0));
  }

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////

  ## BAD BAD BAD: THIS IS A RIDICULOUS HACK
  ((), (), Int32Var, VarGen) conds_eval_info((), Int32 min_size, VarGen init_var_gen) =
    ((), (), ivar32(9223372036854775807), init_var_gen);


  (Instr*, BoolVar+, Int32Var, VarGen) conds_eval_info(Expr+ conds, Int32 min_size, VarGen init_var_gen) {
    // Evaluation of all conditions
    var_gen = init_var_gen;
    cond_vars = ();
    code = ();
    for c @ i <- conds {
      eval_code, surr_expr, var_gen = opt_eval_info(c, var_gen);
      if not surr_expr :: <bool_obj(BoolVar)> {
        surr_var, var_gen = next_bool_var(var_gen);
        eval_code = store_result(eval_code, surr_expr, surr_var);
      }
      else {
        surr_var = untag(surr_expr);
      }
      code = code & eval_code;
      cond_vars = (cond_vars | surr_var);
    }

    // Integer variable that stores the resulting size
    size_var, var_gen = next_int32_var(var_gen);

    // Computation of final array size
    len_expr = foldr(nonempty((bool_to_bit(v) : v <- cond_vars)), add32);
    len_expr = add32(min_size, len_expr) if min_size != 0;
    code = (code | set_ivar32(size_var, len_expr));

    return (code, nonempty(cond_vars), size_var, var_gen);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         options           : CompOptions {

  AnyLambdaExpr opt_comp_cls(AnyClsExpr expr, Type* args_types, [EnvVar -> Type] env, [SurrExpr -> ObjExpr] surrs) =
    cls_var()   = lookup(cls_var_subst_map, expr, expr),
    fn_ptr(fn?) = opt_comp_cls(arity(expr), fn_call(fn, (fn_arg(i) : i < arity(expr)), ()), args_types, env, surrs),
    cls_expr()  = opt_comp_cls(expr.arity, expr.expr, args_types, env, surrs);


  AnyLambdaExpr opt_comp_cls(NzNat arity, Expr expr, Type* args_types, [EnvVar -> Type] env, [SurrExpr -> ObjExpr] surrs) {
    loc_vars = set((fn_arg(i) : i < arity));
    ext_vars = isort(extern_vars(expr) - set((fn_arg(i) : i < arity)));
    fail if not ext_vars :: StdVar*;

    cls_vars = isort(cls_vars(expr));

    subst_map     = [v -> capt_var(i)     : v @ i <- ext_vars];
    cls_subst_map = [v -> capt_cls_var(i) : v @ i <- cls_vars];

    capt_vars     = (eval_var(v, var_subst_map, surrs) : v <- ext_vars);
    capt_cls_vars = (lookup(cls_var_subst_map, v, v) : v <- cls_vars);

    args_env = [fn_arg(i) -> args_types(i) : i <- range(arity)];
    capt_env = [v -> env(v, !) : v <- ext_vars];
    new_env = args_env & capt_env;

    new_ctx = lambda_ctx(subst_map, cls_subst_map);
    let context = new_ctx, surrogates = [], typed_vars = []
      eval_code, surr, _ = opt_eval_code(expr, new_env, blank_var_gen);
    body = (eval_code | ret_val(surr));

    return lambda_expr(cls_def(arity, body), capt_context(context), capt_vars, capt_cls_vars);


    Maybe[DBSymbol] capt_context(Context ctx) =
      null_context  |
      function()    |
      procedure()   |
      automaton()   = nothing,
      data_base()   = just(ctx.name),
      lambda_ctx()  = capt_context(ctx.parent);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ObjExpr eval_var(Var var, [StdVar -> CaptVar] var_subst_map, [SurrExpr -> ObjExpr] surrogates) {
  // If a variable whose low-level representation is not a standard object
  // is captured, then it's stored in the array that contains the captured
  // variables in object form, and from that point on its surrogate is
  // not used anymore. In fact, the surrogate should not be passed down at
  // all when a closure is encountered
  assert not var_subst_map(var, _) or not surrogates(var, _);

  surr = if var_subst_map(var, _) then var_subst_map[var] else
         if surrogates(var, _)    then surrogates[var]    else
                                       var;
  return surr;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Instr+ store_result(Instr* code, ObjExpr surr_expr, AnyLocVar res_var) {
  def_code = (code | set_any_var(res_var, surr_expr));
  return def_code if code == ();
  trimmed_code = take(code, |code| - 1);

  return match (rat(code, 0))
    set_bvar()   i? |
    set_ivar()   i? |
    set_ivar32() i? | ## WHY DOES THIS EXPRESSION TYPECHECKS EVEN WITH AN Int32Var?
    set_fvar()   i? |
    set_var()    i? = if i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                        then (trimmed_code | set_any_var(res_var, obj_expr(i.value)))
                        else def_code,

    set_tvar()      = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT (LOW LEVEL TUPLES)

    call_proc()  i? = if i.var? and i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                                and low_level_repr(i.var) == low_level_repr(res_var)
                        then (trimmed_code | call_proc(res_var, i.name, i.args, i.cls_args))
                        else def_code,

    _               = def_code;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(AnyLocVar, VarGen) next_var(LowLevelRepr repr, VarGen gen) =
  bool        = next_bool_var(gen),
  int         = next_int_var(gen),
  float       = next_float_var(gen),
  tuple(as?)  = next_tuple_var(gen, as),
  symbol      |
  object      = next_obj_var(gen);

(LocOptTagRecVar, VarGen) next_var(OptTagRecRepr repr, VarGen gen) =
  next_opt_tag_rec_var(gen, repr.tag, repr.index);


Instr fake_init_var(LocBoolVar  var) = set_bvar(var, false);
Instr fake_init_var(LocIntVar   var) = set_ivar(var, 0);
Instr fake_init_var(LocFloatVar var) = set_fvar(var, float_lit((0), false, 0));

Instr fake_init_var(TupleVar var) = undefined; ## IMPLEMENT IMPLEMENT IMPLEMENT (LOW LEVEL TUPLES)

Instr fake_init_var(StdVar var) = undefined;

Instr fake_init_var(<LocVar, LocOptTagRecVar> var) = nullify_var(var);


Instr set_any_var(LocBoolVar  var, ObjExpr expr) = set_bvar(var, bool_value(expr));
Instr set_any_var(LocIntVar   var, ObjExpr expr) = set_ivar(var, get_int_val(expr));
Instr set_any_var(LocFloatVar var, ObjExpr expr) = set_fvar(var, float_value(expr));
Instr set_any_var(TupleVar    var, ObjExpr expr) = set_tvar(var, obj_to_tuple(var.repr, expr));
Instr set_any_var(WriteObjVar var, ObjExpr expr) = set_var(var, expr);
Instr set_any_var(LocOptTagRecVar var, ObjExpr expr) = set_var(var, expr);
