implicit program : Program, typedefs : [TypeName -> NeType], database : Database, options : CompOptions {
  StaticBlock compiled_database([RelVar -> [+Nat -> Nat]] rel_vars_args_perms) {
    methods = compiled_database_methods(database.methods);
    updates = compiled_database_updates(database.updates);
    handlers, exported_handlers = compiled_database_handlers(database.handlers);
    msg_types = [h.type : h <- database.handlers];
    msg_memb_pred = if msg_types != [] then just(memb_test_preds_map[ne_union_type(msg_types)]) else nothing;

    insert_checked_foreign_keys = [
      bk : k bk <- physical_foreign_keys_map, not insertion_is_statically_checked(k)
    ];
    delete_checked_foreign_keys = [
      bk : k bk <- physical_foreign_keys_map,
        not database.attr_map(only(k.target_rel_vars), k.source_rel_var) and not
        ( database.attr_map(k.source_rel_var, only(k.target_rel_vars)) and
          is_one_to_one_attribute(database.name, only(k.target_rel_vars))
        )
    ];

    memb_var_check_exprs = [
      v -> is_member(memb_test_preds_map(info.type, !), v) : v info <- database.state_vars
    ];

    return static_block(
      name:                         database.name,
      links:                        database.links,
      state_vars:                   [v -> info.type : v info <- database.state_vars],
      value_stores:                 value_stores,
      tables:                       tables_info,
      insert_checked_foreign_keys:  insert_checked_foreign_keys,
      delete_checked_foreign_keys:  delete_checked_foreign_keys,
      init_code:                    database_init_code,
      cleanup_code:                 database_cleanup_code,
      copy_state_code:              database_copy_state_code(rel_vars_args_perms),
      set_state_code:               database_set_state_code(rel_vars_args_perms),
      memb_var_check_exprs:         memb_var_check_exprs,
      rel_vars_load_code:           database_rel_vars_load_code(rel_vars_args_perms),
      foreign_keys_check_code:      database_foreign_keys_check_code,
      methods:                      methods,
      updates:                      handlers & updates,
      exported_handlers:            exported_handlers,
      msg_memb_pred:                msg_memb_pred
    );
  }


  Instr* database_init_code {
    state_vars = database.state_vars;

    vars_pre_init_code = rand_sort([init_memb_var(v, :blank) : v _ <- state_vars]);
    let context = database, typed_vars = [], surrogates = [] {
      vars_init_code = join(({
          eval_code, surr, _ = opt_eval_code(d.init_value, [], blank_var_gen);
          return (eval_code | set_var(v, surr));
        } : v, d <- isort(state_vars)
      ));
    }

    value_stores_init_code = (init_value_store(vs) : vs <- rand_sort(keys(value_stores)));
    tables_init_code = rand_sort([init_table(v, t) : v t <- tables_info]);

    return vars_pre_init_code & vars_init_code & value_stores_init_code & tables_init_code;
  }


  Instr* database_cleanup_code {
    state_vars = database.state_vars;

    vars_cleanup_code = rand_sort([reset_memb_var(v, :blank) : v _ <- state_vars]);
    value_stores_cleanup_code = (cleanup_value_store(vs) : vs <- rand_sort(keys(value_stores)));
    tables_cleanup_code = rand_sort([cleanup_table(v, t) : v t <- tables_info]);

    return vars_cleanup_code & value_stores_cleanup_code & tables_cleanup_code;
  }


  Instr* database_copy_state_code([RelVar -> [+Nat -> Nat]] rel_vars_args_perms) {
    log_rel_vars = [logical_rel_var(v) : v _ <- database.rel_vars];
    count = nat(|database.state_vars| + |log_rel_vars|);
    return (ret_val(empty_rel)) if count == 0;

    res_var, var_gen = next_obj_var(blank_var_gen);
    keys_var, var_gen = next_vector_var(var_gen, count);
    values_var, var_gen = next_vector_var(var_gen, count);

    state_vars = rand_sort(keys(database.state_vars));
    log_rel_vars = rand_sort(log_rel_vars);
    all_vars = state_vars & log_rel_vars;

    let context = database {
      code = join(({
        set_label_instr = set_var(evar(keys_var.id, i), object(bare_id(var)));
        value_var = evar(values_var.id, i);
        set_value_instr = match (var)
          memb_var()      = set_var(value_var, var),
          rel_var()       = { table_vars = [table_var(v) : v <- physical_rel_vars(database, var)];
                              tables = nonempty_map(select_by_key(tables_info, table_vars));
                              return copy_rel(value_var, tables, rel_vars_args_perms(var));
                            };
        return (set_label_instr, set_value_instr);
      } : var @ i <- all_vars));
    }

    return (code | mk_map(res_var, keys_var, values_var, count), ret_val(res_var));
  }


  [RelVar -> (LocVar+, BoolExpr, Instr+)] database_rel_vars_load_code([RelVar -> [+Nat -> Nat]] rel_vars_args_perms) {
    rel_auto_id = database.name;

    args_vars = (lvar(i) : i < 3);
    surr_vars = (ivar32(i) : i < 3);

    return [v -> {
      arity = arity(rel_auto_id, v);
      args_perm = rel_vars_args_perms(v);

      core_loop_code = if is_columnar_relvar(rel_auto_id, v) then
          column_core_loop_code(rel_auto_id, v, arity, args_vars, surr_vars(0))
        else if is_ternary_slave_column(rel_auto_id, v) then
          ternary_slave_column_core_loop_code(rel_auto_id, v, arity, args_vars, surr_vars, false)
        else
          table_core_loop_code(rel_auto_id, v, arity, args_vars, surr_vars);

      signatures = rel_var_signatures(database, v);

      arg_type_is_unique = ({
        types = [s(i) : s <- signatures];
        a_type = an_elem(types);
        return not (t <- types : not is_eq(t, a_type));
      } : i < arity);

      mono_args = ((i, an_elem([s(i) : s <- signatures])) : i < arity, arg_type_is_unique(i));
      args_types_conds = (is_member(memb_test_preds_map(t, !), args_vars(i)) : i, t <- mono_args);

      poly_args = (i : i < arity, not arg_type_is_unique(i));
      if poly_args != () {
        poly_conds = (
          and_then((is_member(memb_test_preds_map(s(i), !), args_vars(i))  : i <- poly_args))
        : s <- isort(signatures));
        args_types_conds = (args_types_conds | or_else(poly_conds));
      }

      type_check_expr = and_then(nonempty(args_types_conds));

      rel_args_vars = (args_vars(args_perm(i)) : i < arity);

      return (rel_args_vars, type_check_expr, nonempty(core_loop_code));
    } : v <- logical_rel_vars(database)];
  }


  Instr* table_core_loop_code(DBSymbol rel_auto_id, RelVar rel_var, NzNat arity, LocVar+ args_vars, Int32Var+ surr_vars) {
    // Physical tables the logical relation is partitioned into
    tables = [table_var(i) : i <- physical_rel_vars(database, rel_var)];

    if |tables| == 1 {
      table_var = only(tables);
      table_info = table_info(rel_auto_id, table_var);
      fail if not table_info :: AnySurrTable;

      stores_ids = (table_col_store_id(rel_auto_id, table_var, i) : i < arity);
      stores_types = (value_store_type(rel_auto_id, id) : id <- stores_ids);
      store_args = (value_store_encoded_expr(stores_types(i), args_vars(i)) : i < arity);

      store_inserts = (immediate_insert_or_add_ref(surr_vars(i), stores_ids(i), store_args(i)) : i < arity);
      table_insert = immediate_insert_tuple(table_var, table_info, nonempty(take(surr_vars, arity)));
      if arity == 2 {
        symmetric = symmetric(rel_auto_id, rel_var);
        guard_expr = neg(table_contains(table_var, table_info, (just(surr_vars(i)) : i < arity), symmetric));
        table_insert = do_if(guard_expr, table_insert);
      }
      core_loop_code = (store_inserts | table_insert);
    }
    else {
      // Choosing the dispatch arguments
      signatures = [table_signature(rel_auto_id, tv) : tv <- tables];
      disp_args_idxs = optimal_dispatch_args(signatures, typedefs);
      disp_args = (args_vars(i) : i <- disp_args_idxs);

      cases = [{
        table_info = table_info(rel_auto_id, tv);
        fail if not table_info :: AnySurrTable;

        stores_ids = (table_col_store_id(rel_auto_id, tv, i) : i < arity);
        stores_types = (value_store_type(rel_auto_id, id) : id <- stores_ids);
        store_args = (value_store_encoded_expr(stores_types(i), args_vars(i)) : i < arity);

        store_inserts = (
          immediate_insert_or_add_ref(surr_vars(i), stores_ids(i), store_args(i)) : i < arity
        );
        table_insert = immediate_insert_tuple(tv, table_info, nonempty(take(surr_vars, arity)));
        if arity == 2 {
          symmetric = symmetric(rel_auto_id, rel_var);
          guard_expr = neg(table_contains(tv, table_info, (just(surr_vars(i)) : i < arity), symmetric));
          table_insert = do_if(guard_expr, table_insert);
        }
        case_code = (store_inserts | table_insert, exit_block);

        types = table_signature(rel_auto_id, tv);
        disp_types = (types(i) : i <- disp_args_idxs);
        return (disp_types, case_code);
      } : tv <- tables];

      block_body = dynamic_dispatch_code(disp_args, cases);
      core_loop_code = (execute_block(block_body));
    }

    return core_loop_code;
  }



  Instr* ternary_slave_column_core_loop_code(DBSymbol rel_auto_id, RelVar rel_var, NzNat arity, LocVar+ args_vars, Int32Var+ surr_vars, Bool ordered) {
    // Physical tables the logical relation is partitioned into
    tables = [table_var(i) : i <- physical_rel_vars(database, rel_var)];

    if |tables| == 1 {
      core_loop_code = table_var_code(rel_auto_id, only(tables), args_vars, surr_vars, ordered);
    }
    else {
      // Choosing the dispatch arguments
      signatures = [table_signature(rel_auto_id, tv) : tv <- tables];
      disp_args_idxs = optimal_dispatch_args(signatures, typedefs);
      disp_args = (args_vars(i) : i <- disp_args_idxs);

      cases = [{
        case_code = (table_var_code(rel_auto_id, tv, args_vars, surr_vars, ordered) | exit_block);
        types = table_signature(rel_auto_id, tv);
        disp_types = (types(i) : i <- disp_args_idxs);
        return (disp_types, case_code);
      } : tv <- tables];

      block_body = dynamic_dispatch_code(disp_args, cases);
      core_loop_code = (execute_block(block_body));
    }

    return core_loop_code;


    Instr+ table_var_code(DBSymbol rel_auto_id, TableVar table_var, LocVar+ args_vars, Int32Var+ surr_vars, Bool ordered) {
      master_table = master_table(rel_auto_id, table_var);
      master_table_type = table_info(rel_auto_id, master_table);
      fail if not master_table_type :: MasterBinTable;

      store_id_0 = table_col_store_id(rel_auto_id, table_var, 0);
      store_id_1 = table_col_store_id(rel_auto_id, table_var, 1);
      store_type_0 = value_store_type(rel_auto_id, store_id_0);
      store_type_1 = value_store_type(rel_auto_id, store_id_1);
      store_arg_0 = value_store_encoded_expr(store_type_0, args_vars(0));
      store_arg_1 = value_store_encoded_expr(store_type_1, args_vars(1));
      col_repr = column_repr(table_signature(rel_auto_id, table_var)(2));
      actual_surr_vars = (surr_vars(0), surr_vars(1));
      idx_var = surr_vars(2);
      return (
        immediate_insert_or_add_ref(surr_vars(0), store_id_0, store_arg_0),
        immediate_insert_or_add_ref(surr_vars(1), store_id_1, store_arg_1),
        do_if_not(
          table_contains(master_table, master_table_type, (just(v) : v <- actual_surr_vars), false),
          immediate_insert_tuple(master_table, master_table_type, actual_surr_vars)
        ) if not ordered,
        set_ivar32(idx_var, get_assoc_surr(master_table, actual_surr_vars)),
        column_insert_immediate(table_var, idx_var, low_level_expr(col_repr, args_vars(2)))
      );
    }
  }


  Instr* column_core_loop_code(DBSymbol rel_auto_id, RelVar rel_var, NzNat arity, LocVar+ args_vars, Int32Var key_surr_var) {
    // Physical tables the logical relation is partitioned into
    tables = [table_var(i) : i <- physical_rel_vars(database, rel_var)];

    if |tables| == 1 {
      table_var = only(tables);
      store_id = table_col_store_id(rel_auto_id, table_var, 0);
      store_type = value_store_type(rel_auto_id, store_id);
      store_arg = value_store_encoded_expr(store_type, args_vars(0));
      col_repr = column_repr(table_signature(rel_auto_id, table_var)(1));
      core_loop_code = (
        immediate_insert_or_add_ref(key_surr_var, store_id, store_arg),
        column_insert_immediate(table_var, key_surr_var, low_level_expr(col_repr, args_vars(1)))
      );
    }
    else {
      // Choosing the dispatch arguments
      signatures = [table_signature(rel_auto_id, tv) : tv <- tables];
      disp_args_idxs = optimal_dispatch_args(signatures, typedefs);
      disp_args = (args_vars(i) : i <- disp_args_idxs);

      cases = [{
        store_id = table_col_store_id(rel_auto_id, tv, 0);
        store_type = value_store_type(rel_auto_id, store_id);
        store_arg = value_store_encoded_expr(store_type, args_vars(0));
        col_repr = column_repr(table_signature(rel_auto_id, tv)(1));
        case_code = (
          immediate_insert_or_add_ref(key_surr_var, store_id, store_arg),
          column_insert_immediate(tv, key_surr_var, low_level_expr(col_repr, args_vars(1))),
          exit_block
        );
        types = table_signature(rel_auto_id, tv);
        disp_types = (types(i) : i <- disp_args_idxs);
        return (disp_types, case_code);
      } : tv <- tables];

      block_body = dynamic_dispatch_code(disp_args, cases);
      core_loop_code = (execute_block(block_body));
    }

    return core_loop_code;
  }


  Instr* database_set_state_code([RelVar -> [+Nat -> Nat]] rel_vars_args_perms) {
    rel_auto_id = database.name;

    state_var = fn_arg(0);
    tmp_var = lvar(0);
    bool_var = bvar(0);
    args_vars = (lvar(nat(i+1)) : i < 3);
    surr_vars = (ivar32(i) : i < 3);
    it_vars = [1 -> set_it_var(0), 2 -> bin_rel_it_var(0), 3 -> tern_rel_it_var(0)];

    code = (
      do_if(is_eq(state_var, empty_rel), ret_val(true)),
      do_if(neg(is_ne_bin_rel(state_var)), ret_val(false))
    );

    // Member variables
    for v, info <- isort(database.state_vars) {
      pred = memb_test_preds_map(info.type, !);
      instr = do_if(
        has_field(state_var, object(bare_id(v))),
        ( // lookup_field(v, state_var, object(bare_id(v)))  ## REFERENCE COUNTING BUG HERE...
          lookup_field(tmp_var, state_var, object(bare_id(v))),
          do_if_not(is_member(pred, tmp_var), ret_val(false)),
          set_var(v, tmp_var)
        )
      );
      code = (code | instr);
    }

    // Mutable relation variables
    ord_rel_vars = sort_by_key(logical_rel_vars(database), arity(rel_auto_id, $));
    for v <- ord_rel_vars {
      arity = arity(rel_auto_id, v);
      args_perm = rel_vars_args_perms(v);
      // phys_args_vars = (log_args_vars(args_perm(i)) : i < arity);
      it_var = it_vars[arity]; // Need to use [] instead of () because of the typechecker...

      core_loop_code = if is_columnar_relvar(rel_auto_id, v) then
          column_core_loop_code(rel_auto_id, v, arity, args_vars, surr_vars(0))
        else if is_ternary_slave_column(rel_auto_id, v) then
          ternary_slave_column_core_loop_code(rel_auto_id, v, arity, args_vars, surr_vars, true)
        else
          table_core_loop_code(rel_auto_id, v, arity, args_vars, surr_vars);

      signatures = rel_var_signatures(database, v);

      arg_type_is_unique = ({
        types = [s(i) : s <- signatures];
        a_type = an_elem(types);
        return not (t <- types : not is_eq(t, a_type));
      } : i < arity);

      mono_args = ((i, an_elem([s(i) : s <- signatures])) : i < arity, arg_type_is_unique(i));
      args_types_conds = (is_member(memb_test_preds_map(t, !), args_vars(i)) : i, t <- mono_args);

      poly_args = (i : i < arity, not arg_type_is_unique(i));
      if poly_args != () {
        poly_conds = (
          and_then((is_member(memb_test_preds_map(s(i), !), args_vars(i))  : i <- poly_args))
        : s <- isort(signatures));
        args_types_conds = (args_types_conds | or_else(poly_conds));
      }

      core_loop_code = (do_if_not(and_then(nonempty(args_types_conds)), ret_val(false))) & core_loop_code;

      loop_body = (break_if(is_out_of_range(it_var))) &
                  (get_curr_arg(args_vars(args_perm(i)), it_var, i) : i < arity) &
                  core_loop_code & (move_forward(it_var));

      rel_check_cond = match (arity)
        1   = is_ne_set(tmp_var),
        2   = is_ne_bin_rel(tmp_var),
        3   = is_ne_tern_rel(tmp_var);
      rel_check_cond = or_else((is_eq(tmp_var, empty_rel), rel_check_cond));

      instr = do_if(
        has_field(state_var, object(bare_id(v))),
        ( lookup_field(tmp_var, state_var, object(bare_id(v))),
          do_if(neg(rel_check_cond), ret_val(false)),
          get_any_rel_iter(it_var, tmp_var, (nothing : i < arity)),
          repeat(loop_body)
        )
      );

      code = (code | instr);
    }

    return (code | ret_val(true));
  }


  Instr* database_foreign_keys_check_code {
    rel_auto_id = database.name;

    phys_keys_by_table = group_by(physical_foreign_keys, $.origin);
    tables = sort_by_key(keys(phys_keys_by_table), arity(rel_auto_id, original_rel_var($)));

    code = ();
    for tv <- tables {
      rel_var = original_rel_var(tv);
      arity = arity(rel_auto_id, rel_var);
      src_is_sym = symmetric(rel_auto_id, rel_var);

      surr_vars = (ivar32(i) : i < 3);
      assoc_surr_var = ivar32(3);

      foreign_keys = lookup(phys_keys_by_table, tv, []);
      assert not (fk <- foreign_keys : fk.origin != tv);

      sign = table_signature(rel_auto_id, tv);

      it_var = if is_columnar_relvar(rel_auto_id, logical_rel_var(rel_var)) then
          column_it_var(0, column_repr(sign(1)))
        else if is_ternary_slave_column(rel_auto_id, logical_rel_var(rel_var)) then
          slave_column_it_var(0, column_repr(sign(2)))
        else table_it_var(0, arity, src_is_sym);

      if foreign_keys != [] {
        conds = ({
          target_table_info = table_info(rel_auto_id, fk.target);

          if fk.type == :binary_ternary and is_ternary_slave_column(rel_auto_id, logical_rel_var(original_rel_var(fk.target)))
            return table_contains(fk.target, target_table_info, (just(assoc_surr_var), nothing), false);

          tgt_is_sym, args_sets = match (fk.type)
            unary_unary             = (false, ((just(0)))),
            unary_binary(i?)        = (false, ((maybe(0, j == i) : j < 2))),
            unary_ternary(i?)       = (false, ((maybe(0, j == i) : j < 3))),
            binary_unary(i?)        = (false, ((just(i)))),
            ternary_unary(i?)       = (false, ((just(i)))),
            binary_ternary          = (false, ((just(0), just(1), nothing))),
            ternary_binary          = (false, ((just(0), just(1)))),
            unary_sym_binary        = (true,  ((just(0), nothing))),
            unary_sym_ternary_12    = (true,  ((just(0), nothing, nothing))),
            unary_sym_ternary_3     = (true,  ((nothing, nothing, just(0)))),
            sym_binary_unary        = (true,  ((just(0)), (just(1)))),
            sym_ternary_unary_12    = (true,  ((just(0)), (just(1)))),
            sym_ternary_unary_3     = (true,  ((just(2)))), ## NOT AT ALL SURE ABOUT THIS ONE
            sym_binary_sym_ternary  = (true,  ((just(0), just(1), nothing))),
            sym_ternary_sym_binary  = (true,  ((just(0), just(1))));
          return and(
            (table_contains(fk.target, target_table_info, (apply(a, surr_vars($)) : a <- as), tgt_is_sym) : as <- args_sets)
          );
        } : fk <- isort(foreign_keys));

        cond = or((neg(c) : c <- conds));

        surr_vars_used = isort(union([
          match (fk.type)
            unary_unary             = [0],
            unary_binary(i?)        = [0],
            unary_ternary(i?)       = [0],
            binary_unary(i?)        = [i],
            ternary_unary(i?)       = [i],
            binary_ternary          = [0, 1],
            ternary_binary          = [0, 1],
            unary_sym_binary        = [0],
            unary_sym_ternary_12    = [0],
            unary_sym_ternary_3     = [2],
            sym_binary_unary        = [0, 1],
            sym_ternary_unary_12    = [0, 1],
            sym_ternary_unary_3     = [2],
            sym_binary_sym_ternary  = [0, 1],
            sym_ternary_sym_binary  = [0, 1]
          : fk <- foreign_keys
        ]));

        assert match (it_var)
          table_it_var()        = true,
          column_it_var()       = surr_vars_used == (0),
          slave_column_it_var() = surr_vars_used == (0, 1) or surr_vars_used == (0) or surr_vars_used == (1); ## NOT AT ALL SURE HERE. WHAT IS THIS ASSERTION FOR ANYWAY?

        surrs_reads = match (it_var)
          table_it_var()        = (set_ivar32(surr_vars(i), get_unknown_arg(it_var, i)) : i <- surr_vars_used),
          column_it_var()       = (set_ivar32(surr_vars(0), get_unknown_arg(it_var, 0))),
          ## ISN'T THIS TOTALLY POINTLESS IF THE TARGET TABLE IS ALSO THE MASTER ONE?
          ## AND CAN THE TARGET TABLE BE ANYTHING OTHER THAN THE MASTER?
          slave_column_it_var() = { master = master_table(rel_auto_id, tv);
                                    return (
                                      set_ivar32(assoc_surr_var, get_unknown_arg(it_var, 0)),
                                      set_ivar32(surr_vars(0), get_arg_by_assoc_surr(master, 0, assoc_surr_var)),
                                      set_ivar32(surr_vars(1), get_arg_by_assoc_surr(master, 1, assoc_surr_var))
                                    );
                                  };

        if (fk <- foreign_keys : fk.type == :binary_ternary and is_ternary_slave_column(rel_auto_id, logical_rel_var(original_rel_var(fk.target)))) {
          assoc_surr_var_read = set_ivar32(assoc_surr_var, get_assoc_surr(tv, (surr_vars(0), surr_vars(1))));
          surrs_reads = (surrs_reads | assoc_surr_var_read);
        }

        get_iter_instr = match (it_var)
          table_it_var()        |
          slave_column_it_var() = get_table_iter(it_var, tv, (nothing : i < arity)),
          column_it_var()       = get_column_iter(it_var, tv);

        code = (code |
          get_iter_instr,
          repeat((
            break_if(is_out_of_range(it_var))
          ) & surrs_reads & (
            do_if(cond, ret_val(false)),
            move_forward(it_var)
          ))
        );
      }
    }

    return code;
  }


  [MethodId -> OptCompMethod] compiled_database_methods([Method] methods) {
    return merge([compiled(ms) : _ ms <- group_by(methods, family_id($.id))]);


    [MethodId -> OptCompMethod] compiled([+Method] methods) {
      comp_methods = [m.id -> compiled(m) : m <- methods];
      if |methods| > 1 {
        id = only([family_id(m.id) : m <- methods]);
        comp_methods = comp_methods & [id -> dispatch_method(methods)];
      }
      return comp_methods;
    }


    OptCompMethod dispatch_method([+Method] methods) {
      assert |methods| > 1;
      assert |[m.id.symbol : m <- methods]| == 1;
      assert |[|m.args| : m <- methods]| == 1; // All functions have the same arity
      assert only([|m.args| : m <- methods]) > 0;

      count = |methods|;

      disp_args = choose_disp_args((nonempty(left(unzip(m.args))) : m <- isort(methods)), program.typedefs);

      low_level_signs = [m.id -> low_level_sign(m) : m <- methods];
      aggr_sign = aggr_sign([s : _ s <- low_level_signs]);

      args = (low_level_arg(fn_arg(i), r) : r @ i <- aggr_sign.args);

      aggr_ret_var, _ = next_var(aggr_sign.ret_value, blank_var_gen);

      cases = [{
        types = (left(m.args(i)) : i <- disp_args);
        sign = low_level_signs(m.id);
        call_args = (low_level_expr(r, obj_expr(args(j))) : r @ j <- sign.args);
        // We can reuse the same seed to generate variables
        ret_var, _ = next_var(sign.ret_value, blank_var_gen);
        code = (
          invoke_db_method(ret_var, database.name, m.id, call_args),
          ## THESE TWO INSTRUCTIONS SHOULD BE MERGED
          set_any_var(aggr_ret_var, obj_expr(ret_var)) if ret_var != aggr_ret_var,
          ret_val(aggr_ret_var)
        );
        return (types, code);
      } : m <- methods];

      body = dynamic_dispatch_code((fn_arg(i) : i <- disp_args), cases);

      return opt_comp_method(
        args:             args,
        args_types:       (ne_union_superset([left(m.args(i)) : m <- methods]) : i < |args|),
        args_memb_preds:  [(memb_test_preds_map[t] : t, _ <- m.args) : m <- methods],
        loc_vars_types:   [],
        ret_type:         ne_union_superset([m.ret_type : m <- methods]),
        ret_val_repr:     aggr_sign.ret_value,
        body:             body
      );
    }


    OptCompMethod compiled(Method method) {
      vars = (if v != nothing then value(v) else fn_arg(i) : t, v @ i <- method.args);
      args = (low_level_arg(vars(i), fn_arg_low_level_repr(t)) : t, _ @ i <- method.args);
      args_surrs = [vars(i) -> obj_expr(a) : a @ i <- args];

      env = [v -> left(method.args(i)) : v @ i <- vars];

      ret_val_repr = opt_repr(method.ret_type);

      let context = database, surrogates = args_surrs, typed_vars = [] {
        body, ret_val_surr, _ = match (method.expr)
          do_expr() = do_expr_opt_eval_code(method.expr, ret_val_repr, env, blank_var_gen),
          _         = opt_eval_code(method.expr, env, blank_var_gen);
      }

      // Adding push_call_info/pop_call_info debug mode instructions
      if options.debug_mode
        body = (push_call_info(method.id.symbol, (obj_expr(v) : v <- args))) & body & (pop_call_info);

      body = (body | ret_val(low_level_expr(ret_val_repr, ret_val_surr)));

      loc_vars_types = match (method.expr)
        do_expr() = method.expr.typed_vars,
        _         = [];

      return opt_comp_method(
        args:             args,
        args_types:       left(unzip(method.args)),
        args_memb_preds:  [(memb_test_preds_map[t] : t, _ <- method.args)],
        loc_vars_types:   loc_vars_types,
        ret_type:         method.ret_type,
        ret_val_repr:     ret_val_repr,
        body:             body
      );
    }
  }


  [UpdateId -> CompiledUpdate] compiled_database_updates([Update] updates) {
    return merge([compiled_updates(ms) : _ ms <- group_by(updates, ($.name, |$.args|))]);


    [UpdateId -> CompiledUpdate] compiled_updates([+Update] updates) {
      an_update = an_elem(updates);
      name = an_update.name;
      arity = |an_update.args|;
      return [update_id(name, arity) -> compiled_update(an_update)] if |updates| == 1;
      sorted_updates = rand_sort(updates);
      comp_updates = merge(([update_id(m.name, arity, i) -> compiled_update(m)] : m @ i <- sorted_updates));
      dispatcher_code = update_dispatch_code(database.name, sorted_updates);
      dispatcher = compiled_update((fn_arg(i) : i < arity), dispatcher_code);
      return comp_updates & [update_id(name, arity) -> dispatcher];
    }


    CompiledUpdate compiled_update(Update update) =
      compiled_update((v : _, v <- update.args), update_body(update));


    Instr* update_body(Update update) {
      // Compiling the body of the update
      return () if update.body == ();

      code, _, _, _ = stmts_opt_code(
        update.body,
        [v -> t : (t, v) <- update.args],
        blank_var_gen,
        context           = database,
        typed_vars        = [],
        surrogates        = [],
        exp_break_surrs   = nothing,
        result_var        = :invalid_var
      );

      return (execute_block(nonempty(code)));
    }
  }


  ([UpdateId -> CompiledUpdate], [UpdateId, HandlerWrapper]) compiled_database_handlers([Handler] handlers) {
    return ([], []) if handlers == [];
    sorted_handlers = rand_sort(handlers);
    comp_handlers = merge(([handler_id(i) -> compiled_handler(h)] : h @ i <- sorted_handlers));
    exported_handlers = [handler_id(i), interface : h @ i <- sorted_handlers, interface <- interfaces(h)];
    dispatcher_body = if |handlers| != 1
      then update_dispatch_code(database.name, sorted_handlers)
      else (try_update(database.name, polymorphic_update_id(only(handlers), 0), (fn_arg(0))), ret_val(0));
    dispatcher = compiled_update((fn_arg(0)), dispatcher_body);
    return (comp_handlers & [main_handler -> dispatcher], exported_handlers);


    [HandlerWrapper] interfaces(Handler handler) {
      if is_symb_singl_type(handler.type) {
        symb = only_symb(handler.type);
        wrapper = handler_wrapper(
          tag:            symb,
          args:           (),
          msg_inst_code:  (),
          msg_expr:       symb
        );
        return [wrapper];
      }

      res = destructured_tagged_record(handler.type);
      if res != nothing {
        tag, fields, optional = value(res);
        if |fields| == 1 or handler.fields_order? {
          // Calculating the final order of the arguments
          fields_order = if handler.fields_order?
            then (s : s <- handler.fields_order, not optional(object(s))) &
                 (s : s <- handler.fields_order, optional(object(s)))
            else (_untag_(only(keys(fields))));

          cond_vars = [l -> hidden_var(i) : l @ i <- isort(optional)];

          ord_fields = ({
            field_symb = object(l);
            field_type = fields(field_symb);
            return (
              field_type,
              var(l),
              if optional(field_symb)
                then just(bvar(bare_id(cond_vars(field_symb))))
                else nothing,
              memb_test_preds_map(field_type, !)
            );
          } : l @ i <- fields_order);

          rec_expr = map_expr([(
              key:   l,
              value: var(s),
              cond:  cond_vars(l) if optional(l)
            ) : l t <- fields, s = _untag_(l)
          ]);
          inst_expr = tag_obj_expr(tag, rec_expr);

          env = [var(_untag_(l)) -> t : l t <- fields] & [cond_vars(l) -> type_bool : l <- optional];
          surrs = [cond_vars(l) -> obj_expr(bvar(bare_id(cond_vars(l)))) : l <- optional];

          let context = database, surrogates = surrs, typed_vars = [] {
            code, surr, _ = opt_eval_code(inst_expr, env, blank_var_gen);
          }

          wrapper = handler_wrapper(
            tag:            tag,
            args:           ord_fields,
            msg_inst_code:  code,
            msg_expr:       surr
          );

          return [wrapper];
        }
      }

      res = destructured_tagged_tuple(handler.type);
      if res != nothing {
        tag, fields_types = value(res);
        fields = ((t, hidden_var(i), nothing, memb_test_preds_map(t, !)) : t @ i <- fields_types);

        tuple_expr = seq_expr((hidden_var(i) : i < |fields_types|));
        inst_expr = tag_obj_expr(tag, tuple_expr);

        env = [hidden_var(i) -> t : t @ i <- fields_types];
        let context = database, surrogates = [], typed_vars = [] {
          code, surr, _ = opt_eval_code(inst_expr, env, blank_var_gen);
        }

        wrapper = handler_wrapper(
          tag:            tag,
          args:           fields,
          msg_inst_code:  code,
          msg_expr:       surr
        );

        return [wrapper];
      }

      res = destructured_tagged_value(handler.type);
      if res != nothing {
        tag, inner_type = value(res);

        inner_var = hidden_var(0);
        field = (inner_type, inner_var, nothing, memb_test_preds_map(inner_type, !));

        inst_expr = tag_obj_expr(tag, inner_var);

        env = [inner_var -> inner_type];
        let context = database, surrogates = [], typed_vars = [] {
          code, surr, _ = opt_eval_code(inst_expr, env, blank_var_gen);
        }

        wrapper = handler_wrapper(
          tag:            tag,
          args:           (field),
          msg_inst_code:  code,
          msg_expr:       surr
        );

        return [wrapper];
      }

      return [];
    }


    CompiledUpdate compiled_handler(Handler handler) = compiled_update((var(:this)), handler_body(handler));


    Instr* handler_body(Handler handler) {
      // Compiling the body of the handler
      return () if handler.body == ();

      code, _, _, _ = stmts_opt_code(
        handler.body,
        [var(:this) -> handler.type],
        blank_var_gen,
        context           = database,
        typed_vars        = [],
        surrogates        = [],
        exp_break_surrs   = nothing,
        result_var        = :invalid_var
      );

      return (execute_block(nonempty(code)));
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType], database : Database {
  [ForeignKey -> BlockForeignKey] physical_foreign_keys_map = [
    k -> foreign_key(table_var(k.source_rel_var), table_var(only(k.target_rel_vars)), foreign_key_type(k))
    : k <- database.foreign_keys
  ];


  [BlockForeignKey] physical_foreign_keys = values(physical_foreign_keys_map);


  ForeignKeyType foreign_key_type(ForeignKey key) {
    origin_args = key.source_args;
    target_args = key.target_args;

    origin_symmetric = symmetric(database.name, key.source_rel_var);
    target_symmetric = symmetric(database.name, only(key.target_rel_vars));

    assert match (origin_args, target_args)
      (just(s1?)),              (just(s2?))                     = s1 == s2,
      (just(s1?)),              (just(s2?), nothing)            = s1 == s2,
      (just(s1?)),              (nothing, just(s2?))            = s1 == s2,
      (just(s1?)),              (just(s2?), nothing, nothing)   = s1 == s2,
      (just(s1?)),              (nothing, just(s2?), nothing)   = s1 == s2,
      (just(s1?)),              (nothing, nothing, just(s2?))   = s1 == s2,

      (just(s1?), nothing),     (just(s2?))                     = s1 == s2,
      (nothing, just(s1?)),     (just(s2?))                     = s1 == s2,
      (just(s1?), just(s2?)),   (just(s3?), just(s4?), nothing) = s1 != s2 and s1 == s3 and s2 == s4,

      (_, _, _) as?,            (t?)                            = { las = (a : a <- as, a != nothing);
                                                                    return |las| == 1 and only(las) == t;
                                                                  },
      (just(s1?), just(s2?), nothing),  (just(s3?), just(s4?))  = s1 != s2 and s1 == s3 and s2 == s4,

      _,                        _                               = false;

    assert match (origin_args, target_args)
      (_),        (_, _)      = not origin_symmetric,
      (_),        (_, _, _)   = not origin_symmetric,
      (_, _),     (_)         = not target_symmetric,
      (_, _, _),  (_)         = not target_symmetric,
      (_, _),     (_, _, _)   = origin_symmetric == target_symmetric,
      (_, _, _),  (_, _)      = origin_symmetric == target_symmetric,
      _,          _           = not origin_symmetric and not target_symmetric;

    if origin_symmetric or target_symmetric {
      key_type = match (origin_args, target_args)
        (_),                        (_, _)                      = :unary_sym_binary,
        (_),                        (nothing, nothing, just())  = :unary_sym_ternary_3,
        (_),                        (_, _, _)                   = :unary_sym_ternary_12,
        (_, _),                     (_)                         = :sym_binary_unary,
        (nothing, nothing, just()), (_)                         = :sym_ternary_unary_3,
        (_, _, _),                  (_)                         = :sym_ternary_unary_12,
        (_, _),                     (_, _, _)                   = :sym_binary_sym_ternary,
        (_, _, _),                  (_, _)                      = :sym_ternary_sym_binary;
    }
    else {
      key_type = match (origin_args, target_args)
        (just()),           (just())          = :unary_unary,
        (just()),           (just(), nothing) = unary_binary(0),
        (just()),           (nothing, just()) = unary_binary(1),
        (just()),           (_, _, _) as?     = unary_ternary(only_unsafe((i : a @ i <- as, a != nothing))),

        (just(),  nothing), (just())          = binary_unary(0),
        (nothing, just()),  (just())          = binary_unary(1),
        (just(),  just()),  (_, _, _)         = :binary_ternary,

        (_, _, _) oas?,     (just() ta?)      = ternary_unary(only_unsafe((i : a @ i <- oas, a == ta))),
        (_, _, _),          (_, _)            = :ternary_binary;
    }

    return key_type;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[[+(TableVar, Nat)]] column_clusters([TableVar, NzNat, Bool] tables, [BlockForeignKey] foreign_keys) {
  init_clusters = union([associations(k) : k <- foreign_keys]) &
                  [[(v, 0), (v, 1)] : v _ s <- tables, s];
  non_trivial_clusters = merge_intersecting(init_clusters);
  all_cols = [(r, i) : r a _ <- tables, i <- (i : i < a)];
  rem_cols = all_cols - union(non_trivial_clusters);
  final_clusters = non_trivial_clusters & [[c] : c <- rem_cols];
  assert union(final_clusters) == all_cols;
  return final_clusters;


  [[+(TableVar, Nat)]] associations(BlockForeignKey foreign_key) {
    idx_assocs = match (foreign_key.type)
      unary_unary             = [0 -> 0],
      unary_binary(i?)        |
      unary_ternary(i?)       = [0 -> i],
      binary_unary(i?)        |
      ternary_unary(i?)       = [i -> 0],
      binary_ternary          |
      ternary_binary          = [0 -> 0, 1 -> 1],

      sym_ternary_unary_3     = [2 -> 0],
      unary_sym_ternary_3     = [0 -> 2],

      // Relying on the fact that symmetric columns share the same value store
      unary_sym_binary        |
      unary_sym_ternary_12    |
      sym_binary_unary        |
      sym_ternary_unary_12    |
      sym_binary_sym_ternary  |
      sym_ternary_sym_binary  = [0 -> 0];

    return [[(foreign_key.origin, i), (foreign_key.target, j)] : i j <- idx_assocs];
  }
}


implicit program : Program, typedefs : [TypeName -> NeType], database : Database { ## program IS NOT REALLY NEEDED, BUT THE TYPECHECKER...
  [ValueStoreId -> ValueStoreType] value_stores = [
    vs -> {
      cols = nonempty([c : c <- table_col_value_store_map(?, vs)]);
      // types = [database.rel_vars(_untag_(left(c))).signature(right(c)) : c <- cols];
      ## WORKAROUND FOR COMPILER BUG IN VERSION 0.1 (IS IT GONE IN 0.3?)
      ## THE COMMENTED OUT VERSION ABOVE DOES NOT WORK
      types = [database.rel_vars(rv).signature(idx) : c <- cols, rv = untag(left(c)), idx = right(c)];
      return value_store_type(ne_union_superset(types));
    } : vs <- values(table_col_value_store_map)
  ];


  [(TableVar, Nat) -> ValueStoreId] table_col_value_store_map {
    auto_id = database.name;
    table_vars = [table_var(r), arity(auto_id, r), info.symmetric : r info <- database.rel_vars];
    clusters = column_clusters(table_vars, physical_foreign_keys);
    ord_clusters = isort(clusters);
    return [c -> value_store_id(i) : cs @ i <- ord_clusters, c <- cs];
  }


  [TableVar -> AnyTable] tables_info {
    auto_id = database.name;
    col_to_vs_map = table_col_value_store_map;
    return [
      tv -> {
        if is_columnar_relvar(auto_id, logical_rel_var(rv)) {
          value_store = col_to_vs_map((tv, 0));
          signature = info.signature;
          fail if |signature| != 2;
          return column(value_store, column_repr(signature(1)), signature);
        }
        else if is_ternary_slave_column(auto_id, logical_rel_var(rv)) {
          masters_slaves = masters_ternary_slave_columns;
          master = table_var(masters_slaves(auto_id, !, rv));
          value_stores = (col_to_vs_map((tv, i)) : i <- (0, 1));
          signature = info.signature;
          fail if |signature| != 3;
          return slave_column(master, value_stores, column_repr(signature(2)), signature);
        }
        else if is_master_relvar(auto_id, rv) {
          signature = info.signature;
          fail if |signature| != 2;
          return master_bin_table(
            (col_to_vs_map((tv, i)) : i <- (0, 1)),
            info.keys,
            signature,
            info.symmetric
          );
        }
        else if is_slave_relvar(auto_id, rv) {
          signature = info.signature;
          fail if |signature| != 3;
          return slave_tern_table(
            table_var(master_relvar(auto_id, rv)),
            (col_to_vs_map((tv, i)) : i <- (0, 1, 2)),
            info.keys,
            signature,
            info.symmetric
          );
        }
        else {
          value_stores = (col_to_vs_map((tv, i)) : i < |info.signature|);
          return table(value_stores, info.keys, info.signature, info.symmetric);
        }
      } : rv info <- database.rel_vars, tv = table_var(rv)
    ];
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  // ## THIS IS AN ALMOST PERFECT DUPLICATE OF gen_dispatch_auto_method_body().
  // Instr* method_dispatch_code(DBSymbol db_type, Method+ methods) {
  //   assert |methods| > 1;
  //   assert |[m.name : m <- methods]| == 1;    // All methods must have the same name
  //   assert |[|m.args| : m <- methods]| == 1;  // All methods have the same arity
  //   assert |head(methods).args| > 0;          // No-argument methods cannot be polymorphic


  //   l0 = lvar(0);
  //   count = |methods|;

  //   a_method  = head(methods);
  //   name      = a_method.name;
  //   arity     = |a_method.args|;

  //   disp_args = choose_disp_args(((t : t, _ <- nonempty(m.args)) : m <- methods), typedefs);

  //   cases = [{
  //     types = (left(m.args(j)) : j <- disp_args);
  //     invoke_method_instr = invoke_db_method(l0, db_type, method_id(name, arity, i), (fn_arg(j) : j < arity));
  //     code = (invoke_method_instr, ret_val(l0));
  //     return (types, code);
  //   } : m @ i <- methods];

  //   code = dynamic_dispatch_code((fn_arg(i) : i <- disp_args), cases);
  //   return (code | ret_val(l0));
  // }


  Instr* update_dispatch_code(DBSymbol db_type, <Update+, Handler+> updates) {
    assert |updates| > 1;
    assert |[name(u) : u <- updates]| == 1;   // All updates must have the same name
    assert |[arity(u) : u <- updates]| == 1;  // All updates have the same arity
    assert arity(head(updates)) > 0;          // No-argument updates cannot be polymorphic

    i0 = ivar32(0);
    count = |updates|;

    an_update = head(updates);
    name      = name(an_update);
    arity     = arity(an_update);

    are_handlers = match (an_update)
      handler() = true,
      update()  = false;

    args_types = (
      match (u)
        update()  = (t : t, _ <- nonempty(u.args)),
        handler() = (u.type)
      : u <- updates
    );

    disp_args = choose_disp_args(args_types, typedefs);

    cases = [{
      types = (args_types(i)(j) : j <- disp_args);
      try_update_instr = try_update(db_type, polymorphic_update_id(u, i), (fn_arg(j) : j < arity));
      code = (try_update_instr, set_ivar32(i0, int32(i)) if are_handlers, exit_block);
      return (types, code);
    } : u @ i <- updates];

    code = dynamic_dispatch_code((fn_arg(i) : i <- disp_args), cases);
    return (execute_block(code), ret_val(i0) if are_handlers);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  ValueStoreType value_store_type(NeType type) {
    return :integer if is_subset(type, integer);

    tag_int_type = mono_tagged_integer(type);
    return value(tag_int_type) if tag_int_type != nothing;

    return :object;


    Maybe[<mono_tagged_integer(Symbol)>] mono_tagged_integer(NeType type) =
      tag_obj_type()  = if type.tag_type :: SymbType and is_subset(type.obj_type, integer)
                          then just(:mono_tagged_integer(untag(untag(type.tag_type))))
                          else nothing,
      union_type(ts?) = { maybe_types = [mono_tagged_integer(t) : t <- ts];
                          if maybe_types :: [+Just[<mono_tagged_integer(Symbol)>]] {
                            types = [value(t) : t <- maybe_types];
                            return just(only(types)) if |types| == 1;
                          }
                          return nothing;
                        },
      type_ref(ts?)   = mono_tagged_integer(nonempty_type(expand_type_ref(ts, typedefs))),
      _               = nothing;
  }

  ColumnRepr column_repr(NeType type) =
    if is_subset(type, integer)     then :int     else
    if is_subset(type, float_type)  then :float   else
                                         :object;
}

////////////////////////////////////////////////////////////////////////////////

Maybe[UpdateSymbol] name(<Update, Handler>) =
  update() u?   = just(u.name),
  handler()     = nothing;

NeType* arg_types(<Update, Handler>) =
  update() u?   = (t : t, _ <- u.args),
  handler() h?  = (h.type);

UpdateId polymorphic_update_id(<Update, Handler>, Nat idx) =
  update() u?   = update_id(u.name, arity(u), idx),
  handler() h?  = handler_id(idx);
