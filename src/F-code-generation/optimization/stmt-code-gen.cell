implicit program           : Program,
         options           : CompilationOptions,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         surrogates        : [SurrExpr -> ObjExpr]
{
  (Instr*, ObjExpr, VarGen) do_expr_opt_eval_code(DoExpr expr, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    type = expr_type(expr, init_env, typed_vars = []); ## NOT SURE ABOUT typed_vars HERE
    repr = if type != empty_type then opt_repr(type) else :object;
    var, ret_var_gen = next_var(repr, init_var_gen);
    let typed_vars = expr.typed_vars, result_var = var:
      code, unused_var_1, unused_var_2 = stmts_opt_code(expr.body, init_env, ret_var_gen);
    ;
    return ((execute_block(code) if code != ()), obj_expr(var), ret_var_gen);
  }
}


implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         options           : CompilationOptions,
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         typed_vars        : [StdVar -> NeType],
         surrogates        : [SurrExpr -> ObjExpr],
         result_var        : AnyLocVar
{
  (Instr*, [SurrExpr -> ObjExpr], VarGen) stmts_opt_code(Statement+ stmts, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    var_gen = init_var_gen;
    code = ();
    env = init_env;
    surrs = surrogates;
    for s <- stmts:
      stmt_code, surrs, var_gen = stmt_opt_code(s, env, var_gen, surrogates = surrs);
      code = code & stmt_code;
      env = update_env(s, env);
    ;
    return (code, surrs, var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////

  (Instr*, [SurrExpr -> ObjExpr], VarGen) stmt_opt_code(Statement stmt, [EnvVar -> Type] env, VarGen var_gen) =
    break_stmt                = undefined,
    fail_stmt                 = undefined,
    loop_stmt(ss?)            = undefined,
    print_stmt(e?)            = undefined,
    return_stmt(e?)           = return_stmt_opt_code(e, env, var_gen),
    assert_stmt()             = undefined,
    let_stmt()                = undefined,
    assignment_stmt()         = assignment_stmt_opt_code(stmt.vars, stmt.value, env, var_gen),
    seq_update_stmt()         = undefined,
    if_stmt()                 = if_stmt_opt_code(stmt, env, var_gen),
    for_stmt()                = for_stmt_opt_code(stmt, env, var_gen),
    foreach_stmt()            = foreach_stmt_opt_code(stmt, env, var_gen),
    return_stmt               = ((exit_block), surrogates, var_gen),
    proc_call_stmt()          = proc_call_stmt_opt_code(stmt, env, var_gen);


  // proc_call_stmt(res_var: StdVar?, proc_name: ProcSymbol, args: Expr*);
  (Instr*, [SurrExpr -> ObjExpr], VarGen) proc_call_stmt_opt_code(ProcCallStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, args_surrs, var_gen = opt_eval_code(stmt.args, env, init_var_gen);
    call_instr = if stmt.res_var?
      then call_proc(stmt.res_var, stmt.proc_name, args_surrs, ())
      else call_proc(stmt.proc_name, args_surrs, ());
    return ((code | call_instr), surrogates, var_gen);
  }


  (Instr*, [SurrExpr -> ObjExpr], VarGen) assignment_stmt_opt_code(StdVar+ vars, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    type = expr_type(value, env);
    return ((terminate), surrogates, init_var_gen) if type == empty_type;

    repr = opt_repr(type);
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);

    if |vars| == 1:
      var = only(vars);
      ll_var = low_level_var(repr, var);
      code = store_result(code, surr, ll_var);
      surrs = if var != ll_var
        then update(surrogates, var, obj_expr(ll_var))
        else remove_key(surrogates, var);

    else
      assert repr == :object;
      types = tuple_field_supertypes(type, |vars|);
      assert types == (restricted_seq_elem_supertype(type, singleton_type(i)) : i < |vars|);
      fail if not types :: NeType+;
      reprs = (opt_repr(t) : t <- types);
      phys_vars, var_gen = mapli(vars, var_gen, next_var_def(reprs($b), $a, $c));
      code = code & (set_any_var(v, at(surr, i)) : v @ i <- phys_vars);
      surrs = remove_keys(surrogates, set(vars));
      surrs = surrs & [v -> obj_expr(pv) : v @ i <~ vars, pv = phys_vars(i), v != pv];
    ;

    return (code, surrs, var_gen);
  }


  (Instr*, [SurrExpr -> ObjExpr], VarGen) return_stmt_opt_code(Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);
    code = store_result(code, surr, result_var);
    return ((code | exit_block), surrogates, init_var_gen);
  }


  (Instr*, [SurrExpr -> ObjExpr], VarGen) if_stmt_opt_code(IfStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    cond_code, cond_surr, unused_var = opt_eval_code(stmt.cond, env, init_var_gen);

    then_env, else_env = refine_env(stmt.cond, env);

    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_var_gen
    then_code, then_surrs, var_gen = stmts_opt_code(stmt.body, then_env, init_var_gen);

    // Here I could start again from init_var_gen, but then I
    // would have to reconcile the two resulting generators
    else_code, else_surrs, var_gen = if stmt.else != ()
      then stmts_opt_code(stmt.else, else_env, var_gen)
      else ((), surrogates, var_gen);

    ## CHECK WHETHER THE TWO BRANCHES CAN FALL THROUGH (USE may_fall_through(Statement*))
    ## COULD ALSO CHECK WHETHER ONE OF THE BRANCHES IS UNREACHABLE, AND JUST ELIMINATE IT

    // Reconciling the surrogates
    surr_vars = [v : v <- keys(env) & new_vars(stmt), v :: SurrExpr];
    sync_vars = [v : v <- surr_vars, lookup(then_surrs, v, v) == lookup(else_surrs, v, v)];
    unsync_vars = surr_vars - sync_vars;
    fail if not unsync_vars :: [StdVar];
    surrs = [v -> then_surrs(v, !!) : v <- sync_vars, then_surrs(v, *)];

    // Putting together the complete compiled code
    for v <- isort(unsync_vars):
      then_code = (then_code | set_var(v, then_surrs(v, !!))) if then_surrs(v, *);
      else_code = (else_code | set_var(v, else_surrs(v, !!))) if else_surrs(v, *);
    ;
    code = (cond_code | branch(bool_value(cond_surr), then_code, else_code));

    return (code, surrs, var_gen);
  }


  (Instr*, [SurrExpr -> ObjExpr], VarGen) for_stmt_opt_code(ForStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Generating the hidden loop variable
    idx_var, var_gen = next_int_var(init_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    start_val_code, start_val_surr, var_gen = opt_eval_code(stmt.start_val, env, var_gen);
    end_val_code, end_val_surr, var_gen = opt_eval_code(stmt.end_val, env, var_gen);
    entry_code = store_result(start_val_code, start_val_surr, idx_var) & end_val_code;

    // Environment the body runs in
    body_env = for_stmt_body_env(stmt, env);

    body_code = (); exit_surrs = []; ## BAD BAD BAD: THESE SHOULD NOT BE NECESSARY

    surr_vars = [v : v, unused_var <- env, v :: SurrExpr];
    surrs = surrogates;
    loop
      // Trying to generate the body code with the current set of surrogates
      entry_surrs = surrogates & [stmt.var -> obj_expr(idx_var) if stmt.var?];
      ## HERE I ALSO HAVE TO PASS DOWN THE LIST OF EXPECTED SURROGATES FOR BREAK INSTRUCTIONS
      let surrogates = entry_surrs:
        body_code, exit_surrs, exit_var_gen = stmts_opt_code(stmt.body, body_env, var_gen);
      ;

      // Finding out what variables get out of sync after one iteraction of the loop
      out_of_sync_vars = [v : v, e <- surrs, lookup(exit_surrs, v, v) != e];

      // If no variable is out of sync, then we're done
      break if out_of_sync_vars == [];

      // Removing the unsyncronized variables from the initial list of surrogates
      // by physically storing them into their corresponding variables
      for v <- isort(out_of_sync_vars):
        fail if not v :: StdVar;
        entry_code = (entry_code | set_var(v, surrs(v, !!)));
      ;
      surrs = remove_keys(surrs, out_of_sync_vars);
    ;

    for v <- isort(surr_vars):
      assert not surrs(v, *) or (exit_surrs(v, *) and surrs(v, !!) == exit_surrs(v, !!));
      if not surrs(v, *) and exit_surrs(v, *):
        fail if not v :: StdVar;
        body_code = (body_code | set_var(v, exit_surrs(v, !!)));
      ;
    ;

    loop_over_expr = if stmt.end_val_incl
      then is_gt(idx_var, get_int_val(end_val_surr))
      else is_ge(idx_var, get_int_val(end_val_surr));
    loop_instr = repeat(nonempty((break_if(loop_over_expr)) & body_code & (increment(idx_var))));

    return ((entry_code | loop_instr), surrs, init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] for_stmt_body_env(ForStmt stmt, [EnvVar -> Type] env) {
      start_val_type = expr_type(stmt.start_val, env);
      end_val_type = expr_type(stmt.end_val, env);
      idx_var_type = loop_var_type(start_val_type, end_val_type, stmt.end_val_incl);

      loop_var_env = [stmt.var -> idx_var_type if stmt.var?];
      exit_env = update_env(stmt.body, env & loop_var_env);
      return merge_envs(env, exit_env) & loop_var_env;
    }
  }


  (Instr*, [SurrExpr -> ObjExpr], VarGen) foreach_stmt_opt_code(ForeachStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Calculating input sequence type, and returning early if the type is trivial
    seq_type = expr_type(stmt.values, env);
    if seq_type == empty_type:
      return ((terminate), surrogates, init_var_gen);
    elif is_subset(seq_type, empty_seq_type):
      return ((), surrogates, init_var_gen);
    ;

    // Type and representation of the elements of the input sequence
    elt_type = seq_elem_supertype(seq_type);
    fail if elt_type == empty_type;
    elt_repr = opt_repr(elt_type);

    // Evaluation of input expression
    entry_code, seq_surr, var_gen = opt_eval_code(stmt.values, env, init_var_gen);
    fail if not seq_surr :: <LocVar, StdVar>; ## MAYBE THIS COULD BE AVOIDED...

    // Temporary buffer for source data
    buffer_var, var_gen = next_array_var(var_gen, elt_repr);

    vars = stmt.vars;
    if |vars| == 1:
      var = only(vars);
      physical_var, var_gen = next_var_def(elt_repr, var, var_gen);
      surrs = surrogates & [var -> obj_expr(physical_var)];
      it_var = physical_var;
      body_code = ();

    else
      assert elt_repr == :object;
      vars_types = (restricted_seq_elem_supertype(seq_type, singleton_type(i)) : i < |vars|);
      fail if not vars_types :: NeType+;
      reprs = (opt_repr(t) : t <- vars_types);
      physical_vars, var_gen = mapli(vars, var_gen, next_var_def(reprs($b), $a, $c));
      surrs = surrogates & [v -> obj_expr(physical_vars(i)) : v @ i <~ vars];
      it_var, var_gen = next_obj_var(var_gen);
      body_code = (set_any_var(v, at(it_var, i)) : v @ i <- physical_vars);
    ;

    // Index variables
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    surrs = surrs & [stmt.idx_var -> int_obj(hidden_idx_var)] if stmt.idx_var?;

    // Environment the body runs in
    body_env = foreach_stmt_body_env(stmt, env);

    body_code = (); exit_surrs = []; ## BAD BAD BAD: THESE SHOULD NOT BE NECESSARY

    surr_vars = [v : v, unused_var <- env, v :: SurrExpr];
    loop
      // Trying to generate the body code with the current set of surrogates
      // entry_surrs = surrogates & [stmt.var -> obj_expr(idx_var) if stmt.var?];
      ## HERE I ALSO HAVE TO PASS DOWN THE LIST OF EXPECTED SURROGATES FOR BREAK INSTRUCTIONS
      let surrogates = surrs:
        body_code, exit_surrs, exit_var_gen = stmts_opt_code(stmt.body, body_env, var_gen);
      ;

      // Finding out what variables get out of sync after one iteraction of the loop
      out_of_sync_vars = [v : v, e <- surrs, lookup(exit_surrs, v, v) != e];

      // If no variable is out of sync, then we're done
      break if out_of_sync_vars == [];

      // Removing the unsyncronized variables from the initial list of surrogates
      // by physically storing them into their corresponding variables
      for v <- isort(out_of_sync_vars):
        fail if not v :: StdVar;
        entry_code = (entry_code | set_var(v, surrs(v, !!)));
      ;
      surrs = remove_keys(surrs, out_of_sync_vars);
    ;

    for v <- isort(surr_vars):
      assert not surrs(v, *) or (exit_surrs(v, *) and surrs(v, !!) == exit_surrs(v, !!));
      if not surrs(v, *) and exit_surrs(v, *):
        fail if not v :: StdVar;
        body_code = (body_code | set_var(v, exit_surrs(v, !!)));
      ;
    ;

    // Mapping source to destination arrays
    map_instr = foreach(seq_surr, buffer_var, hidden_idx_var, it_var, body_code);

    return ((entry_code | map_instr), surrs, init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] foreach_stmt_body_env(ForeachStmt stmt, [EnvVar -> Type] env) {
      elt_type = seq_elem_supertype(expr_type(stmt.values, env));
      loop_vars_env = asgnm_env_updates(stmt.vars, elt_type);

      loop_vars_env = loop_vars_env & [stmt.idx_var -> type_nat] if stmt.idx_var?;
      exit_env = update_env(stmt.body, env & loop_vars_env);
      return merge_envs(env, exit_env) & loop_vars_env;
    }
  }
}
