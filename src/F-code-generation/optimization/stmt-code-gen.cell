implicit program           : Program,
         options           : CompOptions,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         surrogates        : [SurrExpr -> ObjExpr]
{
  (Instr*, ObjExpr, VarGen) do_expr_opt_eval_code(DoExpr expr, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    type = expr_type(expr, init_env, typed_vars = []); ## NOT SURE ABOUT typed_vars HERE
    repr = if type != empty_type then opt_repr(type) else :object;
    var, ret_var_gen = next_var(repr, init_var_gen);
    let typed_vars = expr.typed_vars, exp_break_surrs = nothing, result_var = var:
      code, unused_var_1, unused_var_2, unused_var_3 = stmts_opt_code(expr.body, init_env, ret_var_gen);
    ;
    return ((execute_block(code) if code != ()), obj_expr(var), ret_var_gen);
  }
}


type StmtCompInfo = (Instr*, Maybe[[SurrExpr -> ObjExpr]], [[SurrExpr -> ObjExpr]], VarGen);


implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         options           : CompOptions,
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         typed_vars        : [StdVar -> NeType],
         surrogates        : [SurrExpr -> ObjExpr],
         exp_break_surrs   : Maybe[[SurrExpr -> ObjExpr]],
         result_var        : AnyLocVar
{
  StmtCompInfo stmts_opt_code(Statement* stmts, [EnvVar -> Type] init_env, VarGen init_var_gen) {
    return ((), just(surrogates), [], init_var_gen) if stmts == ();

    var_gen = init_var_gen;
    code = ();
    env = init_env;
    surrs = just(surrogates);
    break_surrs = [];
    for s <- stmts:
      fail if surrs == nothing;
      stmt_code, surrs, stmt_break_surrs, var_gen = stmt_opt_code(s, env, var_gen, surrogates = value(surrs));
      code = code & stmt_code;
      break_surrs = break_surrs & stmt_break_surrs;
      env = update_env(s, env);
    ;
    return (code, surrs, break_surrs, var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////

  StmtCompInfo stmt_opt_code(Statement stmt, [EnvVar -> Type] env, VarGen var_gen) =
    break_stmt                = break_stmt_opt_code(env, var_gen),
    fail_stmt()               = fail_stmt_opt_code(stmt, env, var_gen),
    loop_stmt(ss?)            = loop_stmt_opt_code(ss, env, var_gen),
    print_stmt(e?)            = print_stmt_opt_code(e, env, var_gen),
    return_stmt(e?)           = return_stmt_opt_code(e, env, var_gen),
    assert_stmt()             = assert_stmt_opt_code(stmt, env, var_gen),
    let_stmt()                = let_stmt_opt_code(stmt.asgnms, stmt.body, env, var_gen),
    assignment_stmt()         = assignment_stmt_opt_code(stmt.vars, stmt.value, env, var_gen),
    seq_update_stmt()         = seq_update_stmt_opt_code(stmt, env, var_gen),
    if_stmt()                 = if_stmt_opt_code(stmt, env, var_gen),
    for_stmt()                = for_stmt_opt_code(stmt, env, var_gen),
    foreach_stmt()            = foreach_stmt_opt_code(stmt, env, var_gen),
    return_stmt               = ((exit_block), just(surrogates), [], var_gen),
    proc_call_stmt()          = proc_call_stmt_opt_code(stmt, env, var_gen);


  StmtCompInfo seq_update_stmt_opt_code(SeqUpdateStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    idx_eval_code, idx_surr, var_gen = opt_eval_code(stmt.idx, env, init_var_gen);
    val_eval_code, val_surr, var_gen = opt_eval_code(stmt.value, env, var_gen);
    tmp_var, var_gen = next_obj_var(var_gen);
    update_code = (
      update_seq_at(tmp_var, stmt.seq_var, get_int_val(idx_surr), val_surr),
      set_var(stmt.seq_var, tmp_var)
    );
    code = idx_eval_code & val_eval_code & update_code;
    return (code, just(surrogates), [], init_var_gen);
  }


  StmtCompInfo fail_stmt_opt_code(FailStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    if options.debug_mode:
      vars = ((v, lookup(surrogates, v, v)) : v <- isort(stmt.env));
      code = (log_runtime_failure(false, stmt.file, stmt.line, nothing, vars));
    else
      code = ();
    ;
    return ((code | terminate), nothing, [], var_gen);
  }


  StmtCompInfo assert_stmt_opt_code(AssertStmt stmt, [EnvVar -> Type] env, VarGen var_gen) {
    return ((), just(surrogates), [], var_gen) if options.ignore_assertions;

    eval_code, surr, unused_var = opt_eval_code(stmt.cond, env, var_gen);
    expr_vars = extern_vars(stmt.cond);
    vars = isort([v : v <- stmt.env, expr_vars(v)]) & isort([v : v <- stmt.env, not expr_vars(v)]);
    vars = ((v, lookup(surrogates, v, v)) : v <- vars);
    log_instr = log_runtime_failure(true, stmt.file, stmt.line, stmt.text, vars);
    check_instr = do_if_not(bool_value(surr), (log_instr, terminate(true)));
    return ((eval_code | check_instr), just(surrogates), [], var_gen);
  }


  StmtCompInfo print_stmt_opt_code(Expr expr, [EnvVar -> Type] env, VarGen var_gen) {
    eval_code, surr, unused_var = opt_eval_code(expr, env, var_gen);
    return ((eval_code | print_obj(surr)), just(surrogates), [], var_gen);
  }


  StmtCompInfo let_stmt_opt_code([ImplArg -> Expr] asgnms, Statement+ body, [EnvVar -> Type] env, VarGen init_var_gen) {
    ## THIS SHOULD BE CHECKED IN THE PROPER PLACE, BOTH IN LAYER 1 AND 2
    ## IT'S A TEMPORARY LIMITATION THAT SHOULD BE REMOVED
    assert subset(outcomes(body), [:fails, :falls_through]);

    ## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
    ord_asgnms = isort(asgnms);
    backup_vars, var_gen = next_obj_vars(init_var_gen, |ord_asgnms|);

    set_up_code = join(({
        eval_code, surr, unused_var = opt_eval_code(e, env, var_gen);
        backup_var = backup_vars(i);
        return (eval_code | set_var(backup_var, v), set_var(v, surr));
      } : v, e @ i <- ord_asgnms
    ));

    tear_down_code = reverse((set_var(v, backup_vars(i)) : v, unused_var @ i <- ord_asgnms));

    env_delta = [a -> expr_type(e, env) : a, e <- asgnms];
    body_env = update(env, env_delta);

    body_code, surrs, break_surrs, var_gen = stmts_opt_code(body, body_env, var_gen);
    assert break_surrs == []; ## SEE COMMENT AT THE BEGINNING OF THIS FUNCTION

    code = set_up_code & body_code & tear_down_code;
    return (code, surrs, break_surrs, var_gen);
  }


  // If a surrogates is defined here but not in the expected list,
  // we just remove it by physically storing its value.

  // If a surrogates is defined in the expected list but not here
  // there's nothing we can do here to fix that. We just return
  // the list of surrogates we end up with and we leave it to code
  // higher up in the call stack to fix that and retry

  // Finally, if a surrogate is defined in both lists, but the
  // definitions are different, we remove it here and we leave
  // to the calling code to fix the expected list and retry

  StmtCompInfo break_stmt_opt_code([EnvVar -> Type] env, VarGen var_gen) {
    exp_surrs = value_unsafe(exp_break_surrs);
    surrs_to_drop = [v : v, e <- surrogates, not exp_surrs(v, *) or exp_surrs(v, !!) != e];
    fail if not surrs_to_drop :: [StdVar];
    sync_code = (set_var(v, surrogates(v, !!)) : v <- isort(surrs_to_drop));
    surrs = remove_keys(surrogates, surrs_to_drop);
    return ((sync_code | break_loop), nothing, [surrs], var_gen);
  }


  // proc_call_stmt(res_var: StdVar?, proc_name: ProcSymbol, args: Expr*);
  StmtCompInfo proc_call_stmt_opt_code(ProcCallStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, args_surrs, var_gen = opt_eval_code(stmt.args, env, init_var_gen);
    call_instr = if stmt.res_var?
      then call_proc(stmt.res_var, stmt.proc_name, args_surrs, ())
      else call_proc(stmt.proc_name, args_surrs, ());
    return ((code | call_instr), just(surrogates), [], var_gen);
  }


  StmtCompInfo assignment_stmt_opt_code(StdVar+ vars, Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    type = expr_type(value, env);
    return ((terminate), just(surrogates), [], init_var_gen) if type == empty_type;

    repr = opt_repr(type);
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);

    if |vars| == 1:
      var = only(vars);
      ll_var = low_level_var(repr, var);
      code = store_result(code, surr, ll_var);
      surrs = if var != ll_var
        then update(surrogates, var, obj_expr(ll_var))
        else remove_key(surrogates, var);

    else
      assert repr == :object;
      types = tuple_field_supertypes(type, |vars|);
      ## REMOVE WHEN DONE
      assert types == (restricted_seq_elem_supertype(type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- types);
      phys_vars = (low_level_var(reprs(i), v) : v @ i <- vars);
      code = code & (set_any_var(v, at(surr, i)) : v @ i <- phys_vars);
      surrs = remove_keys(surrogates, set(vars));
      surrs = surrs & [v -> obj_expr(pv) : v @ i <~ vars, pv = phys_vars(i), v != pv];
    ;

    return (code, just(surrs), [], var_gen);
  }


  StmtCompInfo return_stmt_opt_code(Expr value, [EnvVar -> Type] env, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_code(value, env, init_var_gen);
    code = store_result(code, surr, result_var);
    return ((code | exit_block), nothing, [], init_var_gen);
  }


  StmtCompInfo if_stmt_opt_code(IfStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    ## HERE WE COULD CHECK WHETHER ONE OF THE BRANCHES IS UNREACHABLE, AND JUST ELIMINATE IT

    cond_code, cond_surr, unused_var = opt_eval_code(stmt.cond, env, init_var_gen);
    then_env, else_env = refine_env(stmt.cond, env);

    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_var_gen
    then_code, then_surrs, then_break_surrs, var_gen = stmts_opt_code(stmt.body, then_env, init_var_gen);

    // Here I could start again from init_var_gen, but then I
    // would have to reconcile the two resulting generators
    else_code, else_surrs, else_break_surrs, var_gen = stmts_opt_code(stmt.else, else_env, var_gen);

    if then_surrs != nothing and else_surrs != nothing:
      // If both branches can fall through, we need to syncronize their lists of surrogates
      surr_vars = [v : v <- keys(env) & new_vars(stmt), v :: SurrExpr];
      surrs, then_sync_code, else_sync_code = reconcile(surr_vars, value(then_surrs), value(else_surrs));
      surrs = just(surrs);
      then_code = then_code & then_sync_code;
      else_code = else_code & else_sync_code;

    elif then_surrs != nothing:
      surrs = then_surrs;

    elif else_surrs != nothing:
      surrs = else_surrs;

    else
      surrs = nothing;
    ;

    code = (cond_code | branch(bool_value(cond_surr), then_code, else_code));
    return (code, surrs, then_break_surrs & else_break_surrs, var_gen);
  }


  StmtCompInfo loop_stmt_opt_code(Statement+ body, [EnvVar -> Type] env, VarGen var_gen) {
    body_env = loop_stmt_body_env(body, env);
    entry_code, body_code, surrs = loop_stable_code(body, [], body_env, var_gen);
    return ((entry_code | repeat(nonempty(body_code))), just(surrs), [], var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] loop_stmt_body_env(Statement+ stmts, [EnvVar -> Type] entry_env) {
      exit_env = update_env(stmts, entry_env);
      return merge_envs(entry_env, exit_env);
    }
  }


  StmtCompInfo for_stmt_opt_code(ForStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Generating the hidden loop variable
    idx_var, var_gen = next_int_var(init_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    start_val_code, start_val_surr, var_gen = opt_eval_code(stmt.start_val, env, var_gen);
    end_val_code, end_val_surr, var_gen = opt_eval_code(stmt.end_val, env, var_gen);
    entry_code = store_result(start_val_code, start_val_surr, idx_var) & end_val_code;

    // Environment the body runs in
    body_env = for_stmt_body_env(stmt, env);

    // Compiling loop body and adjusting entry code
    local_surrs = [stmt.var -> obj_expr(idx_var) if stmt.var?];
    entry_code_fixes, body_code, surrs = loop_stable_code(stmt.body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;

    // Packing loop code in a repeat instruction
    loop_over_expr = if stmt.end_val_incl
      then is_gt(idx_var, get_int_val(end_val_surr))
      else is_ge(idx_var, get_int_val(end_val_surr));
    loop_instr = repeat(nonempty((break_if(loop_over_expr)) & body_code & (increment(idx_var))));

    return ((entry_code | loop_instr), just(surrs), [], init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] for_stmt_body_env(ForStmt stmt, [EnvVar -> Type] env) {
      start_val_type = expr_type(stmt.start_val, env);
      end_val_type = expr_type(stmt.end_val, env);
      idx_var_type = loop_var_type(start_val_type, end_val_type, stmt.end_val_incl);

      loop_var_env = [stmt.var -> idx_var_type if stmt.var?];
      exit_env = update_env(stmt.body, env & loop_var_env);
      return merge_envs(env, exit_env) & loop_var_env;
    }
  }


  StmtCompInfo foreach_stmt_opt_code(ForeachStmt stmt, [EnvVar -> Type] env, VarGen init_var_gen) {
    // Calculating input sequence type, and returning early if the type is trivial
    seq_type = expr_type(stmt.values, env);
    if seq_type == empty_type:
      ## just(surrogates) OR nothing?
      return ((terminate), just(surrogates), [], init_var_gen);
    elif is_subset(seq_type, empty_seq_type):
      return ((), just(surrogates), [], init_var_gen);
    ;

    // Type and representation of the elements of the input sequence
    elt_type = seq_elem_supertype(seq_type);
    fail if elt_type == empty_type;
    elt_repr = opt_repr(elt_type);

    // Evaluation of input expression
    entry_code, seq_surr, var_gen = opt_eval_code(stmt.values, env, init_var_gen);
    if not seq_surr :: <LocVar, StdVar>:
      seq_var, var_gen = next_obj_var(var_gen);
      entry_code = (entry_code | set_var(seq_var, seq_surr));
      seq_surr = seq_var;
    ;

    // Temporary buffer for source data
    src_array_var, var_gen = next_array_var(var_gen, elt_repr);

    vars = stmt.vars;
    if |vars| == 1:
      // Simple case, no destructuring of the elements of the source sequence
      var = only(vars);
      it_var = low_level_var(elt_repr, var);
      local_surrs = [var -> obj_expr(it_var) if var != it_var];
      body_code_setup = ();

    else
      // Elements of source sequence need to be destructured
      assert elt_repr == :object;
      vars_types = tuple_field_supertypes(elt_type, |vars|);
      ## REMOVE WHEN DONE
      assert vars_types == (restricted_seq_elem_supertype(elt_type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- vars_types);
      phys_vars = (low_level_var(reprs(i), v) : v @ i <- vars);
      local_surrs = [v -> obj_expr(pv) : v @ i <~ vars, pv = phys_vars(i), v != pv];
      it_var, var_gen = next_obj_var(var_gen);
      body_code_setup = (set_any_var(v, at(it_var, i)) : v @ i <- phys_vars);
    ;

    // Index variables
    count_var, var_gen = next_int32_var(var_gen);
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    local_surrs = local_surrs & [stmt.idx_var -> int_obj(hidden_idx_var)] if stmt.idx_var?;

    // Environment the body runs in
    body_env = foreach_stmt_body_env(stmt, env);

    // Compiling loop body and adjusting entry code
    entry_code_fixes, body_code, surrs = loop_stable_code(stmt.body, local_surrs, body_env, var_gen);
    entry_code = entry_code & entry_code_fixes;
    body_code = body_code_setup & body_code;

    // Mapping source to destination arrays
    read_len_instr = set_ivar32(count_var, get_size(seq_surr));
    map_instr = foreach(
      seq:        seq_surr,
      src_array:  src_array_var,
      count_var:  count_var,
      idx_var:    hidden_idx_var,
      it_var:     it_var,
      body:       body_code
    );

    return ((entry_code | read_len_instr, map_instr), just(surrs), [], init_var_gen);


    ## THIS OUGHT TO BE MOVED SOMEWHERE ELSE, MAYBE IN type-inference.cell
    [EnvVar -> Type] foreach_stmt_body_env(ForeachStmt stmt, [EnvVar -> Type] env) {
      elt_type = seq_elem_supertype(expr_type(stmt.values, env));
      loop_vars_env = asgnm_env_updates(stmt.vars, elt_type);

      loop_vars_env = loop_vars_env & [stmt.idx_var -> type_nat] if stmt.idx_var?;
      exit_env = update_env(stmt.body, env & loop_vars_env);
      return merge_envs(env, exit_env) & loop_vars_env;
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  ([SurrExpr -> ObjExpr], Instr*, Instr*) reconcile([SurrExpr] surr_vars, [SurrExpr -> ObjExpr] surrs1, [SurrExpr -> ObjExpr] surrs2) {
    // Reconciling the surrogates
    sync_vars = [v : v <- surr_vars, lookup(surrs1, v, v) == lookup(surrs2, v, v)];
    unsync_vars = surr_vars - sync_vars;
    fail if not unsync_vars :: [StdVar];
    surrs = [v -> surrs1(v, !!) : v <- sync_vars, surrs1(v, *)];

    // Syncronization code
    sync_code_1 = ();
    sync_code_2 = ();
    for v <- isort(unsync_vars):
      sync_code_1 = (sync_code_1 | set_var(v, surrs1(v, !!))) if surrs1(v, *);
      sync_code_2 = (sync_code_2 | set_var(v, surrs2(v, !!))) if surrs2(v, *);
    ;

    return (surrs, sync_code_1, sync_code_2);
  }


  // The list of surrogates we return is the one we have:
  //   1) Just before the loop starts
  //   2) When the loop breaks
  //   3) After any iteraction of the loop terminates

  // That means that if the loop body never breaks or terminates we'll just
  // return the entry environment.

  // Since we can only remove surrogates from the initial list, then the
  // returned one is always a subset of it, and we can start with the initial
  // entry list and keep removing surrogates from it until everything matches

  (Instr*, Instr*, [SurrExpr -> ObjExpr])
  loop_stable_code(Statement+ stmts, [SurrExpr -> ObjExpr] local_surrs, [EnvVar -> Type] env, VarGen var_gen) {
    ## MAYBE HERE I COULD EXPLICITLY PASS A LIST OF VARIABLES THAT ARE
    ## EXPECTED TO SURVIVE THE LOOP INSTEAD OF TRYING TO FIGURE THAT OUT SOMEHOW
    surr_vars = [v : v, unused_var <- env, v :: SurrExpr, not local_surrs(v, *)];
    entry_surrs = surrogates;
    entry_code = ();

    loop
      body_surrs = entry_surrs & local_surrs;
      let surrogates = body_surrs, exp_break_surrs = just(body_surrs):
        body_code, exit_surrs, break_surrs, unused_var = stmts_opt_code(stmts, env, var_gen);
      ;

      // Finding out what variables get out of sync after one iteraction of the loop
      out_of_sync_vars = [v : v, e <- entry_surrs, is_out_of_sync(v, e, exit_surrs, break_surrs)];

      // If no variable is out of sync, then we're done
      if out_of_sync_vars == []:
        return (entry_code, body_code, entry_surrs) if exit_surrs == nothing;
        exit_surrs = value(exit_surrs);
        for v <- isort(surr_vars):
          assert not entry_surrs(v, *) or (exit_surrs(v, *) and entry_surrs(v, !!) == exit_surrs(v, !!));
          if not entry_surrs(v, *) and exit_surrs(v, *):
            fail if not v :: StdVar;
            body_code = (body_code | set_var(v, exit_surrs(v, !!)));
          ;
        ;
        return (entry_code, body_code, entry_surrs);
      ;

      // Removing the unsyncronized variables from the initial list of surrogates
      // by physically storing them into their corresponding variables
      for v <- isort(out_of_sync_vars):
        fail if not v :: StdVar;
        entry_code = (entry_code | set_var(v, entry_surrs(v, !!)));
      ;
      entry_surrs = remove_keys(entry_surrs, out_of_sync_vars);
    ;


    Bool is_out_of_sync(SurrExpr var, ObjExpr entry_surr, Maybe[[SurrExpr -> ObjExpr]] maybe_exit_surrs, [[SurrExpr -> ObjExpr]] break_surrs) {
      if maybe_exit_surrs != nothing:
        exit_surrs = value(maybe_exit_surrs);
        return true if not exit_surrs(var, *) or exit_surrs(var, !!) != entry_surr;
      ;
      return (surrs <- break_surrs : not surrs(var, *) or surrs(var, !!) != entry_surr);
    }
  }
}
