type SmallIntRepr     = int8, int16, int32; // nat8, nat16, nat32;

type LowLevelEltRepr  = LowLevelRepr, SmallIntRepr;

type LowLevelRepr = bool, int, symbol, float, object,
                    array(type: LowLevelEltRepr, size_var: LocIntVar);

type LowLevelSign = low_level_sign(args: LowLevelRepr*, ret_value: LowLevelRepr);

////////////////////////////////////////////////////////////////////////////////

LowLevelRepr+ atomic_low_level_reprs = (:bool, :int, :symbol, :float);

LowLevelEltRepr* atomic_low_level_elt_reprs = (:bool, :int8, :int16, :int32, :int, :symbol, :float);


NeType low_level_repr_type(LowLevelRepr) =
  bool    = type_bool,
  int     = integer,
  symbol  = atom_type,
  float   = float_type,
  object  = type_any;


NeType low_level_repr_type(SmallIntRepr) =
  int8    = type_int8,
  int16   = type_int16,
  int32   = type_int32;
  // nat8    = type_byte,
  // nat16   = type_nat16,
  // nat32   = type_nat32,

////////////////////////////////////////////////////////////////////////////////

LowLevelRepr aggr_repr(LowLevelRepr repr1, LowLevelRepr repr2) =
  bool,   symbol  = :symbol,
  symbol, bool    = :symbol,
  _,      _       = if repr1 == repr2 then repr1 else :object;

LowLevelRepr aggr_repr([+LowLevelRepr] reprs) = reduce(reprs, aggr_repr);


LowLevelSign aggr_sign([+LowLevelSign] signs) {
  assert |[|s.args| : s <- signs]| == 1;

  a_sign = an_elem(signs);
  args = (aggr_repr([s.args(i) : s <- signs]) : a @ i <- a_sign.args);
  ret_value = aggr_repr([s.ret_value : s <- signs]);
  return low_level_sign(args: args, ret_value: ret_value);
}


AnyTypeExpr low_level_expr(LowLevelRepr repr, ObjExpr expr) =
  bool      = bool_value(expr),
  int       = get_int_val(expr),
  symbol    = expr, ## TEMPORARY TEMPORARY TEMPORARY
  float     = float_value(expr),
  object    = expr;


AnyTypeExpr low_level_expr(SmallIntRepr repr, ObjExpr expr) = undefined;
  // int8    =
  // int16   =
  // int32   =


implicit typedefs : [TypeName -> NeType] {
  LowLevelRepr low_level_repr(NeType type) {
    for r <- atomic_low_level_reprs:
      return r if is_subset(type, low_level_repr_type(r));
    ;
    return :object;
  }


  LowLevelEltRepr low_level_elt_repr(NeType type) {
    for r <- atomic_low_level_elt_reprs:
      return r if is_subset(type, low_level_repr_type(r));
    ;
    return :object;
  }


  LowLevelSign low_level_sign(Function fn) =
    low_level_sign(
      args:       (low_level_repr(t) : unused_var, t <- fn.args),
      ret_value:  low_level_repr(fn.res_type)
    );
}

////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType] {
  (FnId, LowLevelSign) low_level_sign(FnFamilyId fn_id, Type* args_types) {
    for id, s <- signatures_info_by_family_id(fn_id, !!):
      return (id, s) if not (t @ i <~ args_types : not is_subset(t, low_level_repr_type(s.args(i))));
    ;
    return (fn_id, aggr_sign_by_fn_family_id(fn_id, !!));


    [FnFamilyId -> LowLevelSign] aggr_sign_by_fn_family_id =
      [id -> aggr_sign([s : unused_var, s <~ info]) : id, info <- signatures_info_by_family_id];


    [FnFamilyId -> (FnId, LowLevelSign)+] signatures_info_by_family_id {
      family_ids = [id : id, unused_var <- signature_info];
      return [id -> nonempty(isort([info : info <- signature_info(id, ?)])) : id <- family_ids];
    }


    [FnFamilyId, (FnId, LowLevelSign)] signature_info =
      [family_id(fn.id), (fn.id, low_level_sign(fn)) : fn <- program.fndefs];
  }
}


