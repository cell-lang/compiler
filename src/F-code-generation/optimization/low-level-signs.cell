LowLevelRepr+ atomic_low_level_reprs = (:bool, :int, :symbol, :float);

LowLevelEltRepr* atomic_low_level_elt_reprs = (:bool, :int8, :int16, :int32, :int, :symbol, :float);


NeType low_level_repr_type(LowLevelRepr) =
  bool    = type_bool,
  int     = integer,
  symbol  = atom_type,
  float   = float_type,
  object  = type_any;


NeType low_level_repr_type(SmallIntRepr) =
  int8    = type_int8,
  int16   = type_int16,
  int32   = type_int32;
  // nat8    = type_byte,
  // nat16   = type_nat16,
  // nat32   = type_nat32,


LowLevelRepr low_level_repr(BoolExpr)  = :bool;
LowLevelRepr low_level_repr(IntExpr)   = :int;
LowLevelRepr low_level_repr(FloatExpr) = :float;

LowLevelRepr low_level_repr(<InlineObj, StdObjVar, ObjNatOp>) = :object;

OptTagRecRepr low_level_repr(OptTagRecExpr expr) = opt_tag_rec_repr(expr.tag, expr.index);

////////////////////////////////////////////////////////////////////////////////

Bool is_subset(LowLevelRepr r1, LowLevelRepr r2) {
  return true if r1 == r2 or r2 == :object;

  return match (r1)
    bool      = r2 == :symbol,
    int       |
    float     |
    symbol    |
    object    = false,
    array()   = undefined; ## IMPLEMENT
}


Bool overlap(LowLevelRepr r1, LowLevelRepr r2) {
  return true if r1 == r2 or r1 == :object or r2 == :object;

  return match (r1)
    bool    = r2 == :symbol,
    int     |
    float   |
    symbol  = false;
}

////////////////////////////////////////////////////////////////////////////////

LowLevelRepr aggr_repr(LowLevelRepr repr1, LowLevelRepr repr2) =
  bool,   symbol  = :symbol,
  symbol, bool    = :symbol,
  _,      _       = if repr1 == repr2 then repr1 else :object;

LowLevelRepr aggr_repr([+LowLevelRepr] reprs) = reduce(reprs, aggr_repr);


LowLevelSign aggr_sign([+LowLevelSign] signs) {
  assert |[|s.args| : s <- signs]| == 1;

  a_sign = an_elem(signs);
  args = (aggr_repr([s.args(i) : s <- signs]) : a @ i <- a_sign.args);
  ret_value = aggr_repr([s.ret_value : s <- signs]);
  return low_level_sign(args: args, ret_value: ret_value);
}


AnyLocVar low_level_var(LowLevelRepr repr, StdVar var) =
  bool      = bvar(untag(var)),
  int       = ivar(untag(var)),
  float     = fvar(untag(var)),
  symbol    |
  object    = var;


LocOptTagRecVar low_level_var(OptTagRecRepr repr, StdVar var) =
  opt_tag_rec_var(untag(var), repr.tag, repr.index);


AnyTypeExpr low_level_expr(LowLevelRepr repr, ObjExpr expr) =
  bool      = bool_value(expr),
  int       = get_int_val(expr),
  symbol    = expr, ## TEMPORARY TEMPORARY TEMPORARY
  float     = float_value(expr),
  object    = expr;


AnyTypeExpr low_level_expr(SmallIntRepr repr, ObjExpr expr) = undefined;
  // int8    =
  // int16   =
  // int32   =


ObjExpr low_level_expr(OptTagRecRepr repr, ObjExpr expr) =
  if expr :: OptTagRecExpr then expr else cast_opt_tag_rec(repr.tag, repr.index, expr);


implicit typedefs : [TypeName -> NeType] {
  LowLevelRepr low_level_repr(NeType type) {
    for r <- atomic_low_level_reprs:
      return r if is_subset(type, low_level_repr_type(r));
    ;

    return :object;
  }


  LowLevelEltRepr low_level_elt_repr(NeType type) {
    for r <- atomic_low_level_elt_reprs:
      return r if is_subset(type, low_level_repr_type(r));
    ;
    return :object;
  }


  LowLevelSign low_level_sign(Function fn) =
    low_level_sign(
      args:       (low_level_repr(t) : unused_var, t <- fn.args),
      ret_value:  low_level_repr(fn.res_type)
    );
}


implicit program : Program, typedefs : [TypeName -> NeType] {
  <LowLevelRepr, OptTagRecRepr> opt_repr(NeType type) {
    for r <- atomic_low_level_reprs:
      return r if is_subset(type, low_level_repr_type(r));
    ;

    ## PERFORMANCE HERE IS PROBABLY HORRIFYING. FIX
    for tag <- isort(keys(optimized_tagged_records)):
      if is_subset(type, tag_obj_type(symb_type(tag), type_any)):
        untagged_type = untagged_objs_supertype(type);
        for repr @ i <- optimized_tagged_records(tag, !!):
          rec_type = low_level_repr_type(repr);
          return opt_tag_rec_repr(tag, i) if is_subset(untagged_type, rec_type);
        ;
      ;
    ;

    return :object;
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType] {
  (FnId, LowLevelSign) low_level_sign(FnFamilyId fn_id, Type* args_types) {
    for id, s <- signatures_info_by_family_id(fn_id, !!):
      return (id, s) if not (t @ i <~ args_types : not is_subset(t, low_level_repr_type(s.args(i))));
    ;
    return (fn_id, aggr_sign_by_fn_family_id(fn_id, !!));


    [FnFamilyId -> LowLevelSign] aggr_sign_by_fn_family_id =
      [id -> aggr_sign([s : unused_var, s <~ info]) : id, info <- signatures_info_by_family_id];


    [FnFamilyId -> (FnId, LowLevelSign)+] signatures_info_by_family_id {
      family_ids = [id : id, unused_var <- signature_info];
      return [id -> nonempty(isort([info : info <- signature_info(id, ?)])) : id <- family_ids];
    }


    [FnFamilyId, (FnId, LowLevelSign)] signature_info =
      [family_id(fn.id), (fn.id, low_level_sign(fn)) : fn <- program.fndefs];
  }
}


