implicit typedefs : [TypeName -> NeType] {
  Instr* opt_ptrn_match_code(Pattern ptrn, ObjExpr expr, Type type, Instr* eval_code) =
    ptrn_var()        = opt_ptrn_var_match_code(ptrn.var, ptrn.ptrn, expr, type, eval_code),
    ptrn_tuple(ps?)   = opt_ptrn_tuple_match_code(ps, expr, type, eval_code),
    ptrn_tag_obj()    = opt_ptrn_tag_obj_match_code(ptrn.tag, ptrn.obj, expr, type, eval_code),
    ptrn_union(ps?)   = opt_ptrn_union_match_code(ps, expr, type, eval_code),
    _                 = opt_do_if(opt_ptrn_match_expr(ptrn, expr, type), eval_code);


  Instr* opt_ptrn_var_match_code(StdVar var, Pattern ptrn, ObjExpr expr, Type type, Instr* eval_code) {
    fail;
  }


  Instr* opt_ptrn_tuple_match_code(Pattern+ ptrn, ObjExpr expr, Type type, Instr* eval_code) {
    fail;
  }


  Instr* opt_ptrn_tag_obj_match_code(TagPtrn tag_ptrn, Pattern obj_ptrn, ObjExpr expr, Type type, Instr* eval_code) {
    // Here we already know that the value of <expr> has to be a value tagged with a symbols
    // that matches <tag_ptrn>, so there's no need to check that.
    assert is_subset(type, tag_obj_type(equivalent_tag_type(tag_ptrn), type_any));

    untag_value_type = untagged_objs_supertype(type);
    return opt_ptrn_match_code(obj_ptrn, get_inner_obj(expr), untag_value_type, eval_code);
  }


  Instr* opt_ptrn_union_match_code([+Pattern] ptrns, ObjExpr expr, Type type, Instr* eval_code) {
    fail;
  }


  BoolExpr opt_ptrn_match_expr(Pattern ptrn, ObjExpr expr, Type type) {
    return true if type_minus_pattern(type, ptrn) == empty_type;

    return match (ptrn)
      ptrn_symbol                   = is_symb(expr),
      ptrn_symbol(s?)               = is_eq(expr, s),
      ptrn_integer(integer)         = is_int(expr),
      ptrn_integer(t?)              = opt_int_ptrn_match_expr(t, expr, type),
      ptrn_float                    = is_float(expr),
      ptrn_empty_seq                = is_eq(expr, empty_seq),
      ptrn_empty_rel                = is_eq(expr, empty_rel),
      ptrn_ne_seq                   = is_ne_seq(expr),
      ptrn_ne_map                   = is_ne_map(expr),
      ptrn_ne_set                   = is_ne_set(expr),
      ptrn_ne_bin_rel               = is_ne_bin_rel(expr),
      ptrn_ne_tern_rel              = is_ne_tern_rel(expr),
      ptrn_any                      = undefined,
      _                             = undefined;


    BoolExpr opt_int_ptrn_match_expr(IntType ptrn, ObjExpr expr, Type type) {
      memb_expr = match (ptrn)
        low_ints()  = is_le(get_int_val(expr), ptrn.max),
        high_ints() = is_ge(get_int_val(expr), ptrn.min),
        int_range() = and(is_ge(get_int_val(expr), ptrn.min), is_le(get_int_val(expr), max(ptrn))),
        integer     = undefined;

      memb_expr = and_then((is_int(expr), memb_expr)) if not is_subset(type, integer);
      return memb_expr;
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Instr* single_ptrn_match_expr_opt_code(ObjExpr expr, Type type, (Pattern, Instr*)+ cases) {
    cases_by_type = [pmt -> restrict_cases(cases, pmt) : pmt <- ptrn_match_types, may_overlap(type, pmt)];
    unhandled_types = [t : t, cs <- cases_by_type, cs == ()];
    handled_cases_by_type = [t -> cs : t, cs <- cases_by_type, cs != ()];

    code_by_type = [pmt -> opt_code(pmt, expr, type, cs) : pmt, cs <- handled_cases_by_type];

    code = (terminate(unhandled_types == [])); ## TODO: CHANGE THIS ONCE THE CODE HAS BEEN TESTED
    for pmt <- isort(keys(code_by_type)):
      code = (branch(membership_check_expr(pmt, expr), code_by_type(pmt, !!), code));
    ;
    return (execute_block(code));


    (Pattern, Instr*)* restrict_cases((Pattern, Instr*)+ cases, PtrnMatchType ptrn_match_type) {
      ptype = class_ptype(ptrn_match_type);
      return ((value_unsafe(restrict(p, ptype)), c) : p, c <- cases, matches(p, ptype));
    }


    Instr* opt_code(PtrnMatchType ptrn_match_type, ObjExpr expr, Type type, (Pattern, Instr*)+ cases) {
      restricted_type = intersection_superset(type, ptrn_match_type);
      return match (ptrn_match_type)
        symbols   = symb_ptrns_opt_code(expr, restricted_type, cases),
        tag_objs  = tag_objs_ptrns_opt_code(expr, restricted_type, cases),
        _         = default_opt_code(ptrn_match_type, expr, restricted_type, cases);
    }


    Instr* symb_ptrns_opt_code(ObjExpr expr, Type type, (Pattern, Instr*)+ cases) {
      assert is_subset(type, atom_type);

      cases_by_symb = ([s -> (rp, is) : s, rp <- nonempty_map(split_by_ptype(p))] : p, is <- cases);
      if not (c <~ cases_by_symb : c(:symbols, *)):
        cases_by_symb = ([only_symbol(s) -> p_is : s, p_is <- c] : c <- cases_by_symb);
        return symb_ptrns_by_symb_opt_code(expr, type, cases_by_symb);
      else
        fail;
      ;
    }


    Instr* symb_ptrns_by_symb_opt_code(ObjExpr expr, Type type, [+Symbol -> (Pattern, Instr*)]+ cases) {
      cases_by_symb = ord_group_by_key(cases);

      handled_type = union_type([symb_type(s) : s, unused_var <- cases_by_symb]);
      is_complete = is_subset(type, handled_type);

      code_by_symb = [
        object(s) -> {
          case_type = symb_type(s);
          eval_code = join((opt_ptrn_match_code(p, expr, case_type, is) : p, is <- cs));
          return (eval_code | exit_block);
        } : s, cs <- cases_by_symb
      ];

      code_by_symbs = [(ss, is) : is, ss <- reverse_map(code_by_symb)];
      return opt_symb_switch(expr, code_by_symbs, (terminate(is_complete)));
    }


    Instr* tag_objs_ptrns_opt_code(ObjExpr expr, Type type, (Pattern, Instr*)+ cases) {
      assert is_subset(type, type_tagged_obj);

      cases_by_tag = ([t -> (rp, is) : t, rp <- nonempty_map(split_by_tag_ptype(p))] : p, is <- cases);

      if not (c <~ cases_by_tag : c(:symbols, *)):
        simplified_cases_by_tag = ([only_symbol(t) -> p_is : t, p_is <- c] : c <- cases_by_tag);
        return tag_objs_ptrns_by_tag_opt_code(expr, type, simplified_cases_by_tag);

      else
        fail;
      ;
    }


    Instr* tag_objs_ptrns_by_tag_opt_code(ObjExpr expr, Type type, [+Symbol -> (Pattern, Instr*)]+ cases) {
      cases_by_tag = ord_group_by_key(cases);

      handled_type = union_type([tag_obj_type(symb_type(t), type_any) : t, unused_var <- cases_by_tag]);
      is_complete = is_subset(type, handled_type);

      code_by_tag = [
        object(t) -> {
          case_type = tag_obj_type(symb_type(t), restricted_untagged_objs_supertype(type, t));
          eval_code = join((opt_ptrn_match_code(p, expr, case_type, is) : p, is <- cs));
          return (eval_code | exit_block);
        } : t, cs <- cases_by_tag
      ];

      code_by_tags = [(ss, is) : is, ss <- reverse_map(code_by_tag)];
      return opt_symb_switch(get_tag(expr), code_by_tags, (terminate(is_complete)));
    }


    Instr* default_opt_code(PtrnMatchType ptrn_match_type, ObjExpr expr, Type type, (Pattern, Instr*)+ cases) {
      fail;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////

    Symbol only_symbol(<symbols, symbol(Symbol)>) =
      symbol(s?)  = s,
      symbols     = undefined;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

TagType equivalent_tag_type(TagPtrn ptrn) =
  ptrn_symbol     = atom_type,
  ptrn_symbol(s?) = symb_type(s),
  ptrn_var()      = equivalent_tag_type(ptrn.ptrn);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  Type intersection_superset(Type type, PtrnMatchType ptrn_match_type) =
    type_pattern_intersection_superset(type, as_pattern(ptrn_match_type));

  Bool may_overlap(Type type, PtrnMatchType ptrn_match_type) =
    intersection_superset(type, ptrn_match_type) != empty_type;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type PtrnMatchType = symbols, integers, floats, seqs, empty_rel, ne_sets, ne_bin_rels, ne_tern_rels, tag_objs;


[+PtrnMatchType] ptrn_match_types = [
  :symbols,
  :integers,
  :floats,
  :seqs,
  :empty_rel,
  :ne_sets,
  :ne_bin_rels,
  :ne_tern_rels,
  :tag_objs
];


BoolExpr membership_check_expr(PtrnMatchType, ObjExpr expr) =
  symbols       = is_symb(expr),
  integers      = is_int(expr),
  floats        = is_float(expr),
  seqs          = or((are_eq(expr, empty_seq), is_ne_seq(expr))),
  empty_rel     = are_eq(expr, empty_rel),
  ne_sets       = is_ne_set(expr),
  ne_bin_rels   = is_ne_bin_rel(expr),
  ne_tern_rels  = is_ne_tern_rel(expr),
  tag_objs      = is_tagged_obj(expr);


NePseudoType class_ptype(PtrnMatchType) =
  symbols       = pseudotype_symbols,
  integers      = pseudotype_integers,
  floats        = pseudotype_floats,
  seqs          = pseudotype_seqs,
  empty_rel     = pseudotype_empty_rel,
  ne_sets       = pseudotype_ne_sets,
  ne_bin_rels   = pseudotype_ne_bin_rels,
  ne_tern_rels  = pseudotype_ne_tern_rels,
  tag_objs      = pseudotype_tag_objs;


Pattern as_pattern(PtrnMatchType) =
  symbols       = ptrn_symbol,
  integers      = ptrn_integer(integer),
  floats        = ptrn_float,
  seqs          = ptrn_union([ptrn_empty_seq, ptrn_ne_seq]),
  empty_rel     = ptrn_empty_rel,
  ne_sets       = ptrn_ne_set,
  ne_bin_rels   = ptrn_ne_bin_rel,
  ne_tern_rels  = ptrn_ne_tern_rel,
  tag_objs      = ptrn_tag_obj(ptrn_symbol, ptrn_any);
