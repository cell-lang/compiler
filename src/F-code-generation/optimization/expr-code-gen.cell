// type EnvExpr = EnvVar, ExprRef;

type SubExprInfo = (type: Type, surr_expr: ObjExpr);


implicit program : Program, typedefs : [TypeName -> NeType], context : Context, var_surrs : [EnvVar -> ObjExpr] {
  (Instr*, ObjExpr, VarGen) opt_eval_info(<undefined>, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    return ((terminate), never_used_lvar, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(LeafObj expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    return ((), expr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(FloatLit expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(Var var, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    surr = if var :: EnvVar then var_surrs(var, !!) else var;
    return ((), surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsDefExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsSetExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(ExprRef expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(RecExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) =
    seq_expr(ses?)      = undefined,
    tuple_expr(es?)     = undefined,
    seq_tail_expr()     = undefined,
    set_expr(ses?)      = undefined,
    map_expr(es?)       = undefined,
    bin_rel_expr(es?)   = undefined,
    tern_rel_expr(es?)  = undefined,
    tag_obj_expr()      = undefined,
    fn_call()           = fn_call_opt_eval_info(expr, var_gen, subexpr_info),
    cls_call()          = undefined,
    builtin_call()      = undefined,
    size_expr()         = undefined,
    unary_pseudo_call() = undefined,
    rel_memb_test()     = undefined,
    rel_lookup()        = undefined,
    relvar_memb_test()  = undefined,
    relvar_lookup()     = undefined,
    and_expr()          = undefined,
    or_expr()           = undefined,
    not_expr(e?)        = undefined,
    eq()                = undefined,
    membership()        = undefined,
    cast_expr()         = undefined,
    accessor()          = undefined,
    accessor_test()     = undefined,
    auto_method_call()  = undefined,
    db_method_call()    = undefined,
    if_expr()           = undefined,
    match_expr()        = undefined,
    do_expr()           = undefined,
    ex_qual()           = undefined,
    set_comp()          = undefined,
    map_comp()          = undefined,
    bin_rel_comp()      = undefined,
    tern_rel_comp()     = undefined,
    seq_comp()          = undefined,
    range_comp()        = undefined;


  // fn_call(fn_id: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr])
  (Instr*, ObjExpr, VarGen) fn_call_opt_eval_info(FnCallExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    assert expr.impl_args == [];
    fail if not expr.args :: ExprRef* or not expr.impl_args :: [ImplArg -> ExprRef];

    // Actual arguments information
    args_info = (subexpr_info(a) : a <- expr.args);

    // Signature of the target function
    fn_id, low_level_sign = low_level_sign(expr.fn_id, (just(a.type) : a <- args_info));

    // Low-level actual arguments
    low_level_args = (low_level_expr(value_unsafe(low_level_sign.args(i)), a.surr_expr) : a @ i <- args_info);

    // Result variable, surrogate expression and next variable generator
    res_var, surr_expr, next_var_gen = match (low_level_sign.ret_value)
      bool            = {v, g = next_bool_var(var_gen);  return (v, bool_obj(v),  g);},
      int             = {v, g = next_int_var(var_gen);   return (v, int_obj(v),   g);},
      float           = {v, g = next_float_var(var_gen); return (v, float_obj(v), g);},
      symbol | object = {v, g = next_obj_var(var_gen);   return (v, v,            g);};

    // Evaluation code for the call only
    eval_code = (call_proc(res_var, fn_id, low_level_args));

    return (eval_code, surr_expr, next_var_gen);
  }
}

  // Instr+ gen_eval_code_for_fn_call_expr(FnFamilyId id, AnyExpr* params, [ImplArg -> Expr] impl_args, EvalDestVar res_var) {
  //   if impl_args != []:
  //     ## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
  //     var = an_elem(nonempty(keys(impl_args)));
  //     expr = impl_args[var];
  //     rem_impl_args = [v -> e : v, e <- impl_args, v != var];
  //     backup_var, var_gen = next_obj_var(next_var_gen);
  //     info = gen_eval_info(expr, next_var_gen = var_gen);
  //     body = gen_eval_code_for_fn_call_expr(id, params, rem_impl_args, res_var, next_var_gen = info.next_var_gen);
  //     set_up_code = (set_var(backup_var, var), set_var(var, info.expr));
  //     tear_down_code = (set_var(var, backup_var));
  //     return nonempty(info.eval_code & set_up_code & body & tear_down_code);

  //   else
  //     pars_are_first_order = (is_expr(p) : p <- params);
  //     par_packed_idxs = packed_seq_idxs(pars_are_first_order);
  //     pars_info = gen_eval_info((cast_as_expr(p) : p @ i <- params, pars_are_first_order(i)));
  //     all_params = (
  //       if pars_are_first_order(i)
  //         then pars_info.exprs(par_packed_idxs[i])
  //         else compiled_closure(cast_as_cls_expr(p))
  //     : p @ i <- params);
  //     core_call_code = (call_proc(res_var, id, all_params));
  //     return nonempty(pars_info.eval_code & core_call_code);
  //   ;
  // }


// type RecExpr  = SetExpr, SeqExpr, TupleExpr, SeqTailExpr,
//                 MapExpr, BinRelExpr, TernRelExpr, TagObjExpr,
//                 FnCallExpr, ClsCall, BuiltinCall,
//                 SizeExpr,
//                 UnaryPseudoCall, RelMembTest, RelLookup,
//                 RelVarMembTest, RelVarLookup,
//                 AndExpr, OrExpr, NotExpr,
//                 EqExpr,
//                 MembExpr, CastExpr,
//                 AccExpr, AccTestExpr,
//                 AutoMethodCall, DBMethodCall,
//                 IfExpr, MatchExpr, DoExpr,
//                 ExQualExpr, SetCompExpr, MapCompExpr, BinRelCompExpr, TernRelCompExpr,
//                 SeqCompExpr, RangeCompExpr;
