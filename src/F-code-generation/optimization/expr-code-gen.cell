implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         cluster           : Expr+,
         types             : Type+,
         surrogates        : [EnvVar -> ObjExpr],
         expr_id           : Nat,
         options           : CompilationOptions
{
  Type subexpr_type(Expr) =
    expr_ref(id?) = types(id);

  Expr expand_subexpr(Expr) =
    expr_ref(id?) = cluster(id);

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, VarGen) opt_eval_info(Expr expr, AnyLocVar res_var, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    eval_code = store_result(eval_code, surr_expr, res_var);
    return (eval_code, var_gen);
  }


  Instr+ opt_eval_code(Expr expr, AnyLocVar res_var, VarGen var_gen) {
    eval_code, surr_expr, unused_var = opt_eval_info(expr, var_gen);
    return store_result(eval_code, surr_expr, res_var);
  }


  (Instr*, ObjExpr*, VarGen) opt_eval_info(Expr* exprs, VarGen init_var_gen) {
    var_gen = init_var_gen;
    code = ();
    surrs = ();
    for e <- exprs:
      expr_code, surr, var_gen = opt_eval_info(e, var_gen);
      code = code & expr_code;
      surrs = (surrs | surr);
    ;
    return (code, surrs, var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, ObjExpr, VarGen) opt_eval_info(<undefined>, VarGen var_gen) {
    return ((terminate), never_used_lvar, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(LeafObj expr, VarGen var_gen) {
    return ((), expr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(FloatLit expr, VarGen init_var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(Var var, VarGen var_gen) {
    surr = if var :: EnvVar then surrogates(var, !!) else var;
    return ((), surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsDefExpr expr, VarGen var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsSetExpr expr, VarGen var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(ExprRef expr, VarGen var_gen) {
    id = untag(expr);
    return opt_eval_info(cluster(id), var_gen, expr_id = id);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(RecExpr expr, VarGen var_gen) =
    seq_expr(ses?)      |
    tuple_expr(ses?)    = seq_expr_opt_eval_info(ses, var_gen),
    seq_tail_expr()     = undefined,
    // set_expr(ses?)      = undefined,
    // map_expr(es?)       = undefined,
    // bin_rel_expr(es?)   = undefined,
    // tern_rel_expr(es?)  = undefined,
    tag_obj_expr()      = tag_obj_expr_opt_eval_info(expr, var_gen),
    fn_call()           = fn_call_opt_eval_info(expr, var_gen),
    cls_call()          = undefined,
    builtin_call()      = builtin_call_opt_eval_info(expr, var_gen),
    size_expr()         = size_expr_opt_eval_info(expr.coll, var_gen),
    unary_pseudo_call() = unary_pseudo_call_opt_eval_info(expr.target, expr.arg, var_gen),
    rel_memb_test()     = undefined,
    rel_lookup()        = undefined,
    // relvar_memb_test()  = undefined,
    // relvar_lookup()     = undefined,
    and_expr()          = and_expr_opt_eval_info(expr.left, expr.right, var_gen),
    or_expr()           = or_expr_opt_eval_info(expr.left, expr.right, var_gen),
    not_expr(e?)        = not_expr_opt_eval_info(e, var_gen),
    eq()                = eq_expr_opt_eval_info(expr.left, expr.right, var_gen),
    membership()        = undefined,
    // cast_expr()         = undefined,
    accessor()          = undefined,
    accessor_test()     = undefined,
    // auto_method_call()  = undefined,
    // db_method_call()    = undefined,
    if_expr()           = if_expr_opt_eval_info(expr, var_gen),
    match_expr()        = undefined,
    do_expr()           = undefined,
    // ex_qual()           = undefined,
    // set_comp()          = undefined,
    // map_comp()          = undefined,
    // bin_rel_comp()      = undefined,
    // tern_rel_comp()     = undefined,
    seq_comp()          = seq_comp_opt_eval_info(expr, var_gen),
    range_comp()        = range_comp_opt_eval_info(expr, var_gen);


  // tag_obj_expr(tag: Expr, obj: Expr);
  // type MapExpr        = map_expr([+(key: Expr, value: Expr, cond: Expr?)]);
  // type OptRecRepr       = opt_rec_repr([+Symbol -> (repr: LowLevelRepr, optional: Bool)]);
  // write_rec_field(var: WriteObjVar, label: Symbol, value: AnyTypeExpr),

  (Instr*, ObjExpr, VarGen) tag_obj_expr_opt_eval_info(TagObjExpr expr, VarGen init_var_gen) {
    tag_type = subexpr_type(expr.tag);
    if is_symb_singl_type(tag_type):
      // The tag is a known symbol
      symb = untag(only_symb(tag_type));
      if optimized_tagged_records(symb, *):
        // There's at least one optimized representation for values with such tag
        reprs = optimized_tagged_records(symb, !!);
        obj_expr = expr.obj;
        obj_type = subexpr_type(obj_expr);
        for repr @ repr_idx <- reprs:
          repr_type = low_level_repr_type(repr);
          if is_subset(obj_type, repr_type):
            // The tagged value has an optimized representation
            obj_expr = expand_subexpr(obj_expr);
            if obj_expr :: MapExpr:
              // The expression that defines the tagged value is a map expression
              fields = isort(untag(obj_expr));
              keys_types = (subexpr_type(f.key) : f <- fields);
              if not (t <~ keys_types : not is_symb_singl_type(t)):
                // Every key in the map expression is a known symbol
                labels = (untag(only_symb(t)) : t <- keys_types);
                return direct_opt_rec_eval_info(symb, labels, obj_expr, repr, repr_idx, init_var_gen);
              ;
            ;
          elif not are_ptype_disjoint(obj_type, repr_type):
            fail;
          ;
        ;
      ;
      // The tagged value does not have an optimized representation
      fail;
    else
      // The symbol is not known at compile time
      fail;
    ;



    (Instr*, ObjExpr, VarGen) direct_opt_rec_eval_info(Symbol tag, Symbol+ labels, MapExpr rec_expr, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      low_level_fields = untag(repr);
      var, var_gen = next_opt_tag_rec_var(init_var_gen, tag, repr_idx);
      surrs = ();
      conds = ();
      code = (inst_opt_tag_rec(var, tag, repr_idx));
      var_gen = init_var_gen;
      for f @ i <- isort(untag(rec_expr)):
        label = labels(i);
        field = low_level_fields(label, !!);

        if f.cond?:
          cond_code, cond_surr, var_gen = opt_eval_info(f.cond, var_gen);
          code = code & cond_code;
          maybe_cond = just(bool_value(cond_surr));
        else
          maybe_cond = nothing;
        ;

        field_code, surr, var_gen = opt_eval_info(f.value, var_gen);
        set_field_instr = write_rec_field(var, label, low_level_expr(field.repr, surr), field.optional);
        field_code = (field_code | set_field_instr);
        if maybe_cond != nothing:
          cond_surr = value(maybe_cond);
          field_code = (do_if(value(maybe_cond), field_code));
        ;

        code = code & field_code;
      ;

      return (code, var, var_gen);
    }
  }


  // seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) seq_comp_opt_eval_info(SeqCompExpr expr, VarGen init_var_gen) {
    // Generating the result variable and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    var_gen = ret_var_gen;

    // Calculating source type, and returning early if the type is trivial
    src_type = subexpr_type(expr.src_expr);
    if src_type == empty_type:
      return ((terminate), never_used_lvar, init_var_gen);
    elif is_subset(src_type, empty_seq_type):
      return ((), empty_seq, init_var_gen);
    ;

    // Types of elements of source and destination sequences
    src_elt_type = seq_elem_supertype(src_type);
    elt_type = subexpr_type(expr.expr);
    fail if src_elt_type == empty_type or elt_type == empty_type;

    // Low-level representation of elements of source and destination sequences
    src_repr = low_level_repr(src_elt_type);
    elt_repr = low_level_repr(elt_type);

    // Evaluation of source expression
    eval_code, src_surr, var_gen = opt_eval_info(expr.src_expr, var_gen);
    fail if not src_surr :: <LocVar, StdVar>; ## MAYBE THIS COULD BE AVOIDED...

    // Temporary buffer for source data
    buffer_var, var_gen = next_array_var(var_gen, src_repr);

    // Allocation of destination array
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    eval_code = (eval_code | alloc_array(array_var, get_size(src_surr)));

    vars = expr.vars;
    if |vars| == 1:
      var = only(vars);
      physical_var, var_gen = next_var_def(src_repr, var, var_gen);
      surrs = surrogates & [var -> obj_expr(physical_var)];
      it_var = physical_var;
      body_code = ();

    else
      assert src_repr == :object;
      vars_types = (restricted_seq_elem_supertype(src_type, singleton_type(i)) : i < |vars|);
      fail if not vars_types :: NeType+;
      reprs = (low_level_repr(t) : t <- vars_types);
      physical_vars, var_gen = mapli(vars, var_gen, next_var_def(reprs($b), $a, $c));
      surrs = surrogates & [v -> obj_expr(physical_vars(i)) : v @ i <~ vars];
      it_var, var_gen = next_obj_var(var_gen);
      body_code = (set_any_var(v, at(it_var, i)) : v @ i <- physical_vars);
    ;

    // Index variables
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    surrs = surrs & [expr.idx_var -> int_obj(hidden_idx_var)] if expr.idx_var?;

    // Evaluation of destination element expression
    elt_eval_code, elt_surr, var_gen = opt_eval_info(expr.expr, var_gen, surrogates = surrs);

    // Finalizing loop body
    body_code = body_code & elt_eval_code;
    if expr.sel_expr?:
      target_idx_var, var_gen = next_int32_var(var_gen);
      cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.sel_expr, var_gen, surrogates = surrs);
      body_code = (body_code | write_array(array_var, target_idx_var, elt_surr), increment(target_idx_var));
      body_code = (cond_eval_code | do_if(bool_value(cond_surr), body_code));
      loop_init_code = (set_ivar32(target_idx_var, 0));
      mk_seq_instr = mk_seq(res_var, array_var, target_idx_var);

    else
      body_code = (body_code | write_array(array_var, hidden_idx_var, elt_surr));
      loop_init_code = ();
      mk_seq_instr = mk_seq(res_var, array_var);
    ;

    // Mapping source to destination arrays
    map_instr = traverse_array(src_surr, buffer_var, array_var, hidden_idx_var, it_var, body_code);

    eval_code = (eval_code & loop_init_code | map_instr, mk_seq_instr);
    return (eval_code, res_var, ret_var_gen);
  }


  // range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) range_comp_opt_eval_info(RangeCompExpr expr, VarGen init_var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) if_expr_opt_eval_info(IfExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate), never_used_lvar, init_var_gen) if type == empty_type;
    repr = low_level_repr(type);

    cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.cond, init_var_gen);

    res_var, var_gen = next_var(repr, var_gen);
    then_eval_code, unused_var = opt_eval_info(expr.then, res_var, var_gen);
    else_eval_code, unused_var = opt_eval_info(expr.else, res_var, var_gen);

    eval_code = (cond_eval_code | branch(bool_value(cond_surr), then_eval_code, else_eval_code));
    return (eval_code, obj_expr(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) eq_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    left_eval_code, left_surr, var_gen = opt_eval_info(left, init_var_gen);
    right_eval_code, right_surr, var_gen = opt_eval_info(right, var_gen);

    eval_code = left_eval_code & right_eval_code;
    return (eval_code, bool_obj(is_eq(left_surr, right_surr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) and_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == ():
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = and_then(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    ;

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, unused_var = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, unused_var = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) or_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == ():
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = or_else(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    ;

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, unused_var = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, unused_var = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if_not(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) not_expr_opt_eval_info(Expr expr, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    return (eval_code, bool_obj(neg(bool_value(surr_expr))), var_gen);
  }


  (Instr*, ObjExpr, VarGen) unary_pseudo_call_opt_eval_info(Expr target, Expr arg, VarGen init_var_gen) {
    target_type = subexpr_type(target);
    return ((terminate), never_used_lvar, init_var_gen) if target_type == empty_type;

    coll_eval_code, coll_surr, var_gen = opt_eval_info(target, init_var_gen);
    arg_eval_code, arg_surr, var_gen = opt_eval_info(arg, var_gen);
    eval_code = coll_eval_code & arg_eval_code;

    if is_subset(target_type, type_seq):
      expr_surr = at(coll_surr, get_int_val(arg_surr));

    elif is_subset(target_type, type_set):
      expr_surr = bool_obj(has_elem(coll_surr, arg_surr));

    elif is_subset(target_type, type_map):
      expr_surr = lookup(coll_surr, arg_surr);

    else
      assert is_subset(target_type, atom_type);
      expr_surr, var_gen = next_obj_var(var_gen);
      eval_code = (eval_code | mk_tagged_obj(expr_surr, coll_surr, arg_surr));
      var_gen = init_var_gen;
    ;

    return (eval_code, expr_surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) size_expr_opt_eval_info(Expr collection, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(collection, init_var_gen);
    return (eval_code, int_obj(get_size(surr_expr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_expr_opt_eval_info(SubExpr* elts, VarGen init_var_gen) {
    // Empty sequence
    return ((), empty_seq, init_var_gen) if elts == ();

    // Types of elements of the sequence
    elts_types = [subexpr_type(if is_cond_expr(e) then e.expr else e) : e <~ elts];
    elts_type = union_superset(elts_types);

    // Unreachable expression
    return ((terminate), never_used_lvar, init_var_gen) if elts_types(empty_type) or elts_type == empty_type;

    // Elements representation
    elt_repr = low_level_elt_repr(elts_type);

    // Sequence and array variables
    seq_var, var_gen = next_obj_var(init_var_gen);
    array_var, var_gen = next_array_var(var_gen, elt_repr);

    // Both seq_var and array_var must survive the evaluation of the expression
    ret_var_gen = var_gen;

    conds = (e.cond : e <- elts, is_cond_expr(e));
    if conds == ():
      // Easy case, no conditional inclusions
      code = (alloc_array(array_var, int32(|elts|)));
      for e @ i <- elts:
        fail if is_cond_expr(e); ## ANY BETTER WAY TO DO THIS?
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
        code = code & (elt_eval_code | write_array(array_var, i, elt_surr));
      ;
      code = (code | mk_seq(seq_var, array_var));
      return (code, seq_var, ret_var_gen);
    ;

    // Evaluation of all conditions
    ## HERE MAYBE WE COULD DO BETTER WITH THE VARIABLES GENERATOR
    cond_vars, var_gen = next_bool_vars(var_gen, |conds|);
    conds_eval_code = join((opt_eval_code(c, cond_vars(i), var_gen) : c @ i <- conds));

    // Integer variable for both size and cursor
    int32_var, var_gen = next_int32_var(var_gen);

    // Computation of final array size
    len_expr = foldr(nonempty((bool_to_bit(v) : v <- cond_vars)), add32);
    min_size = int32(|elts| - |conds|);
    len_expr = add32(min_size, len_expr) if min_size != 0;
    conds_eval_code = (conds_eval_code | set_ivar32(int32_var, len_expr));

    // Destination array allocation
    code = (alloc_array(array_var, int32_var));

    // Computation of all array elements
    cond_expr_idx = 0;
    for e @ i <- elts:
      is_last = i == |elts| - 1;
      if is_cond_expr(e): // Conditional inclusion expression
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e.expr, var_gen);
        // If it's the first conditional expression, we statically know the
        // destination array index. After that we need to use the cursor variable
        write_code = if cond_expr_idx == 0
          then (write_array(array_var, i, elt_surr), set_ivar32(int32_var, int32(i+1)))
          else (write_array(array_var, int32_var, elt_surr), increment(int32_var) if not is_last);
        // Making the inclusion conditional
        code = (code | do_if(cond_vars(cond_expr_idx), elt_eval_code & write_code));
        cond_expr_idx = cond_expr_idx + 1;

      else // Non-conditional expression
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
        // Until we reach the first conditional element we statically know the
        // destination array index. After that we need to use the cursor variable
        write_code = if cond_expr_idx == 0
          then (write_array(array_var, i, elt_surr))
          else (write_array(array_var, int32_var, elt_surr), increment(int32_var) if not is_last);
        code = code & elt_eval_code & write_code;
      ;
    ;

    // Creation of the wrapping sequence object
    code = (code | mk_seq(seq_var, array_var));

    // Checking for the empty sequence case, if all expression are conditional
    code = (branch(is_eq(int32_var, 0), (set_var(seq_var, empty_seq)), code)) if min_size == 0;

    return (conds_eval_code & code, seq_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) fn_call_opt_eval_info(FnCallExpr expr, VarGen init_var_gen) {
    // fn_call(fn_id: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr])
    assert expr.impl_args == [];
    fail if not expr.args :: Expr* or not expr.impl_args :: [ImplArg -> ExprRef];

    // Actual arguments information
    args_types = (subexpr_type(a) : a <- expr.args);

    // Evaluation of the arguments
    args_eval_code, args_surrs, unused_var = opt_eval_info(expr.args, init_var_gen);

    // Signature of the target function
    fn_id, low_level_sign = low_level_sign(expr.fn_id, args_types);

    // Low-level actual arguments
    low_level_args = (low_level_expr(low_level_sign.args(i), s) : s @ i <- args_surrs);

    // Return value variable. Once the call returns the arguments
    // are not needed anymore, so we can reuse the variables
    res_var, var_gen = next_var(low_level_sign.ret_value, init_var_gen);

    // Evaluation code for the call only
    cls_args = (compiled_closure(a, next_var_gen = init_var_gen) : a <- expr.cls_args);
    eval_code = (args_eval_code | call_proc(res_var, fn_id, low_level_args, cls_args));

    return (eval_code, obj_expr(res_var), var_gen);
  }


  // builtin_call(name: BuiltIn, args: Expr+);
  (Instr*, ObjExpr, VarGen) builtin_call_opt_eval_info(BuiltinCall expr, VarGen init_var_gen) {
    // Evaluation of the arguments
    args_eval_code, args_surrs, unused_var = opt_eval_info(expr.args, init_var_gen);

    // Builtin call. The arguments are not needed anymore once the call
    // returns, so we can restart from the initial variables generator
    code, surr, var_gen = eval_info(expr.name, nonempty(args_surrs), init_var_gen);

    return (args_eval_code & code, surr, var_gen);


    (Instr*, ObjExpr, VarGen) eval_info(BuiltIn name, ObjExpr+ args, VarGen init_var_gen) =
      slice   |
      cat     |
      rev     |
      isort   |
      parse   |
      print   |
      str     = { res_var, var_gen = next_obj_var(init_var_gen);
                  instr = eval_instr(name, args, res_var);
                  return ((instr), res_var, var_gen);
                },
      _       = ((), eval_expr(name, args), init_var_gen);


    Instr eval_instr(BuiltIn name, ObjExpr+ args, LocVar res_var) =
      slice         = get_seq_slice(res_var, args(0), get_int_val(args(1)), get_int_val(args(2))),
      cat           = join_seqs(res_var, args(0), args(1)),
      rev           = rev_seq(res_var, args(0)),
      isort         = internal_sort(res_var, args(0)),
      parse         = parse_value(res_var, args(0)),
      print         = print_value(res_var, args(0)),
      str           = symb_to_str(res_var, args(0));


    ObjExpr eval_expr(BuiltIn name, ObjExpr+ args) =
      neg       |
      add       |
      sub       |
      mult      |
      div       |
      mod       |
      and       |
      or        |
      xor       = int_obj(int_op_eval_info(name, (get_int_val(a) : a <- args))),
      lt        |
      le        = bool_obj(bool_op_eval_info(name, (get_int_val(a) : a <- args))),
      flt       |
      fle       = bool_obj(floats_to_bool_op_eval_info(name, (float_value(a) : a <- args))),
      bits      |
      mantissa  |
      dec_exp   = int_obj(int_op_eval_info(name, float_value(args(0)))),
      fneg      |
      fadd      |
      fsub      |
      fmult     |
      fdiv      |
      fexp      |
      fsqrt     = float_obj(float_op_eval_info(name, (float_value(a) : a <- args))),
      float     = float_obj(int_to_float(get_int_val(args(0)))),
      symb      = to_symb(args(0)),
      tag       = get_tag(args(0)),
      untag     = get_inner_obj(args(0));



    BoolExpr bool_op_eval_info(BuiltIn, IntExpr+ args) =
      lt  = is_lt(args(0), args(1)),
      le  = is_le(args(0), args(1));

    BoolExpr floats_to_bool_op_eval_info(BuiltIn, FloatExpr+ args) =
      flt   = is_flt(args(0), args(1)),
      fle   = is_fle(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, IntExpr+ args) =
      neg   = minus(args(0)),
      add   = add(args(0), args(1)),
      sub   = sub(args(0), args(1)),
      mult  = mult(args(0), args(1)),
      div   = div(args(0), args(1)),
      mod   = mod_op(args(0), args(1)),
      and   = bitwise_and(args(0), args(1)),
      or    = bitwise_or(args(0), args(1)),
      xor   = bitwise_xor(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, FloatExpr arg) =
      bits      = float_bits(arg),
      mantissa  = mantissa(arg),
      dec_exp   = dec_exp(arg);

    FloatExpr float_op_eval_info(BuiltIn, FloatExpr+ args) =
      fneg  = neg_float(args(0)),
      fadd  = add_floats(args(0), args(1)),
      fsub  = sub_floats(args(0), args(1)),
      fmult = mult_floats(args(0), args(1)),
      fdiv  = div_floats(args(0), args(1)),
      fexp  = exp_floats(args(0), args(1)),
      fsqrt = square_root(args(0));
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Instr+ store_result(Instr* code, ObjExpr surr_expr, AnyLocVar res_var) {
  def_code = (code | set_any_var(res_var, surr_expr));
  return def_code if code == ();
  trimmed_code = take(code, |code| - 1);

  return match (rat(code, 0))
    set_bvar()   i? |
    set_ivar()   i? |
    set_ivar32() i? | ## WHY DOES THIS EXPRESSION TYPECHECKS EVEN WITH AN Int32Var?
    set_fvar()   i? |
    set_var()    i? = if i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                        then (trimmed_code | set_any_var(res_var, obj_expr(i.value)))
                        else def_code,

    call_proc()  i? = if i.var? and i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                        then (trimmed_code | call_proc(res_var, i.name, i.args, i.cls_args))
                        else def_code,

    _               = def_code;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type AnyLocVar = LocBoolVar, LocIntVar, LocFloatVar, LocVar, StdVar;


(AnyLocVar, VarGen) next_var(LowLevelRepr repr, VarGen gen) =
  bool    = next_bool_var(gen),
  int     = next_int_var(gen),
  float   = next_float_var(gen),
  symbol  |
  object  = next_obj_var(gen);


## FIND BETTER NAME
(AnyLocVar, VarGen) next_var_def(LowLevelRepr repr, StdVar var, VarGen var_gen) =
  bool      |
  int       |
  float     = next_var(repr, var_gen),
  symbol    |
  object    = (var, var_gen);


Instr set_any_var(LocBoolVar  var, ObjExpr expr) = set_bvar(var, bool_value(expr));
Instr set_any_var(LocIntVar   var, ObjExpr expr) = set_ivar(var, get_int_val(expr));
Instr set_any_var(LocFloatVar var, ObjExpr expr) = set_fvar(var, float_value(expr));
Instr set_any_var(WriteObjVar var, ObjExpr expr) = set_var(var, expr);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(B*, C) mapl(A* xs, C seed, (A C -> (B, C)) next) {
  ys = ();
  state = seed;
  for x <- xs:
    y, state = next(x, state);
    ys = (ys | y);
  ;
  return (ys, state);
}


// (Y*, S) mapli(X* xs, S seed, (X x, Nat i, S s -> (Y, S)) next)
(B*, C) mapli(A* xs, C seed, (A Nat C -> (B, C)) next) {
  ys = ();
  state = seed;
  for x @ i <- xs:
    y, state = next(x, i, state);
    ys = (ys | y);
  ;
  return (ys, state);
}
