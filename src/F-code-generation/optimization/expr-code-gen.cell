implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         cluster           : Expr+,
         types             : Type+,
         environments      : [EnvVar -> Type]+,
         surrogates        : [SurrExpr -> ObjExpr],
         expr_id           : Nat,
         options           : CompOptions {

  Type subexpr_type(Expr) =
    expr_ref(id?) = types(id);

  Expr expand_subexpr(Expr) =
    expr_ref(id?) = cluster(id);

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, VarGen) opt_eval_info(Expr expr, AnyLocVar res_var, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    eval_code = store_result(eval_code, surr_expr, res_var);
    return (eval_code, var_gen);
  }


  (Instr*, ObjExpr*, VarGen) opt_eval_info((), VarGen var_gen) = ((), (), var_gen);

  (Instr*, ObjExpr+, VarGen) opt_eval_info(Expr+ exprs, VarGen init_var_gen) {
    var_gen = init_var_gen;
    code = ();
    surrs = ();
    for e <- exprs:
      expr_code, surr, var_gen = opt_eval_info(e, var_gen);
      code = code & expr_code;
      surrs = (surrs | surr);
    ;
    return (code, nonempty(surrs), var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, ObjExpr, VarGen) opt_eval_info(<undefined>, VarGen var_gen) {
    return ((terminate), :invalid_var, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(LeafObj expr, VarGen var_gen) {
    return ((), expr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(FloatLit expr, VarGen var_gen) {
    return ((), float_obj(expr), var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(Var var, VarGen var_gen) {
    return ((), eval_var(var, var_subst_map, surrogates), var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsDefExpr expr, VarGen var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsSetExpr expr, VarGen var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(ExprRef expr, VarGen var_gen) {
    id = untag(expr);
    return opt_eval_info(cluster(id), var_gen, expr_id = id);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(RecExpr expr, VarGen var_gen) =
    seq_expr(ses?)      |
    tuple_expr(ses?)    = seq_expr_opt_eval_info(ses, var_gen),
    seq_tail_expr()     = seq_tail_expr_opt_eval_info(expr.seq, expr.tail, var_gen),
    set_expr(ses?)      = set_expr_opt_eval_info(ses, var_gen),
    map_expr(es?)       = map_expr_opt_eval_info(es, var_gen),
    bin_rel_expr(es?)   = bin_rel_expr_opt_eval_info(es, var_gen),
    tern_rel_expr(es?)  = tern_rel_expr_opt_eval_info(es, var_gen),
    tag_obj_expr()      = tag_obj_expr_opt_eval_info(expr, var_gen),
    fn_call()           = fn_call_opt_eval_info(expr, var_gen),
    cls_call()          = cls_call_opt_eval_info(expr.name, expr.args, var_gen),
    builtin_call()      = builtin_call_opt_eval_info(expr, var_gen),
    size_expr()         = size_expr_opt_eval_info(expr.coll, var_gen),
    unary_pseudo_call() = unary_pseudo_call_opt_eval_info(expr.target, expr.arg, var_gen),
    rel_memb_test()     = rel_memb_test_opt_eval_info(expr.rel, expr.args, var_gen),
    rel_lookup()        = rel_lookup_opt_eval_info(expr, var_gen),
    // relvar_memb_test()  = undefined,
    // relvar_lookup()     = undefined,
    and_expr()          = and_expr_opt_eval_info(expr.left, expr.right, var_gen),
    or_expr()           = or_expr_opt_eval_info(expr.left, expr.right, var_gen),
    not_expr(e?)        = not_expr_opt_eval_info(e, var_gen),
    eq()                = eq_expr_opt_eval_info(expr.left, expr.right, var_gen),
    membership()        = membership_opt_eval_info(expr.obj, expr.type, var_gen),
    // cast_expr()         = undefined,
    accessor()          = accessor_opt_eval_info(expr.expr, expr.field, var_gen),
    accessor_test()     = accessor_test_opt_eval_info(expr.expr, expr.field, var_gen),
    // auto_method_call()  = undefined,
    // db_method_call()    = undefined,
    if_expr()           = if_expr_opt_eval_info(expr, var_gen),
    match_expr()        = match_expr_opt_eval_info(expr, var_gen),
    do_expr()           = do_expr_opt_eval_code(expr, environments(expr_id), var_gen),
    ex_qual()           = ex_qual_opt_eval_info(expr.source, expr.cond, var_gen),
    set_comp()          = set_comp_opt_eval_info(expr.expr, expr.source, var_gen),
    map_comp()          = map_comp_opt_eval_info(expr, var_gen),
    bin_rel_comp()      = bin_rel_comp_opt_eval_info(expr, var_gen),
    tern_rel_comp()     = tern_rel_comp_opt_eval_info(expr, var_gen),
    seq_comp()          = seq_comp_opt_eval_info(expr, var_gen),
    range_comp()        = range_comp_opt_eval_info(expr, var_gen);


  // ex_qual(source: Clause, cond: Expr)
  (Instr*, ObjExpr, VarGen) ex_qual_opt_eval_info(Clause source, Expr cond, VarGen init_var_gen) {
    res_var, var_gen = next_bool_var(init_var_gen);

    bottom_action = yield_value_action(res_var, cond, (exit_block_if(res_var)));
    action = yield_action(source, bottom_action);
    code = yield_action_opt_code(action, var_gen);

    code = (set_bvar(res_var, false), execute_block(nonempty(code)));
    return (code, obj_expr(res_var), var_gen);
  }

  // set_comp(expr: Expr, source: Clause);
  (Instr*, ObjExpr, VarGen) set_comp_opt_eval_info(Expr expr, Clause source, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info((expr), source, var_gen);
    return ((code | mk_set(res_var, only_unsafe(strms))), res_var, var_gen);
  }


  // map_comp(key_expr: Expr, value_expr: Expr, source: Clause)
  (Instr*, ObjExpr, VarGen) map_comp_opt_eval_info(MapCompExpr expr, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info((expr.key_expr, expr.value_expr), expr.source, var_gen);
    assert |strms| == 2;
    return ((code | mk_map(res_var, strms(0), strms(1))), res_var, var_gen);
  }


  // bin_rel_comp(exprs: (Expr, Expr), source: Clause)
  (Instr*, ObjExpr, VarGen) bin_rel_comp_opt_eval_info(BinRelCompExpr expr, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info(expr.exprs, expr.source, var_gen);
    assert |strms| == 2;
    return ((code | mk_rel(res_var, strms(0), strms(1))), res_var, var_gen);
  }


  // tern_rel_comp(exprs: (Expr, Expr, Expr), source: Clause)
  (Instr*, ObjExpr, VarGen) tern_rel_comp_opt_eval_info(TernRelCompExpr expr, VarGen init_var_gen) {
    res_var, var_gen = next_obj_var(init_var_gen);
    code, strms = rel_comp_partial_eval_info(expr.exprs, expr.source, var_gen);
    assert |strms| == 3;
    return ((code | mk_rel(res_var, strms(0), strms(1), strms(2))), res_var, var_gen);
  }


  (Instr*, StreamVar*) rel_comp_partial_eval_info(Expr+ exprs, Clause source, VarGen init_var_gen) {
    arg_vars,  var_gen = next_obj_vars(init_var_gen, |exprs|);
    strm_vars, var_gen = next_stream_vars(var_gen, |exprs|);

    args_info = nonempty(zip(exprs, arg_vars, strm_vars));

    bottom_action = yield_actions((yield_value_action(v, e, (append(sv, v))) : e, v, sv <- args_info));
    action = yield_action(source, bottom_action);
    nested_code = yield_action_opt_code(action, var_gen);

    code = (init_stream(v) : v <- strm_vars) & nested_code;
    return (code, strm_vars);
  }


  // match_expr(exprs: Expr+, cases: (ptrns: Pattern+, expr: Expr)+);
  (Instr*, ObjExpr, VarGen) match_expr_opt_eval_info(MatchExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate(true)), :invalid_var, init_var_gen) if type == empty_type;
    repr = opt_repr(type);
    res_var, var_gen = next_var(repr, init_var_gen);
    ret_var_gen = var_gen;

    if |expr.exprs| == 1:
      match_expr = only(expr.exprs);
      match_expr_type = subexpr_type(match_expr);
      match_expr_code, match_expr_surr, var_gen = opt_eval_info(match_expr, var_gen);

      cases = ({
          ptrn = only_unsafe(c.ptrns);
          ptrn_env = generate_env(ptrn, match_expr_type);
          vars_reprs = [v -> low_level_var(opt_repr(t), v) : v, t <- ptrn_env];
          surrs = surrogates & [v -> obj_expr(pv) : v, pv <- vars_reprs];
          code, surr, unused_var = opt_eval_info(c.expr, var_gen, surrogates = surrs);
          code = (store_result(code, surr, res_var) | exit_block);
          return (ptrn, code, vars_reprs);
        } : c <- expr.cases
      );

      match_code = single_ptrn_match_expr_opt_code(match_expr_surr, match_expr_type, cases);
      return (match_expr_code & match_code, obj_expr(res_var), ret_var_gen);

    else
      exprs_types = (subexpr_type(e) : e <- expr.exprs);
      exprs_eval_code, exprs_surrs, var_gen = opt_eval_info(expr.exprs, var_gen);

      cases_code = ({
          ptrns_env = merge((generate_env(p, exprs_types(i)) : p @ i <- c.ptrns));
          vars_reprs = [v -> low_level_var(opt_repr(t), v) : v, t <- ptrns_env];
          surrs = surrogates & [v -> obj_expr(pv) : v, pv <- vars_reprs];
          code, surr, unused_var = opt_eval_info(c.expr, var_gen, surrogates = surrs);
          code = (store_result(code, surr, res_var) | exit_block);
          for p, t, s <- reverse(zip(c.ptrns, exprs_types, exprs_surrs)):
            code = opt_ptrn_match_code(p, s, t, code, vars_reprs = vars_reprs);
          ;
          return code;
        } : c <- expr.cases
      );

      code = (exprs_eval_code | execute_block((join(cases_code) | terminate)));
      return (code, obj_expr(res_var), ret_var_gen);
    ;
  }


  // rel_lookup(rel: Expr, set_args: Expr*, unknown_arg_idx: Nat);
  (Instr*, ObjExpr, VarGen) rel_lookup_opt_eval_info(RelLookup expr, VarGen init_var_gen) {
    // Physical representation of the result and variable that stores it
    type = types(expr_id);
    return ((terminate), :invalid_var, init_var_gen) if type == empty_type;

    repr = opt_repr(type);
    res_var, ret_var_gen = next_var(repr, init_var_gen);

    // Evaluation of all subexpressions
    code, rel_surr, var_gen = opt_eval_info(expr.rel, ret_var_gen);
    args_surrs = ();
    for e <- expr.set_args:
      arg_code, arg_surr, var_gen = opt_eval_info(e, var_gen);
      code = code & arg_code;
      args_surrs = (args_surrs | arg_surr);
    ;

    if args_surrs == ():
      code = (code | check(is_eq(get_size(rel_surr), 1)), set_any_var(res_var, rand_elem(rel_surr)));

    elif |args_surrs| == 1:
      arg_surr = only(args_surrs);
      if expr.unknown_arg_idx == 1:
        code = (code | set_any_var(res_var, lookup(rel_surr, arg_surr)));
      else
        it_var, var_gen = next_bin_rel_it_var(var_gen);
        code = (code |
          get_iter(it_var, rel_surr, (nothing, just(arg_surr))),
          check(neg(is_out_of_range(it_var))),
          set_any_var(res_var, get_curr_arg(it_var, 0)),
          move_forward(it_var),
          check(is_out_of_range(it_var))
        );
      ;

    else
      it_var, var_gen = next_tern_rel_it_var(var_gen);
      search_args = insert((just(a) : a <- args_surrs), expr.unknown_arg_idx, nothing);
      fail if |search_args| != 3 or not expr.unknown_arg_idx :: <0..2>;
      code = (code |
        get_iter(it_var, rel_surr, search_args),
        check(neg(is_out_of_range(it_var))),
        set_any_var(res_var, get_curr_arg(it_var, expr.unknown_arg_idx)),
        move_forward(it_var),
        check(is_out_of_range(it_var))
      );
    ;

    return (code, obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) rel_memb_test_opt_eval_info(Expr rel, Maybe[Expr]+ args, VarGen init_var_gen) {
    args_surrs : Maybe[ObjExpr]*; ## WHY IS THIS NEEDED? IS THIS A BUG IN THE TYPECHECKER?

    res_var, ret_var_gen = next_bool_var(init_var_gen);

    code, rel_surr, var_gen = opt_eval_info(rel, ret_var_gen);

    args_surrs = ();
    for a <- args:
      if a != nothing:
        arg_code, arg_surr, var_gen = opt_eval_info(value(a), var_gen);
        code = code & arg_code;
        args_surrs = (args_surrs | just(arg_surr));
      else
        args_surrs = (args_surrs | nothing);
      ;
    ;

    if not (a <~ args_surrs : a == nothing): ## THIS SHOULD NARROW DOWN THE TYPE OF args_surrs
      search_instr = set_bvar(res_var, contains(rel_surr, nonempty((value_unsafe(a) : a <- args_surrs))));
      code = (code | search_instr);

    else
      if |args_surrs| == 2:
        it_var, var_gen = next_bin_rel_it_var(var_gen);
        get_iter_instr = get_iter(it_var, rel_surr, args_surrs);

      else
        fail if |args_surrs| != 3;
        it_var, var_gen = next_tern_rel_it_var(var_gen);
        get_iter_instr = get_iter(it_var, rel_surr, args_surrs);
      ;

      code = (code | get_iter_instr, set_bvar(res_var, neg(is_out_of_range(it_var))));
    ;

    return (code, obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_tail_expr_opt_eval_info(Expr seq, Expr+ tail, VarGen init_var_gen) {
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    code, seq_surr, var_gen = opt_eval_info(seq, ret_var_gen);
    for e @ i <- tail:
      elt_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
      src_seq = if i == 0 then seq_surr else res_var;
      code = (code & elt_code | append_to_seq(res_var, src_seq, elt_surr));
    ;
    return (code, res_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) membership_opt_eval_info(Expr obj, NeType type, VarGen init_var_gen) {
    pred = memb_test_preds_map[type];
    res_var, ret_var_gen = next_bool_var(init_var_gen);
    code, surr, var_gen = opt_eval_info(obj, ret_var_gen);
    return ((code | set_bvar(res_var, is_member(pred, surr))), obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) accessor_opt_eval_info(Expr expr, SymbObj field, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_info(expr, init_var_gen);
    target_type = subexpr_type(expr);
    maybe_repr = nothing;
    if is_subset(target_type, tag_obj_type(atom_type, type_any)):
      tag_type = tag_supertype(target_type);
      if is_symb_singl_type(tag_type):
        tag_obj = only_symb(tag_type);
        tag = untag(tag_obj);
        tag_type = symb_type(tag_obj);
        opt_types = if optimized_tagged_records_types(tag, *)
          then optimized_tagged_records_types(tag, !!)
          else ();
        for t @ i <- opt_types:
          if is_subset(target_type, tag_obj_type(tag_type, t)):
            surr = cast_opt_tag_rec(tag, i, surr) if not surr :: OptTagRecVar;
            fields_reprs = untag(optimized_tagged_records(tag, !!)(i));
            maybe_repr = just(fields_reprs(untag(field), !!).repr);
            break;
          ;
        ;
      ;
    ;
    return (code, lookup_field(surr, field, maybe_repr), var_gen);
  }


  (Instr*, ObjExpr, VarGen) accessor_test_opt_eval_info(Expr expr, SymbObj field, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_info(expr, init_var_gen);
    return (code, bool_obj(has_field(surr, field)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) record_opt_eval_info(SymbObj+ labels, Expr+ values, VarGen init_var_gen) {
    var, var_gen = next_obj_var(init_var_gen);
    code, surrs, var_gen = opt_eval_info(values, var_gen);
    code = (code | mk_record(var, [l -> surrs(i) : l @ i <~ labels]));
    return (code, var, var_gen);
  }


  (Instr*, ObjExpr, VarGen) tag_obj_expr_opt_eval_info(TagObjExpr expr, VarGen init_var_gen) {
    tag_type = subexpr_type(expr.tag);
    if is_symb_singl_type(tag_type):
      // The tag is a known symbol
      tag = untag(only_symb(tag_type));
      may_need_conv = false;
      if optimized_tagged_records(tag, *):
        // There's at least one optimized representation for values with such tag
        reprs = optimized_tagged_records(tag, !!);
        obj_expr = expr.obj;
        obj_type = subexpr_type(obj_expr);
        for repr @ repr_idx <- reprs:
          repr_type = low_level_repr_type(repr);
          if is_subset(obj_type, repr_type):
            // The tagged value has an optimized representation
            // assert not may_need_conv; ## SEE COMMENT BELOW
            return opt_rec_eval_info(tag, obj_expr, repr, repr_idx, init_var_gen);
          elif not are_ptype_disjoint(obj_type, repr_type):
            ## THIS DOESN'T MAKE MUCH SENSE. obj_type AND repr_type ARE NEVER
            ## GOING TO BE PTYPE DISJOINT, BECAUSE THEY ARE BOTH RECORDS
            ## WE NEED A BETTER CHECK, FOR EXAMPLE WE COULD SEE IF
            ## THEIR SET OF FIELDS ARE COMPATIBLE
            may_need_conv = true;
          ;
        ;
      ;
      // The tagged value may or may not have an optimized representation
      code, value_surr, var_gen = opt_eval_info(expr.obj, init_var_gen);
      var, var_gen = next_obj_var(var_gen);
      creation_instr = if may_need_conv
        then call_proc(var, :tag_rec_conv(tag), (value_surr), ())
        else mk_tagged_obj(var, object(tag), value_surr);
      code = (code | creation_instr);
      return (code, var, var_gen);

    else
      // The symbol is not known at compile time
      tag_code, tag_surr, var_gen = opt_eval_info(expr.tag, init_var_gen);
      value_code, value_surr, var_gen = opt_eval_info(expr.obj, var_gen);
      var, var_gen = next_obj_var(var_gen);
      ## HERE WE COULD CHECK IF THE TARGET OBJECT NEEDS TO BE OPTIMIZED
      code = (tag_code & value_code | call_proc(var, :any_tag_rec_conv, (tag_surr, value_surr), ()));
      return (code, var, var_gen);
    ;


    (Instr*, ObjExpr, VarGen) opt_rec_eval_info(Symbol tag, Expr rec_expr_ref, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      rec_expr = expand_subexpr(rec_expr_ref);
      if rec_expr :: MapExpr:
        // The expression that defines the tagged value is a map expression
        fields = isort(untag(rec_expr));
        keys_types = (subexpr_type(f.key) : f <- fields);
        if not (t <~ keys_types : not is_symb_singl_type(t)):
          // Every key in the map expression is a known symbol
          labels = (untag(only_symb(t)) : t <- keys_types);
          return direct_opt_rec_eval_info(tag, labels, rec_expr, repr, repr_idx, init_var_gen);
        ;
      ;

      // Generic creation: evaluating the record expression first, then
      // passing it on to the representation-specific conversion function
      code, value_surr, var_gen = opt_eval_info(rec_expr, init_var_gen);
      var, var_gen = next_opt_tag_rec_var(var_gen, tag, repr_idx);
      code = (code | call_proc(var, :tag_rec_repr_conv(tag, repr_idx), (value_surr), ()));
      return (code, var, var_gen);
    }


    (Instr*, ObjExpr, VarGen) direct_opt_rec_eval_info(Symbol tag, Symbol+ labels, MapExpr rec_expr, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      low_level_fields = untag(repr);
      var, var_gen = next_opt_tag_rec_var(init_var_gen, tag, repr_idx);
      surrs = ();
      conds = ();
      code = (inst_opt_tag_rec(var, tag, repr_idx));
      var_gen = init_var_gen;
      for f @ i <- isort(untag(rec_expr)):
        label = labels(i);
        field = low_level_fields(label, !!);

        if f.cond?:
          cond_code, cond_surr, var_gen = opt_eval_info(f.cond, var_gen);
          code = code & cond_code;
          maybe_cond = just(bool_value(cond_surr));
        else
          maybe_cond = nothing;
        ;

        field_code, surr, var_gen = opt_eval_info(f.value, var_gen);
        set_field_instr = write_rec_field(var, label, low_level_expr(field.repr, surr), field.optional);
        field_code = (field_code | set_field_instr);
        if maybe_cond != nothing:
          cond_surr = value(maybe_cond);
          field_code = (do_if(value(maybe_cond), field_code));
        ;

        code = code & field_code;
      ;

      return (code, var, var_gen);
    }
  }


  // seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) seq_comp_opt_eval_info(SeqCompExpr expr, VarGen init_var_gen) {
    // Generating the result variable and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    var_gen = ret_var_gen;

    // Calculating source type, and returning early if the type is trivial
    src_type = subexpr_type(expr.src_expr);
    if src_type == empty_type:
      return ((terminate), :invalid_var, init_var_gen);
    elif is_subset(src_type, empty_seq_type):
      return ((), empty_seq, init_var_gen);
    ;

    // Types of elements of source and destination sequences
    src_elt_type = seq_elem_supertype(src_type);
    elt_type = subexpr_type(expr.expr);
    fail if src_elt_type == empty_type or elt_type == empty_type;

    // Low-level representation of elements of source and destination sequences
    src_repr = opt_repr(src_elt_type);
    elt_repr = opt_repr(elt_type);

    // Evaluation of source expression
    eval_code, src_surr, var_gen = opt_eval_info(expr.src_expr, var_gen);
    if not src_surr :: <LocVar, StdVar>:
      src_var, var_gen = next_obj_var(var_gen);
      eval_code = (eval_code | set_var(src_var, src_surr));
      src_surr = src_var;
    ;

    // Temporary buffer for source data
    src_array_var, var_gen = next_array_var(var_gen, src_repr);

    // Allocation of destination array
    array_size_var, var_gen = next_int32_var(var_gen);
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    eval_code = (eval_code |
      set_ivar32(array_size_var, get_size(src_surr)),
      alloc_array(array_var, array_size_var)
    );

    vars = expr.vars;
    if |vars| == 1:
      var = only(vars);
      it_var = low_level_var(src_repr, var);
      surrs = surrogates & [var -> obj_expr(it_var) if var != it_var];
      body_code = ();

    else
      assert src_repr == :object;
      vars_types = tuple_field_supertypes(src_elt_type, |vars|);
      ## REMOVE WHEN DONE
      assert vars_types == (restricted_seq_elem_supertype(src_elt_type, singleton_type(i)) : i < |vars|);
      reprs = (opt_repr(t) : t <- vars_types);
      phys_vars = (low_level_var(reprs(i), v) : v @ i <- vars);
      surrs = surrogates & [v -> obj_expr(pv) : v @ i <~ vars, pv = phys_vars(i), v != pv];
      it_var, var_gen = next_obj_var(var_gen);
      body_code = (set_any_var(v, at(it_var, i)) : v @ i <- phys_vars);
    ;

    // Index variables
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    surrs = surrs & [expr.idx_var -> int_obj(hidden_idx_var)] if expr.idx_var?;

    // Evaluation of destination element expression
    elt_eval_code, elt_surr, var_gen = opt_eval_info(expr.expr, var_gen, surrogates = surrs);

    // Finalizing loop body
    if expr.sel_expr?:
      target_idx_var, var_gen = next_int32_var(var_gen);
      cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.sel_expr, var_gen, surrogates = surrs);
      cond_code = (elt_eval_code | write_array(array_var, target_idx_var, elt_surr), increment(target_idx_var));
      body_code = (body_code & cond_eval_code | do_if(bool_value(cond_surr), cond_code));
      loop_init_code = (set_ivar32(target_idx_var, 0));
      mk_seq_instr = mk_seq(res_var, array_var, target_idx_var);

    else
      body_code = (body_code & elt_eval_code | write_array(array_var, hidden_idx_var, elt_surr));
      loop_init_code = ();
      mk_seq_instr = mk_seq(res_var, array_var);
    ;

    // Mapping source to destination arrays
    map_instr = foreach(
      seq:        src_surr,
      src_array:  src_array_var,
      tmp_buffer: array_var,
      count_var:  array_size_var,
      idx_var:    hidden_idx_var,
      it_var:     it_var,
      body:       body_code
    );

    eval_code = (eval_code & loop_init_code | map_instr, mk_seq_instr);
    return (eval_code, res_var, ret_var_gen);
  }


  // range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) range_comp_opt_eval_info(RangeCompExpr expr, VarGen init_var_gen) {
    // Generating the result and hidden loop variables and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    idx_var, var_gen = next_int32_var(ret_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    code, bound_surr, var_gen = opt_eval_info(expr.bound_expr, var_gen);
    if not bound_surr :: <Var, int_obj(<IntVar, Int32Var>)>:
      bound_var, var_gen = next_int_var(var_gen);
      code = store_result(code, bound_surr, bound_var);
      bound_surr = bound_var;
    else
      bound_surr = get_int_val(bound_surr);
    ;

    // Types and low-level representation of the elements of the output sequence
    elt_type = subexpr_type(expr.expr);
    fail if elt_type == empty_type;
    elt_repr = opt_repr(elt_type);

    // Allocation of destination array
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    size_expr = if expr.inclusive then add(bound_surr, 1) else bound_surr;
    code = (code | alloc_array(array_var, cast_int32(size_expr)));

    let surrogates = surrogates & [expr.var -> obj_expr(idx_var)]:
      if expr.sel_expr?:
        // Creating and initializing the target cursor
        target_idx_var, var_gen = next_int32_var(var_gen);
        code = (code | set_ivar32(target_idx_var, 0));

        // Evaluating the condition. No need to save the variable generator
        cond_eval_code, cond_surr, unused_var = opt_eval_info(expr.sel_expr, var_gen);

        // Evaluating the expression that yields a new element
        eval_code, elt_surr, unused_var = opt_eval_info(expr.expr, var_gen);

        // Conditional array write
        write_instr = write_array(array_var, target_idx_var, elt_surr);
        cond_write_instr = do_if(bool_value(cond_surr), (eval_code | write_instr, increment(target_idx_var)));

        // Body code and sequence creation instruction
        body_code = (cond_eval_code | cond_write_instr);
        mk_seq_instr = mk_seq(res_var, array_var, target_idx_var);

      else
        // Evaluating the expression that yields a new element
        eval_code, elt_surr, unused_var = opt_eval_info(expr.expr, var_gen);

        // Body code and sequence creation instruction
        write_instr = write_array(array_var, idx_var, elt_surr);
        body_code = (eval_code | write_instr);
        mk_seq_instr = mk_seq(res_var, array_var);
      ;
    ;

    // Final body code
    break_cond = if expr.inclusive then is_ge(idx_var, bound_surr) else is_lt(idx_var, bound_surr);
    body_code = ((break_if(break_cond)) & body_code | increment(idx_var));

    // Final code
    code = (code | set_ivar32(idx_var, 0), repeat(body_code), mk_seq_instr);
    return (code, res_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) if_expr_opt_eval_info(IfExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate), :invalid_var, init_var_gen) if type == empty_type;
    repr = opt_repr(type);

    cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.cond, init_var_gen);

    res_var, var_gen = next_var(repr, var_gen);
    then_eval_code, unused_var = opt_eval_info(expr.then, res_var, var_gen);
    else_eval_code, unused_var = opt_eval_info(expr.else, res_var, var_gen);

    eval_code = (cond_eval_code | branch(bool_value(cond_surr), then_eval_code, else_eval_code));
    return (eval_code, obj_expr(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) eq_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    left_eval_code, left_surr, var_gen = opt_eval_info(left, init_var_gen);
    right_eval_code, right_surr, var_gen = opt_eval_info(right, var_gen);

    eval_code = left_eval_code & right_eval_code;
    return (eval_code, bool_obj(is_eq(left_surr, right_surr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) and_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == ():
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = and_then(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    ;

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, unused_var = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, unused_var = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) or_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == ():
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = or_else(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    ;

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, unused_var = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, unused_var = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if_not(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) not_expr_opt_eval_info(Expr expr, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    return (eval_code, bool_obj(neg(bool_value(surr_expr))), var_gen);
  }


  (Instr*, ObjExpr, VarGen) unary_pseudo_call_opt_eval_info(Expr target, Expr arg, VarGen init_var_gen) {
    target_type = subexpr_type(target);
    return ((terminate), :invalid_var, init_var_gen) if target_type == empty_type;

    coll_eval_code, coll_surr, var_gen = opt_eval_info(target, init_var_gen);
    arg_eval_code, arg_surr, var_gen = opt_eval_info(arg, var_gen);
    eval_code = coll_eval_code & arg_eval_code;

    if is_subset(target_type, type_seq):
      expr_surr = at(coll_surr, get_int_val(arg_surr));

    elif is_subset(target_type, type_set):
      expr_surr = bool_obj(has_elem(coll_surr, arg_surr));

    elif is_subset(target_type, type_map):
      expr_surr = lookup(coll_surr, arg_surr);

    else
      assert is_subset(target_type, atom_type);
      expr_surr, var_gen = next_obj_var(var_gen);
      ## HERE WE COULD CHECK IF THE TARGET OBJECT NEEDS TO BE OPTIMIZED
      eval_code = (eval_code | call_proc(expr_surr, :any_tag_rec_conv, (coll_surr, arg_surr), ()));
      var_gen = init_var_gen;
    ;

    return (eval_code, expr_surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) size_expr_opt_eval_info(Expr collection, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(collection, init_var_gen);
    return (eval_code, int_obj(get_size(surr_expr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_expr_opt_eval_info(SubExpr* elts, VarGen init_var_gen) {
    // Empty sequence
    return ((), empty_seq, init_var_gen) if elts == ();

    // Types of the elements of the sequence
    ord_elts_types = (subexpr_type(if is_cond_expr(e) then e.expr else e) : e <- elts);
    elts_types = set(ord_elts_types);
    elts_type = union_superset(elts_types);

    // Unreachable expression
    return ((terminate), :invalid_var, init_var_gen) if elts_types(empty_type) or elts_type == empty_type;

    // Elements representation
    elt_repr = low_level_elt_repr(elts_type);

    // Sequence and array variables
    seq_var, var_gen = next_obj_var(init_var_gen);
    elts_var, var_gen = next_array_var(var_gen, elt_repr);

    // Both seq_var and elts_var must survive the evaluation of the expression
    ret_var_gen = var_gen;

    // Dealing with the important special case of sequences of literal integers
    if is_subset(elts_type, integer) and not (e <~ elts : is_cond_expr(e)):
      if not (t <- elts_types : t == empty_type or not is_singleton(t)):
        int_seq = (only_integer(t) : t <- ord_elts_types);
        seq_id = int_seqs_ids[int_seq];
        code = (build_const_int_seq(seq_var, seq_id));
        return (code, seq_var, ret_var_gen);
      ;
    ;

    conds = (e.cond : e <- elts, is_cond_expr(e));
    if conds == ():
      // Easy case, no conditional inclusions
      code = (alloc_array(elts_var, int32(|elts|)));
      for e @ i <- elts:
        fail if is_cond_expr(e); ## ANY BETTER WAY TO DO THIS?
        fail if not i :: Int32;
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
        code = code & (elt_eval_code | write_array(elts_var, i, elt_surr));
      ;
      return ((code | mk_seq(seq_var, elts_var)), seq_var, ret_var_gen);
    ;

    // Evaluating conditions and final array size
    min_size = int32(|elts| - |conds|);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination array
    code = (alloc_array(elts_var, size_idx_var));

    // Computation of all array elements
    cond_expr_idx = 0;
    for e @ i <- elts:
      fail if not i :: Int32; ## ANY BETTER WAY TO DO THIS?
      is_last = i == |elts| - 1;
      if is_cond_expr(e): // Conditional inclusion expression
        elt_code, elt_surr, unused_var = opt_eval_info(e.expr, var_gen);
        if cond_expr_idx == 0:
          // If it's the first conditional expression, we statically know the
          // destination array index. After that we need to use the cursor
          // variable, unless this is the last element in the sequence
          cond = cond_vars(cond_expr_idx);
          elt_code = (elt_code | write_array(elts_var, i, elt_surr));
          if not is_last:
            elt_code = (elt_code | set_ivar32(size_idx_var, int32(i+1)));
            elt_instr = branch(cond, elt_code, (set_ivar32(size_idx_var, i)));
          else
            elt_instr = do_if(cond, elt_code);
          ;
        else
          elt_code = (elt_code | write_array(elts_var, size_idx_var, elt_surr));
          elt_code = (elt_code | increment(size_idx_var)) if not is_last;
          elt_instr = do_if(cond_vars(cond_expr_idx), elt_code);
        ;
        code = (code | elt_instr);
        cond_expr_idx = cond_expr_idx + 1;

      else // Non-conditional expression
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
        // Until we reach the first conditional element we statically know the
        // destination array index. After that we need to use the cursor variable
        write_code = if cond_expr_idx == 0
          then (write_array(elts_var, i, elt_surr))
          else (write_array(elts_var, size_idx_var, elt_surr), increment(size_idx_var) if not is_last);
        code = code & elt_eval_code & write_code;
      ;
    ;

    // Creation of the wrapping sequence object
    code = (code | mk_seq(seq_var, elts_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(seq_var, empty_seq)), code)) if min_size == 0;

    return (conds_code & code, seq_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) set_expr_opt_eval_info([SubExpr] elts, VarGen init_var_gen) {
    // Empty set
    return ((), empty_rel, init_var_gen) if elts == [];

    // Set object and array variables.
    set_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    elts_var, var_gen = next_array_var(ret_var_gen, :object);

    exprs = isort([e : e <- elts, not is_cond_expr(e)]);
    cond_exprs = isort([e : e <- elts, is_cond_expr(e)]);

    // Evaluating of conditions and final array size
    min_size = int32(|exprs|);
    conds = (e.cond : e <- cond_exprs);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination array
    size_expr = if cond_exprs == () then min_size else size_idx_var;
    code = (alloc_array(elts_var, size_expr));

    // Non-conditional elements
    for e @ i <- exprs:
      eval_code, surr, unused_var = opt_eval_info(e, var_gen);
      code = (code & eval_code | write_array(elts_var, int32(i), surr));
    ;

    if |cond_exprs| == 1:
      // Just one conditional element, no need to have an index variable
      elt_code, surr, unused_var = opt_eval_info(only(cond_exprs).expr, var_gen);
      elt_code = (elt_code | write_array(elts_var, min_size, surr));
      code = (code | do_if(cond_vars(0), elt_code));

    elif |cond_exprs| > 1:
      // More than one conditional element, we need to keep track of the next array slot
      for e @ i <- cond_exprs:
        cond = cond_vars(i);
        elt_code, surr, unused_var = opt_eval_info(e.expr, var_gen);
        elt_code = (elt_code | write_array(elts_var, if i == 0 then min_size else size_idx_var, surr));
        is_last = i == |cond_exprs| - 1;
        if i == 0:
          elt_code = (elt_code | set_ivar32(size_idx_var, int32(min_size + 1)));
          elt_instr = branch(cond, elt_code, (set_ivar32(size_idx_var, min_size)));
        else
          elt_code = (elt_code | increment(size_idx_var)) if not is_last;
          elt_instr = do_if(cond, elt_code);
        ;
        code = (code | elt_instr);
      ;
    ;

    // Creation of the set object
    code = (code | mk_set(set_obj_var, elts_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(set_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, set_obj_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) map_expr_opt_eval_info([+(key: Expr, value: Expr, cond: Expr?)] entries, VarGen var_gen) {
    // Checking if the expression is actually a record,
    // and if so building a record object instead
    if not (e <- entries : e.cond?):
      ord_entries = isort(entries);
      keys_types = (subexpr_type(e.key) : e <- ord_entries);
      if not (t <~ keys_types : not is_symb_singl_type(t)):
        labels = (only_symb(t) : t <- keys_types);
        if duplicates(labels) == []:
          return record_opt_eval_info(labels, (e.value : e <- ord_entries), var_gen);
        ;
      ;
    ;

    // Separating conditional entries from unconditional ones
    uncond_entries = isort([(e.key, e.value) : e <- entries, not e.cond?]);
    cond_entries = isort([(e.key, e.value, e.cond) : e <- entries, e.cond?]);

    return bin_rel_expr_opt_eval_info(uncond_entries, cond_entries, true, var_gen);
  }


  (Instr*, ObjExpr, VarGen) bin_rel_expr_opt_eval_info([+(args: (Expr, Expr), cond: Expr?)] entries, VarGen var_gen) {
    // Separating conditional entries from unconditional ones
    uncond_entries = isort([e.args : e <- entries, not e.cond?]);
    cond_entries = isort([(left(e.args), right(e.args), e.cond) : e <- entries, e.cond?]);

    return bin_rel_expr_opt_eval_info(uncond_entries, cond_entries, false, var_gen);
  }


  (Instr*, ObjExpr, VarGen) bin_rel_expr_opt_eval_info((Expr, Expr)* uncond_entries, (Expr, Expr, Expr)* cond_entries, Bool is_map, VarGen init_var_gen) {
    // Binary relation object and array variables.
    rel_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    col1_var, var_gen = next_array_var(ret_var_gen, :object);
    col2_var, var_gen = next_array_var(var_gen, :object);

    // Evaluating of conditions and final array size
    min_size = int32(|uncond_entries|);
    conds = (c : unused_var_1, unused_var_2, c <- cond_entries);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination arrays
    size_expr = if cond_entries == () then min_size else size_idx_var;
    code = (alloc_array(col1_var, size_expr), alloc_array(col2_var, size_expr));

    // Non-conditional elements
    for a1, a2 @ i <- uncond_entries:
      code = code & write_entry_code(a1, a2, col1_var, col2_var, int32(i), var_gen);
    ;

    if |cond_entries| == 1:
      // Just one conditional entry, no need to have an index variable
      arg1, arg2, unused_var = only(cond_entries);
      entry_code = write_entry_code(arg1, arg2, col1_var, col2_var, min_size, var_gen);
      code = (code | do_if(cond_vars(0), entry_code));

    elif |cond_entries| > 1:
      // More than one conditional element, we need to keep track of the next array slot
      for a1, a2, unused_var @ i <- cond_entries:
        cond = cond_vars(i);
        idx = if i == 0 then min_size else size_idx_var;
        entry_code = write_entry_code(a1, a2, col1_var, col2_var, idx, var_gen);
        is_last = i == |cond_entries| - 1;
        if i == 0:
          entry_code = (entry_code | set_ivar32(size_idx_var, int32(min_size+1)));
          entry_instr = branch(cond, entry_code, (set_ivar32(size_idx_var, min_size)));
        else
          entry_code = (entry_code | increment(size_idx_var)) if not is_last;
          entry_instr = do_if(cond, entry_code);
        ;
        code = (code | entry_instr);
      ;
    ;

    // Creation of the map object
    code = (code | mk_rel(rel_obj_var, col1_var, col2_var, is_map));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(rel_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, rel_obj_var, ret_var_gen);


    Instr* write_entry_code(Expr arg1, Expr arg2, ArrayVar col1, ArrayVar col2, Int32Expr idx, VarGen var_gen) {
      eval_code, surr, unused_var = opt_eval_info(arg1, var_gen);
      arg1_code = (eval_code | write_array(col1, idx, surr));
      eval_code, surr, unused_var = opt_eval_info(arg2, var_gen);
      arg2_code = (eval_code | write_array(col2, idx, surr));
      return arg1_code & arg2_code;
    }
  }


  (Instr*, ObjExpr, VarGen) tern_rel_expr_opt_eval_info([+(args: (Expr, Expr, Expr), cond: Expr?)] entries, VarGen init_var_gen) {
    // Binary relation object and array variables.
    rel_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    col1_var, var_gen = next_array_var(ret_var_gen, :object);
    col2_var, var_gen = next_array_var(var_gen, :object);
    col3_var, var_gen = next_array_var(var_gen, :object);

    // Separating conditional entries from unconditional ones
    uncond_entries = isort([e : e <- entries, not e.cond?]);
    cond_entries = isort([e : e <- entries, e.cond?]);

    // Evaluating of conditions and final array size
    min_size = int32(|uncond_entries|);
    conds = (e.cond : e <- cond_entries);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination arrays
    size_expr = if cond_entries == () then min_size else size_idx_var;
    code = (alloc_array(v, size_expr) : v <- (col1_var, col2_var, col3_var));

    // Non-conditional elements
    for e @ i <- uncond_entries:
      code = code & write_entry_code(e.args, col1_var, col2_var, col3_var, int32(i), var_gen);
    ;

    if |cond_entries| == 1:
      // Just one conditional entry, no need to have an index variable
      entry = only(cond_entries);
      entry_code = write_entry_code(entry.args, col1_var, col2_var, col3_var, min_size, var_gen);
      code = (code | do_if(cond_vars(0), entry_code));

    elif |cond_entries| > 1:
      // More than one conditional element, we need to keep track of the next array slot
      for e @ i <- cond_entries:
        cond = cond_vars(i);
        idx = if i == 0 then min_size else size_idx_var;
        entry_code = write_entry_code(e.args, col1_var, col2_var, col3_var, idx, var_gen);
        is_last = i == |cond_entries| - 1;
        if i == 0:
          entry_code = (entry_code | set_ivar32(size_idx_var, int32(min_size+1)));
          entry_instr = branch(cond, entry_code, (set_ivar32(size_idx_var, min_size)));
        else
          entry_code = (entry_code | increment(size_idx_var)) if not is_last;
          entry_instr = do_if(cond, entry_code);
        ;
        code = (code | entry_instr);
      ;
    ;

    // Creation of the map object
    code = (code | mk_rel(rel_obj_var, col1_var, col2_var, col3_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(rel_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, rel_obj_var, ret_var_gen);


    Instr* write_entry_code((Expr, Expr, Expr) args, ArrayVar col1, ArrayVar col2, ArrayVar col3, Int32Expr idx, VarGen var_gen) {
      arg1, arg2, arg3 = args;
      eval_code, surr, unused_var = opt_eval_info(arg1, var_gen);
      arg1_code = (eval_code | write_array(col1, idx, surr));
      eval_code, surr, unused_var = opt_eval_info(arg2, var_gen);
      arg2_code = (eval_code | write_array(col2, idx, surr));
      eval_code, surr, unused_var = opt_eval_info(arg3, var_gen);
      arg3_code = (eval_code | write_array(col3, idx, surr));
      return arg1_code & arg2_code & arg3_code;
    }
  }


  // fn_call(fn_id: FnFamilyId, args: Expr*, cls_args: AnyClsExpr*, impl_args: [ImplArg -> Expr])
  (Instr*, ObjExpr, VarGen) fn_call_opt_eval_info(FnCallExpr expr, VarGen init_var_gen) {
    env = environments(expr_id);

    // Actual arguments' types
    args_types = (subexpr_type(a) : a <- expr.args);

    // Actual types of closure arguments
    cls_types = inst_cls_types(expr.fn_id, args_types, expr.cls_args, env, typed_vars = []);

    // Low-level signature of the target function
    fn_id, low_level_sign = low_level_sign(expr.fn_id, args_types);

    // Result variable and returned variable generator
    res_var, ret_var_gen = next_var(low_level_sign.ret_value, init_var_gen);

    // Dealing with implicit arguments
    ord_impl_args = isort(keys(expr.impl_args));
    backup_vars, var_gen = next_obj_vars(ret_var_gen, |ord_impl_args|);
    tear_down_code = (set_var(a, backup_vars(i)) : a @ i <- ord_impl_args);
    set_up_code = join(({
        eval_code, surr, unused_var = opt_eval_info(expr.impl_args(a, !!), var_gen);
        return (eval_code | set_var(backup_vars(i), a), set_var(a, surr));
      } : a @ i <- ord_impl_args
    ));

    // Evaluation of the arguments
    args_eval_code, args_surrs, unused_var = opt_eval_info(expr.args, var_gen);

    // Low-level actual arguments
    low_level_args = (low_level_expr(low_level_sign.args(i), s) : s @ i <- args_surrs);

    // Evaluation code for the call only
    cls_args = (opt_comp_cls(a, t, env, surrogates) : a, t <- zip(expr.cls_args, cls_types));
    eval_code = (args_eval_code | call_proc(res_var, fn_id, low_level_args, cls_args));

    return (set_up_code & eval_code & tear_down_code, obj_expr(res_var), ret_var_gen);
  }


  // cls_call(name: ClsVar, args: Expr+)
  (Instr*, ObjExpr, VarGen) cls_call_opt_eval_info(ClsVar name, Expr+ args, VarGen init_var_gen) {
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    eval_code, surrs, var_gen = opt_eval_info(args, ret_var_gen);
    final_name = lookup(cls_var_subst_map, name, name);
    code = (eval_code | call_cls(res_var, final_name, surrs));
    return (code, res_var, ret_var_gen);
  }


  // builtin_call(name: BuiltIn, args: Expr+);
  (Instr*, ObjExpr, VarGen) builtin_call_opt_eval_info(BuiltinCall expr, VarGen init_var_gen) {
    // Evaluation of the arguments
    args_eval_code, args_surrs, unused_var = opt_eval_info(expr.args, init_var_gen);

    // Builtin call. The arguments are not needed anymore once the call
    // returns, so we can restart from the initial variables generator
    code, surr, var_gen = eval_info(expr.name, nonempty(args_surrs), init_var_gen);

    return (args_eval_code & code, surr, var_gen);


    (Instr*, ObjExpr, VarGen) eval_info(BuiltIn name, ObjExpr+ args, VarGen init_var_gen) =
      slice   |
      cat     |
      rev     |
      isort   |
      parse   |
      print   |
      str     = { res_var, var_gen = next_obj_var(init_var_gen);
                  instr = eval_instr(name, args, res_var);
                  return ((instr), res_var, var_gen);
                },
      _       = ((), eval_expr(name, args), init_var_gen);


    Instr eval_instr(BuiltIn name, ObjExpr+ args, LocVar res_var) =
      slice         = get_seq_slice(res_var, args(0), get_int_val(args(1)), get_int_val(args(2))),
      cat           = join_seqs(res_var, args(0), args(1)),
      rev           = rev_seq(res_var, args(0)),
      isort         = internal_sort(res_var, args(0)),
      parse         = parse_value(res_var, args(0)),
      print         = print_value(res_var, args(0)),
      str           = symb_to_str(res_var, args(0));


    ObjExpr eval_expr(BuiltIn name, ObjExpr+ args) =
      neg       |
      add       |
      sub       |
      mult      |
      div       |
      mod       |
      and       |
      or        |
      xor       = int_obj(int_op_eval_info(name, (get_int_val(a) : a <- args))),
      lt        |
      le        = bool_obj(bool_op_eval_info(name, (get_int_val(a) : a <- args))),
      flt       |
      fle       = bool_obj(floats_to_bool_op_eval_info(name, (float_value(a) : a <- args))),
      bits      |
      mantissa  |
      dec_exp   = int_obj(int_op_eval_info(name, float_value(args(0)))),
      fneg      |
      fadd      |
      fsub      |
      fmult     |
      fdiv      |
      fexp      |
      fsqrt     = float_obj(float_op_eval_info(name, (float_value(a) : a <- args))),
      float     = float_obj(int_to_float(get_int_val(args(0)))),
      symb      = to_symb(args(0)),
      tag       = get_tag(args(0)),
      untag     = get_inner_obj(args(0)),

      rand_nat  = int_obj(rand_nat(args(0))),
      rand_elem = rand_elem(args(0)),
      counter   = int_obj(unique_nat),
      ticks     = int_obj(ticks);



    BoolExpr bool_op_eval_info(BuiltIn, IntExpr+ args) =
      lt  = is_lt(args(0), args(1)),
      le  = is_le(args(0), args(1));

    BoolExpr floats_to_bool_op_eval_info(BuiltIn, FloatExpr+ args) =
      flt   = is_flt(args(0), args(1)),
      fle   = is_fle(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, IntExpr+ args) =
      neg   = minus(args(0)),
      add   = add(args(0), args(1)),
      sub   = sub(args(0), args(1)),
      mult  = mult(args(0), args(1)),
      div   = div(args(0), args(1)),
      mod   = mod_op(args(0), args(1)),
      and   = bitwise_and(args(0), args(1)),
      or    = bitwise_or(args(0), args(1)),
      xor   = bitwise_xor(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, FloatExpr arg) =
      bits      = float_bits(arg),
      mantissa  = mantissa(arg),
      dec_exp   = dec_exp(arg);

    FloatExpr float_op_eval_info(BuiltIn, FloatExpr+ args) =
      fneg  = neg_float(args(0)),
      fadd  = add_floats(args(0), args(1)),
      fsub  = sub_floats(args(0), args(1)),
      fmult = mult_floats(args(0), args(1)),
      fdiv  = div_floats(args(0), args(1)),
      fexp  = exp_floats(args(0), args(1)),
      fsqrt = square_root(args(0));
  }

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////

  ## BAD BAD BAD: THIS IS A RIDICULOUS HACK
  ((), (), Int32Var, VarGen) conds_eval_info((), Int32 min_size, VarGen init_var_gen) =
    ((), (), ivar32(9223372036854775807), init_var_gen);


  (Instr*, BoolVar+, Int32Var, VarGen) conds_eval_info(Expr+ conds, Int32 min_size, VarGen init_var_gen) {
    // Evaluation of all conditions
    var_gen = init_var_gen;
    cond_vars = ();
    code = ();
    for c @ i <- conds:
      eval_code, surr_expr, var_gen = opt_eval_info(c, var_gen);
      if not surr_expr :: <bool_obj(BoolVar)>:
        surr_var, var_gen = next_bool_var(var_gen);
        eval_code = store_result(eval_code, surr_expr, surr_var);
      else
        surr_var = untag(surr_expr);
      ;
      code = code & eval_code;
      cond_vars = (cond_vars | surr_var);
    ;

    // Integer variable for both size and cursor
    size_var, var_gen = next_int32_var(var_gen);

    // Computation of final array size
    len_expr = foldr(nonempty((bool_to_bit(v) : v <- cond_vars)), add32);
    len_expr = add32(min_size, len_expr) if min_size != 0;
    code = (code | set_ivar32(size_var, len_expr));

    return (code, nonempty(cond_vars), size_var, var_gen);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         options           : CompOptions {

  BoundCls opt_comp_cls(AnyClsExpr expr, ClsType type, [EnvVar -> Type] env, [SurrExpr -> ObjExpr] surrs) =
    cls_var()   = lookup(cls_var_subst_map, expr, expr),
    fn_ptr(fn?) = opt_comp_cls(arity(expr), fn_call(fn, (fn_arg(i) : i < arity(expr)), ()), type, env, surrs),
    cls_expr()  = opt_comp_cls(expr.arity, expr.expr, type, env, surrs);


  BoundCls opt_comp_cls(NzNat arity, Expr expr, ClsType type, [EnvVar -> Type] env, [SurrExpr -> ObjExpr] surrs) {
    loc_vars = set((fn_arg(i) : i < arity));
    ext_vars = isort(extern_vars(expr) - set((fn_arg(i) : i < arity)));
    fail if not ext_vars :: StdVar*;

    cls_vars = isort(cls_vars(expr));

    subst_map     = [v -> capt_var(i)     : v @ i <~ ext_vars];
    cls_subst_map = [v -> capt_cls_var(i) : v @ i <~ cls_vars];

    capt_vars     = (eval_var(v, var_subst_map, surrs) : v <- ext_vars);
    capt_cls_vars = (lookup(cls_var_subst_map, v, v) : v <- cls_vars);

    args_env = [fn_arg(i) -> type.in_types(i) : i <- range(arity)];
    capt_env = [v -> env(v, !!) : v <~ ext_vars];
    new_env = args_env & capt_env;

    let var_subst_map = subst_map, cls_var_subst_map = cls_subst_map, surrogates = [], typed_vars = []:
      eval_code, surr, unused_var = opt_eval_code(expr, new_env, blank_var_gen);
    ;
    body = (eval_code | ret_val(surr));

    return bound_cls(cls_def(arity, body), capt_vars, capt_cls_vars);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ObjExpr eval_var(Var var, [StdVar -> CaptVar] var_subst_map, [SurrExpr -> ObjExpr] surrogates) {
  // If a variable whose low-level representation is not a standard object
  // is captured, then it's stored in the array that contains the captured
  // variables in object form, and from that point on its surrogate is
  // not used anymore. In fact, the surrogate should not be passed down at
  // all when a closure is encountered
  assert not var_subst_map(var, *) or not surrogates(var, *);

  surr = if   var_subst_map(var, *) then var_subst_map[var]
         elif surrogates(var, *)    then surrogates[var]
                                    else var;
  return surr;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Instr+ store_result(Instr* code, ObjExpr surr_expr, AnyLocVar res_var) {
  def_code = (code | set_any_var(res_var, surr_expr));
  return def_code if code == ();
  trimmed_code = take(code, |code| - 1);

  return match (rat(code, 0))
    set_bvar()   i? |
    set_ivar()   i? |
    set_ivar32() i? | ## WHY DOES THIS EXPRESSION TYPECHECKS EVEN WITH AN Int32Var?
    set_fvar()   i? |
    set_var()    i? = if i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                        then (trimmed_code | set_any_var(res_var, obj_expr(i.value)))
                        else def_code,

    call_proc()  i? = if i.var? and i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                                and low_level_repr(i.var) == low_level_repr(res_var)
                        then (trimmed_code | call_proc(res_var, i.name, i.args, i.cls_args))
                        else def_code,

    _               = def_code;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(AnyLocVar, VarGen) next_var(LowLevelRepr repr, VarGen gen) =
  bool    = next_bool_var(gen),
  int     = next_int_var(gen),
  float   = next_float_var(gen),
  symbol  |
  object  = next_obj_var(gen);

(LocOptTagRecVar, VarGen) next_var(OptTagRecRepr repr, VarGen gen) =
  next_opt_tag_rec_var(gen, repr.tag, repr.index);


Instr set_any_var(LocBoolVar  var, ObjExpr expr) = set_bvar(var, bool_value(expr));
Instr set_any_var(LocIntVar   var, ObjExpr expr) = set_ivar(var, get_int_val(expr));
Instr set_any_var(LocFloatVar var, ObjExpr expr) = set_fvar(var, float_value(expr));
Instr set_any_var(WriteObjVar var, ObjExpr expr) = set_var(var, expr);
Instr set_any_var(LocOptTagRecVar var, ObjExpr expr) = set_var(var, expr);
