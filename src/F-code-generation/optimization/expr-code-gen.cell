implicit program           : Program,
         typedefs          : [TypeName -> NeType],
         context           : Context,
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         cluster           : Expr+,
         types             : Type+,
         environments      : [EnvVar -> Type]+,
         surrogates        : [SurrExpr -> ObjExpr],
         expr_id           : Nat,
         options           : CompOptions
{
  Type subexpr_type(Expr) =
    expr_ref(id?) = types(id);

  Expr expand_subexpr(Expr) =
    expr_ref(id?) = cluster(id);

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, VarGen) opt_eval_info(Expr expr, AnyLocVar res_var, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    eval_code = store_result(eval_code, surr_expr, res_var);
    return (eval_code, var_gen);
  }


  (Instr*, ObjExpr*, VarGen) opt_eval_info(Expr* exprs, VarGen init_var_gen) {
    var_gen = init_var_gen;
    code = ();
    surrs = ();
    for e <- exprs:
      expr_code, surr, var_gen = opt_eval_info(e, var_gen);
      code = code & expr_code;
      surrs = (surrs | surr);
    ;
    return (code, surrs, var_gen);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (Instr*, ObjExpr, VarGen) opt_eval_info(<undefined>, VarGen var_gen) {
    return ((terminate), never_used_lvar, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(LeafObj expr, VarGen var_gen) {
    return ((), expr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(FloatLit expr, VarGen var_gen) {
    return ((), float_obj(expr), var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(Var var, VarGen var_gen) {
    surr = lookup(surrogates, var, var);
    return ((), surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsDefExpr expr, VarGen var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsSetExpr expr, VarGen var_gen) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(ExprRef expr, VarGen var_gen) {
    id = untag(expr);
    return opt_eval_info(cluster(id), var_gen, expr_id = id);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(RecExpr expr, VarGen var_gen) =
    seq_expr(ses?)      |
    tuple_expr(ses?)    = seq_expr_opt_eval_info(ses, var_gen),
    seq_tail_expr()     = seq_tail_expr_opt_eval_info(expr.seq, expr.tail, var_gen),
    set_expr(ses?)      = set_expr_opt_eval_info(ses, var_gen),
    map_expr(es?)       = map_expr_opt_eval_info(es, var_gen),
    bin_rel_expr(es?)   = bin_rel_expr_opt_eval_info(es, var_gen),
    tern_rel_expr(es?)  = tern_rel_expr_opt_eval_info(es, var_gen),
    tag_obj_expr()      = tag_obj_expr_opt_eval_info(expr, var_gen),
    fn_call()           = fn_call_opt_eval_info(expr, var_gen),
    cls_call()          = undefined,
    builtin_call()      = builtin_call_opt_eval_info(expr, var_gen),
    size_expr()         = size_expr_opt_eval_info(expr.coll, var_gen),
    unary_pseudo_call() = unary_pseudo_call_opt_eval_info(expr.target, expr.arg, var_gen),
    rel_memb_test()     = rel_memb_test_opt_eval_info(expr.rel, expr.args, var_gen),
    rel_lookup()        = rel_lookup_opt_eval_info(expr, var_gen),
    // relvar_memb_test()  = undefined,
    // relvar_lookup()     = undefined,
    and_expr()          = and_expr_opt_eval_info(expr.left, expr.right, var_gen),
    or_expr()           = or_expr_opt_eval_info(expr.left, expr.right, var_gen),
    not_expr(e?)        = not_expr_opt_eval_info(e, var_gen),
    eq()                = eq_expr_opt_eval_info(expr.left, expr.right, var_gen),
    membership()        = membership_opt_eval_info(expr.obj, expr.type, var_gen),
    // cast_expr()         = undefined,
    accessor()          = accessor_opt_eval_info(expr.expr, expr.field, var_gen),
    accessor_test()     = accessor_test_opt_eval_info(expr.expr, expr.field, var_gen),
    // auto_method_call()  = undefined,
    // db_method_call()    = undefined,
    if_expr()           = if_expr_opt_eval_info(expr, var_gen),
    match_expr()        = match_expr_opt_eval_info(expr, var_gen),
    do_expr()           = do_expr_opt_eval_code(expr, environments(expr_id), var_gen),
    // ex_qual()           = undefined,
    // set_comp()          = undefined,
    // map_comp()          = undefined,
    // bin_rel_comp()      = undefined,
    // tern_rel_comp()     = undefined,
    seq_comp()          = seq_comp_opt_eval_info(expr, var_gen),
    range_comp()        = range_comp_opt_eval_info(expr, var_gen);


  // match_expr(exprs: Expr+, cases: (ptrns: Pattern+, expr: Expr)+);
  (Instr*, ObjExpr, VarGen) match_expr_opt_eval_info(MatchExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate(true)), never_used_lvar, init_var_gen) if type == empty_type;
    repr = opt_repr(type);
    res_var, var_gen = next_var(repr, init_var_gen);
    ret_var_gen = var_gen;

    if |expr.exprs| == 1:
      match_expr = only(expr.exprs);
      match_expr_type = subexpr_type(match_expr);
      match_expr_code, match_expr_surr, var_gen = opt_eval_info(match_expr, var_gen);

      ptrns = (only_unsafe(c.ptrns) : c <- expr.cases);
      fallthrough_type = foldl(type, ptrns, type_minus_pattern);
      is_complete = fallthrough_type == empty_type;

      cases = ({
          ptrn = only_unsafe(c.ptrns);
          ptrn_env = generate_env(ptrn, type);
          surrs = [v -> low_level_var(opt_repr(t), v) : v, t <- ptrn_env, t != empty_type];
          code, surr, unused_var = opt_eval_info(c.expr, var_gen);
          return (ptrn, nonempty(store_result(code, surr, res_var)));
        } : c <- expr.cases
      );

      match_code = single_ptrn_match_expr_opt_code(match_expr_surr, match_expr_type, cases, is_complete);
      return (match_expr_code & match_code, obj_expr(res_var), ret_var_gen);

    else
      fail;
    ;
  }

  //   Instr+ gen_switch_code(ExprEvalRes+ exprs, (ptrns: Pattern+, code: Instr+)+ cases) {
  //     if |head(cases).ptrns| == 1:
  //       return gen_single_ptrn_switch_code(only_unsafe(exprs), ((only_unsafe(c.ptrns), c.code) : c <- cases));
  //     else
  //       code = ();
  //       for c <- cases:
  //         case_code = gen_guarded_case_eval_code(exprs, c.ptrns, c.code);
  //         code = code & case_code;
  //       ;
  //       return (execute_block((code | terminate)));
  //     ;


  //     Instr+ gen_guarded_case_eval_code(AtomicExpr* exprs, Pattern* ptrns, Instr+ code) {
  //       assert |exprs| == |ptrns|;

  //       return code if exprs == () or ptrns == (); // Shutting up the typechecker...

  //       next_step_code = gen_guarded_case_eval_code(tail(exprs), tail(ptrns), code);
  //       let loc_bound_vars=[], on_match_code=next_step_code, tag_vars=[]:
  //         res = gen_ptrn_matching_code(head(ptrns), head(exprs), pseudotype_any);
  //       ;
  //       return nonempty(res);
  //     }
  //   }
  // }

  // Type match_expr_type(Expr+ exprs, (ptrns: Pattern+, expr: Expr)+ cases, [EnvVar -> Type] env) {
  //   types = (case_expr_type(exprs, c.ptrns, c.expr, env) : c <- cases);
  //   return union_superset(set(types));

  //   Type case_expr_type(Expr+ exprs, Pattern+ ptrns, Expr expr, [EnvVar -> Type] env) {
  //     case_expr_env = update_env(exprs, ptrns, env);
  //     return expr_type(expr, case_expr_env);
  //   }
  // }

  // Instr+ gen_eval_code_for_match_expr(Expr+ exprs, (ptrns: Pattern+, expr: Expr)+ cases, EvalDestVar res_var) {
  //   info = gen_eval_info(exprs);
  //   let next_var_gen = info.next_var_gen:
  //     semicomp_cases = ((ptrns: c.ptrns, code: (gen_eval_code(c.expr, res_var) | exit_block)) : c <- cases);
  //     switch_code = gen_switch_code(nonempty(info.exprs), semicomp_cases);
  //   ;
  //   return nonempty(info.eval_code & switch_code);
  // }


  // rel_lookup(rel: Expr, set_args: Expr*, unknown_arg_idx: Nat);
  (Instr*, ObjExpr, VarGen) rel_lookup_opt_eval_info(RelLookup expr, VarGen init_var_gen) {
    // Physical representation of the result and variable that stores it
    type = types(expr_id);
    return ((terminate), never_used_lvar, init_var_gen) if type == empty_type;

    repr = opt_repr(type);
    res_var, ret_var_gen = next_var(repr, init_var_gen);

    // Evaluation of all subexpressions
    code, rel_surr, var_gen = opt_eval_info(expr.rel, ret_var_gen);
    args_surrs = ();
    for e <- expr.set_args:
      arg_code, arg_surr, var_gen = opt_eval_info(e, var_gen);
      code = code & arg_code;
      args_surrs = (args_surrs | arg_surr);
    ;

    if args_surrs == ():
      code = (code | check(is_eq(get_size(rel_surr), 1)), set_any_var(res_var, rand_elem(rel_surr)));

    elif |args_surrs| == 1:
      arg_surr = only(args_surrs);
      if expr.unknown_arg_idx == 1:
        code = (code | set_any_var(res_var, lookup(rel_surr, arg_surr)));
      else
        it_var, var_gen = next_bin_rel_it_var(var_gen);
        code = (code |
          get_iter(it_var, rel_surr, (nothing, just(arg_surr))),
          check(neg(is_out_of_range(it_var))),
          set_any_var(res_var, get_curr_arg(it_var, 0)),
          move_forward(it_var),
          check(is_out_of_range(it_var))
        );
      ;

    else
      it_var, var_gen = next_tern_rel_it_var(var_gen);
      search_args = insert((just(a) : a <- args_surrs), expr.unknown_arg_idx, nothing);
      fail if |search_args| != 3 or not expr.unknown_arg_idx :: <0..2>;
      code = (code |
        get_iter(it_var, rel_surr, search_args),
        check(neg(is_out_of_range(it_var))),
        set_any_var(res_var, get_curr_arg(it_var, expr.unknown_arg_idx)),
        move_forward(it_var),
        check(is_out_of_range(it_var))
      );
    ;

    return (code, obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) rel_memb_test_opt_eval_info(Expr rel, Maybe[Expr]+ args, VarGen init_var_gen) {
    args_surrs : Maybe[ObjExpr]*; ## WHY IS THIS NEEDED? IS THIS A BUG IN THE TYPECHECKER?

    res_var, ret_var_gen = next_bool_var(init_var_gen);

    code, rel_surr, var_gen = opt_eval_info(rel, ret_var_gen);

    args_surrs = ();
    for a <- args:
      if a != nothing:
        arg_code, arg_surr, var_gen = opt_eval_info(value(a), var_gen);
        code = code & arg_code;
        args_surrs = (args_surrs | just(arg_surr));
      else
        args_surrs = (args_surrs | nothing);
      ;
    ;

    if not (a <~ args_surrs : a == nothing): ## THIS SHOULD NARROW DOWN THE TYPE OF args_surrs
      search_instr = set_bvar(res_var, contains(rel_surr, nonempty((value_unsafe(a) : a <- args_surrs))));
      code = (code | search_instr);

    else
      if |args_surrs| == 2:
        it_var, var_gen = next_bin_rel_it_var(var_gen);
        get_iter_instr = get_iter(it_var, rel_surr, args_surrs);

      else
        fail if |args_surrs| != 3;
        it_var, var_gen = next_tern_rel_it_var(var_gen);
        get_iter_instr = get_iter(it_var, rel_surr, args_surrs);
      ;

      code = (code | get_iter_instr, set_bvar(res_var, neg(is_out_of_range(it_var))));
    ;

    return (code, obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_tail_expr_opt_eval_info(Expr seq, Expr+ tail, VarGen init_var_gen) {
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    code, seq_surr, var_gen = opt_eval_info(seq, ret_var_gen);
    for e @ i <- tail:
      elt_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
      src_seq = if i == 0 then seq_surr else res_var;
      code = (code & elt_code | append_to_seq(res_var, src_seq, elt_surr));
    ;
    return (code, res_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) membership_opt_eval_info(Expr obj, NeType type, VarGen init_var_gen) {
    pred = memb_test_preds_map[type];
    res_var, ret_var_gen = next_bool_var(init_var_gen);
    code, surr, var_gen = opt_eval_info(obj, ret_var_gen);
    return ((code | set_bvar(res_var, is_member(pred, surr))), obj_expr(res_var), ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) accessor_opt_eval_info(Expr expr, SymbObj field, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_info(expr, init_var_gen);
    target_type = subexpr_type(expr);
    maybe_repr = nothing;
    if is_subset(target_type, tag_obj_type(atom_type, type_any)):
      tag_type = tag_supertype(target_type);
      if is_symb_singl_type(tag_type):
        tag_obj = only_symb(tag_type);
        tag = untag(tag_obj);
        tag_type = symb_type(tag_obj);
        opt_types = if optimized_tagged_records_types(tag, *)
          then optimized_tagged_records_types(tag, !!)
          else ();
        for t @ i <- opt_types:
          if is_subset(target_type, tag_obj_type(tag_type, t)):
            surr = cast_opt_tag_rec(tag, i, surr) if not surr :: OptTagRecVar;
            fields_reprs = untag(optimized_tagged_records(tag, !!)(i));
            maybe_repr = just(fields_reprs(untag(field), !!).repr);
            break;
          ;
        ;
      ;
    ;
    return (code, lookup_field(surr, field, maybe_repr), var_gen);
  }


  (Instr*, ObjExpr, VarGen) accessor_test_opt_eval_info(Expr expr, SymbObj field, VarGen init_var_gen) {
    code, surr, var_gen = opt_eval_info(expr, init_var_gen);
    return (code, bool_obj(has_field(surr, field)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) record_opt_eval_info(SymbObj+ labels, Expr+ values, VarGen init_var_gen) {
    var, var_gen = next_obj_var(init_var_gen);
    code, surrs, var_gen = opt_eval_info(values, var_gen);
    code = (code | mk_record(var, [l -> surrs(i) : l @ i <~ labels]));
    return (code, var, var_gen);
  }


  (Instr*, ObjExpr, VarGen) tag_obj_expr_opt_eval_info(TagObjExpr expr, VarGen init_var_gen) {
    tag_type = subexpr_type(expr.tag);
    if is_symb_singl_type(tag_type):
      // The tag is a known symbol
      tag = untag(only_symb(tag_type));
      may_need_conv = false;
      if optimized_tagged_records(tag, *):
        // There's at least one optimized representation for values with such tag
        reprs = optimized_tagged_records(tag, !!);
        obj_expr = expr.obj;
        obj_type = subexpr_type(obj_expr);
        for repr @ repr_idx <- reprs:
          repr_type = low_level_repr_type(repr);
          if is_subset(obj_type, repr_type):
            // The tagged value has an optimized representation
            assert not may_need_conv;
            return opt_rec_eval_info(tag, obj_expr, repr, repr_idx, init_var_gen);
          elif not are_ptype_disjoint(obj_type, repr_type):
            may_need_conv = true;
          ;
        ;
      ;
      // The tagged value may or may not have an optimized representation
      code, value_surr, var_gen = opt_eval_info(expr.obj, init_var_gen);
      var, var_gen = next_obj_var(var_gen);
      creation_instr = if may_need_conv
        then call_proc(var, :tag_rec_conv(tag), (value_surr), ())
        else mk_tagged_obj(var, object(tag), value_surr);
      code = (code | creation_instr);
      return (code, var, var_gen);

    else
      // The symbol is not known at compile time
      tag_code, tag_surr, var_gen = opt_eval_info(expr.tag, init_var_gen);
      value_code, value_surr, var_gen = opt_eval_info(expr.obj, var_gen);
      var, var_gen = next_obj_var(var_gen);
      ## HERE WE COULD CHECK IF THE TARGET OBJECT NEEDS TO BE OPTIMIZED
      code = (tag_code & value_code | call_proc(var, :any_tag_rec_conv, (tag_surr, value_surr), ()));
      return (code, var, var_gen);
    ;


    (Instr*, ObjExpr, VarGen) opt_rec_eval_info(Symbol tag, Expr rec_expr_ref, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      rec_expr = expand_subexpr(rec_expr_ref);
      if rec_expr :: MapExpr:
        // The expression that defines the tagged value is a map expression
        fields = isort(untag(rec_expr));
        keys_types = (subexpr_type(f.key) : f <- fields);
        if not (t <~ keys_types : not is_symb_singl_type(t)):
          // Every key in the map expression is a known symbol
          labels = (untag(only_symb(t)) : t <- keys_types);
          return direct_opt_rec_eval_info(tag, labels, rec_expr, repr, repr_idx, init_var_gen);
        ;
      ;

      // Generic creation: evaluating the record expression first, then
      // passing it on to the representation-specific conversion function
      code, value_surr, var_gen = opt_eval_info(rec_expr, init_var_gen);
      var, var_gen = next_opt_tag_rec_var(var_gen, tag, repr_idx);
      code = (code | call_proc(var, :tag_rec_repr_conv(tag, repr_idx), (value_surr), ()));
      return (code, var, var_gen);
    }


    (Instr*, ObjExpr, VarGen) direct_opt_rec_eval_info(Symbol tag, Symbol+ labels, MapExpr rec_expr, OptRecRepr repr, Nat repr_idx, VarGen init_var_gen) {
      low_level_fields = untag(repr);
      var, var_gen = next_opt_tag_rec_var(init_var_gen, tag, repr_idx);
      surrs = ();
      conds = ();
      code = (inst_opt_tag_rec(var, tag, repr_idx));
      var_gen = init_var_gen;
      for f @ i <- isort(untag(rec_expr)):
        label = labels(i);
        field = low_level_fields(label, !!);

        if f.cond?:
          cond_code, cond_surr, var_gen = opt_eval_info(f.cond, var_gen);
          code = code & cond_code;
          maybe_cond = just(bool_value(cond_surr));
        else
          maybe_cond = nothing;
        ;

        field_code, surr, var_gen = opt_eval_info(f.value, var_gen);
        set_field_instr = write_rec_field(var, label, low_level_expr(field.repr, surr), field.optional);
        field_code = (field_code | set_field_instr);
        if maybe_cond != nothing:
          cond_surr = value(maybe_cond);
          field_code = (do_if(value(maybe_cond), field_code));
        ;

        code = code & field_code;
      ;

      return (code, var, var_gen);
    }
  }


  // seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) seq_comp_opt_eval_info(SeqCompExpr expr, VarGen init_var_gen) {
    // Generating the result variable and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    var_gen = ret_var_gen;

    // Calculating source type, and returning early if the type is trivial
    src_type = subexpr_type(expr.src_expr);
    if src_type == empty_type:
      return ((terminate), never_used_lvar, init_var_gen);
    elif is_subset(src_type, empty_seq_type):
      return ((), empty_seq, init_var_gen);
    ;

    // Types of elements of source and destination sequences
    src_elt_type = seq_elem_supertype(src_type);
    elt_type = subexpr_type(expr.expr);
    fail if src_elt_type == empty_type or elt_type == empty_type;

    // Low-level representation of elements of source and destination sequences
    src_repr = opt_repr(src_elt_type);
    elt_repr = opt_repr(elt_type);

    // Evaluation of source expression
    eval_code, src_surr, var_gen = opt_eval_info(expr.src_expr, var_gen);
    fail if not src_surr :: <LocVar, StdVar>; ## MAYBE THIS COULD BE AVOIDED...

    // Temporary buffer for source data
    src_array_var, var_gen = next_array_var(var_gen, src_repr);

    // Allocation of destination array
    array_size_var, var_gen = next_int32_var(var_gen);
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    eval_code = (eval_code |
      set_ivar32(array_size_var, get_size(src_surr)),
      alloc_array(array_var, array_size_var)
    );

    vars = expr.vars;
    if |vars| == 1:
      var = only(vars);
      physical_var, var_gen = next_var_def(src_repr, var, var_gen);
      surrs = surrogates & [var -> obj_expr(physical_var)];
      it_var = physical_var;
      body_code = ();

    else
      assert src_repr == :object;
      vars_types = (restricted_seq_elem_supertype(src_type, singleton_type(i)) : i < |vars|);
      fail if not vars_types :: NeType+;
      reprs = (opt_repr(t) : t <- vars_types);
      physical_vars, var_gen = mapli(vars, var_gen, next_var_def(reprs($b), $a, $c));
      surrs = surrogates & [v -> obj_expr(physical_vars(i)) : v @ i <~ vars];
      it_var, var_gen = next_obj_var(var_gen);
      body_code = (set_any_var(v, at(it_var, i)) : v @ i <- physical_vars);
    ;

    // Index variables
    hidden_idx_var, var_gen = next_int32_var(var_gen);
    surrs = surrs & [expr.idx_var -> int_obj(hidden_idx_var)] if expr.idx_var?;

    // Evaluation of destination element expression
    elt_eval_code, elt_surr, var_gen = opt_eval_info(expr.expr, var_gen, surrogates = surrs);

    // Finalizing loop body
    body_code = body_code & elt_eval_code;
    if expr.sel_expr?:
      target_idx_var, var_gen = next_int32_var(var_gen);
      cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.sel_expr, var_gen, surrogates = surrs);
      body_code = (body_code | write_array(array_var, target_idx_var, elt_surr), increment(target_idx_var));
      body_code = (cond_eval_code | do_if(bool_value(cond_surr), body_code));
      loop_init_code = (set_ivar32(target_idx_var, 0));
      mk_seq_instr = mk_seq(res_var, array_var, target_idx_var);

    else
      body_code = (body_code | write_array(array_var, hidden_idx_var, elt_surr));
      loop_init_code = ();
      mk_seq_instr = mk_seq(res_var, array_var);
    ;

    // Mapping source to destination arrays
    map_instr = foreach(
      seq:        src_surr,
      src_array:  src_array_var,
      tmp_buffer: array_var,
      count_var:  array_size_var,
      idx_var:    hidden_idx_var,
      it_var:     it_var,
      body:       body_code
    );

    eval_code = (eval_code & loop_init_code | map_instr, mk_seq_instr);
    return (eval_code, res_var, ret_var_gen);
  }


  // range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
  (Instr*, ObjExpr, VarGen) range_comp_opt_eval_info(RangeCompExpr expr, VarGen init_var_gen) {
    // Generating the result and hidden loop variables and setting up the variable generator
    res_var, ret_var_gen = next_obj_var(init_var_gen);
    idx_var, var_gen = next_int32_var(ret_var_gen);

    // Code that evaluates the bounds and initializes the loop variable
    code, bound_surr, var_gen = opt_eval_info(expr.bound_expr, var_gen);
    if not bound_surr :: <Var, int_obj(<IntVar, Int32Var>)>:
      bound_var, var_gen = next_int_var(var_gen);
      code = store_result(code, bound_surr, bound_var);
      bound_surr = bound_var;
    else
      bound_surr = get_int_val(bound_surr);
    ;

    // Types and low-level representation of the elements of the output sequence
    elt_type = subexpr_type(expr.expr);
    fail if elt_type == empty_type;
    elt_repr = opt_repr(elt_type);

    // Allocation of destination array
    array_var, var_gen = next_array_var(var_gen, elt_repr);
    size_expr = if expr.inclusive then add(bound_surr, 1) else bound_surr;
    code = (code | alloc_array(array_var, cast_int32(size_expr)));

    let surrogates = surrogates & [expr.var -> obj_expr(idx_var)]:
      if expr.sel_expr?:
        // Creating and initializing the target cursor
        target_idx_var, var_gen = next_int32_var(var_gen);
        code = (code | set_ivar32(target_idx_var, 0));

        // Evaluating the condition. No need to save the variable generator
        cond_eval_code, cond_surr, unused_var = opt_eval_info(expr.sel_expr, var_gen);

        // Evaluating the expression that yields a new element
        eval_code, elt_surr, unused_var = opt_eval_info(expr.expr, var_gen);

        // Conditional array write
        write_instr = write_array(array_var, target_idx_var, elt_surr);
        cond_write_instr = do_if(bool_value(cond_surr), (eval_code | write_instr, increment(target_idx_var)));

        // Body code and sequence creation instruction
        body_code = (cond_eval_code | cond_write_instr);
        mk_seq_instr = mk_seq(res_var, array_var, target_idx_var);

      else
        // Evaluating the expression that yields a new element
        eval_code, elt_surr, unused_var = opt_eval_info(expr.expr, var_gen);

        // Body code and sequence creation instruction
        write_instr = write_array(array_var, idx_var, elt_surr);
        body_code = (eval_code | write_instr);
        mk_seq_instr = mk_seq(res_var, array_var);
      ;
    ;

    // Final body code
    break_cond = if expr.inclusive then is_ge(idx_var, bound_surr) else is_lt(idx_var, bound_surr);
    body_code = ((break_if(break_cond)) & body_code | increment(idx_var));

    // Final code
    code = (code | set_ivar32(idx_var, 0), repeat(body_code), mk_seq_instr);
    return (code, res_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) if_expr_opt_eval_info(IfExpr expr, VarGen init_var_gen) {
    type = types(expr_id);
    return ((terminate), never_used_lvar, init_var_gen) if type == empty_type;
    repr = opt_repr(type);

    cond_eval_code, cond_surr, var_gen = opt_eval_info(expr.cond, init_var_gen);

    res_var, var_gen = next_var(repr, var_gen);
    then_eval_code, unused_var = opt_eval_info(expr.then, res_var, var_gen);
    else_eval_code, unused_var = opt_eval_info(expr.else, res_var, var_gen);

    eval_code = (cond_eval_code | branch(bool_value(cond_surr), then_eval_code, else_eval_code));
    return (eval_code, obj_expr(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) eq_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    left_eval_code, left_surr, var_gen = opt_eval_info(left, init_var_gen);
    right_eval_code, right_surr, var_gen = opt_eval_info(right, var_gen);

    eval_code = left_eval_code & right_eval_code;
    return (eval_code, bool_obj(is_eq(left_surr, right_surr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) and_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == ():
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = and_then(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    ;

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, unused_var = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, unused_var = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) or_expr_opt_eval_info(Expr left, Expr right, VarGen init_var_gen) {
    right_eval_code, right_surr, var_gen = opt_eval_info(right, init_var_gen);
    if right_eval_code == ():
      // Special case: the right expression is an inline one
      assert var_gen == init_var_gen;
      left_eval_code, left_surr, var_gen = opt_eval_info(left, var_gen);
      bool_expr = or_else(bool_value(left_surr), bool_value(right_surr));
      return (left_eval_code, bool_obj(bool_expr), var_gen);
    ;

    // No special case, we need to store the result in a boolean variable
    res_var, ret_var_gen = next_bool_var(init_var_gen);

    left_eval_code, unused_var = opt_eval_info(left, res_var, ret_var_gen);
    right_eval_code, unused_var = opt_eval_info(right, res_var, ret_var_gen);

    eval_code = (left_eval_code | do_if_not(res_var, right_eval_code));
    return (eval_code, bool_obj(res_var), var_gen);
  }


  (Instr*, ObjExpr, VarGen) not_expr_opt_eval_info(Expr expr, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(expr, init_var_gen);
    return (eval_code, bool_obj(neg(bool_value(surr_expr))), var_gen);
  }


  (Instr*, ObjExpr, VarGen) unary_pseudo_call_opt_eval_info(Expr target, Expr arg, VarGen init_var_gen) {
    target_type = subexpr_type(target);
    return ((terminate), never_used_lvar, init_var_gen) if target_type == empty_type;

    coll_eval_code, coll_surr, var_gen = opt_eval_info(target, init_var_gen);
    arg_eval_code, arg_surr, var_gen = opt_eval_info(arg, var_gen);
    eval_code = coll_eval_code & arg_eval_code;

    if is_subset(target_type, type_seq):
      expr_surr = at(coll_surr, get_int_val(arg_surr));

    elif is_subset(target_type, type_set):
      expr_surr = bool_obj(has_elem(coll_surr, arg_surr));

    elif is_subset(target_type, type_map):
      expr_surr = lookup(coll_surr, arg_surr);

    else
      assert is_subset(target_type, atom_type);
      expr_surr, var_gen = next_obj_var(var_gen);
      ## HERE WE COULD CHECK IF THE TARGET OBJECT NEEDS TO BE OPTIMIZED
      eval_code = (eval_code | call_proc(expr_surr, :any_tag_rec_conv, (coll_surr, arg_surr), ()));
      var_gen = init_var_gen;
    ;

    return (eval_code, expr_surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) size_expr_opt_eval_info(Expr collection, VarGen init_var_gen) {
    eval_code, surr_expr, var_gen = opt_eval_info(collection, init_var_gen);
    return (eval_code, int_obj(get_size(surr_expr)), var_gen);
  }


  (Instr*, ObjExpr, VarGen) seq_expr_opt_eval_info(SubExpr* elts, VarGen init_var_gen) {
    // Empty sequence
    return ((), empty_seq, init_var_gen) if elts == ();

    // Types of the elements of the sequence
    ord_elts_types = (subexpr_type(if is_cond_expr(e) then e.expr else e) : e <- elts);
    elts_types = set(ord_elts_types);
    elts_type = union_superset(elts_types);

    // Unreachable expression
    return ((terminate), never_used_lvar, init_var_gen) if elts_types(empty_type) or elts_type == empty_type;

    // Elements representation
    elt_repr = low_level_elt_repr(elts_type);

    // Sequence and array variables
    seq_var, var_gen = next_obj_var(init_var_gen);
    elts_var, var_gen = next_array_var(var_gen, elt_repr);

    // Both seq_var and elts_var must survive the evaluation of the expression
    ret_var_gen = var_gen;

    // Dealing with the important special case of sequences of literal integers
    if is_subset(elts_type, integer) and not (e <~ elts : is_cond_expr(e)):
      if not (t <- elts_types : t == empty_type or not is_singleton(t)):
        int_seq = (only_integer(t) : t <- ord_elts_types);
        seq_id = int_seqs_ids[int_seq];
        code = (build_const_int_seq(seq_var, seq_id));
        return (code, seq_var, ret_var_gen);
      ;
    ;

    conds = (e.cond : e <- elts, is_cond_expr(e));
    if conds == ():
      // Easy case, no conditional inclusions
      code = (alloc_array(elts_var, int32(|elts|)));
      for e @ i <- elts:
        fail if is_cond_expr(e); ## ANY BETTER WAY TO DO THIS?
        fail if not i :: Int32;
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
        code = code & (elt_eval_code | write_array(elts_var, i, elt_surr));
      ;
      return ((code | mk_seq(seq_var, elts_var)), seq_var, ret_var_gen);
    ;

    // Evaluating conditions and final array size
    min_size = int32(|elts| - |conds|);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination array
    code = (alloc_array(elts_var, size_idx_var));

    // Computation of all array elements
    cond_expr_idx = 0;
    for e @ i <- elts:
      fail if not i :: Int32; ## ANY BETTER WAY TO DO THIS?
      is_last = i == |elts| - 1;
      if is_cond_expr(e): // Conditional inclusion expression
        elt_code, elt_surr, unused_var = opt_eval_info(e.expr, var_gen);
        if cond_expr_idx == 0:
          // If it's the first conditional expression, we statically know the
          // destination array index. After that we need to use the cursor
          // variable, unless this is the last element in the sequence
          cond = cond_vars(cond_expr_idx);
          elt_code = (elt_code | write_array(elts_var, i, elt_surr));
          if not is_last:
            elt_code = (elt_code | set_ivar32(size_idx_var, int32(i+1)));
            elt_instr = branch(cond, elt_code, (set_ivar32(size_idx_var, i)));
          else
            elt_instr = do_if(cond, elt_code);
          ;
        else
          elt_code = (elt_code | write_array(elts_var, size_idx_var, elt_surr));
          elt_code = (elt_code | increment(size_idx_var)) if not is_last;
          elt_instr = do_if(cond_vars(cond_expr_idx), elt_code);
        ;
        code = (code | elt_instr);
        cond_expr_idx = cond_expr_idx + 1;

      else // Non-conditional expression
        elt_eval_code, elt_surr, unused_var = opt_eval_info(e, var_gen);
        // Until we reach the first conditional element we statically know the
        // destination array index. After that we need to use the cursor variable
        write_code = if cond_expr_idx == 0
          then (write_array(elts_var, i, elt_surr))
          else (write_array(elts_var, size_idx_var, elt_surr), increment(size_idx_var) if not is_last);
        code = code & elt_eval_code & write_code;
      ;
    ;

    // Creation of the wrapping sequence object
    code = (code | mk_seq(seq_var, elts_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(seq_var, empty_seq)), code)) if min_size == 0;

    return (conds_code & code, seq_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) set_expr_opt_eval_info([SubExpr] elts, VarGen init_var_gen) {
    // Empty set
    return ((), empty_rel, init_var_gen) if elts == [];

    // Set object and array variables.
    set_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    elts_var, var_gen = next_array_var(ret_var_gen, :object);

    exprs = isort([e : e <- elts, not is_cond_expr(e)]);
    cond_exprs = isort([e : e <- elts, is_cond_expr(e)]);

    // Evaluating of conditions and final array size
    min_size = int32(|exprs|);
    conds = (e.cond : e <- cond_exprs);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination array
    size_expr = if cond_exprs == () then min_size else size_idx_var;
    code = (alloc_array(elts_var, size_expr));

    // Non-conditional elements
    for e @ i <- exprs:
      eval_code, surr, unused_var = opt_eval_info(e, var_gen);
      code = (code & eval_code | write_array(elts_var, int32(i), surr));
    ;

    if |cond_exprs| == 1:
      // Just one conditional element, no need to have an index variable
      elt_code, surr, unused_var = opt_eval_info(only(cond_exprs).expr, var_gen);
      elt_code = (elt_code | write_array(elts_var, min_size, surr));
      code = (code | do_if(cond_vars(0), elt_code));

    elif |cond_exprs| > 1:
      // More than one conditional element, we need to keep track of the next array slot
      for e @ i <- cond_exprs:
        cond = cond_vars(i);
        elt_code, surr, unused_var = opt_eval_info(e.expr, var_gen);
        elt_code = (elt_code | write_array(elts_var, if i == 0 then min_size else size_idx_var, surr));
        is_last = i == |cond_exprs| - 1;
        if i == 0:
          elt_code = (elt_code | set_ivar32(size_idx_var, int32(min_size + 1)));
          elt_instr = branch(cond, elt_code, (set_ivar32(size_idx_var, min_size)));
        else
          elt_code = (elt_code | increment(size_idx_var)) if not is_last;
          elt_instr = do_if(cond, elt_code);
        ;
        code = (code | elt_instr);
      ;
    ;

    // Creation of the set object
    code = (code | mk_set(set_obj_var, elts_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(set_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, set_obj_var, ret_var_gen);
  }


  (Instr*, ObjExpr, VarGen) map_expr_opt_eval_info([+(key: Expr, value: Expr, cond: Expr?)] entries, VarGen var_gen) {
    // Checking if the expression is actually a record,
    // and if so building a record object instead
    if not (e <- entries : e.cond?):
      ord_entries = isort(entries);
      keys_types = (subexpr_type(e.key) : e <- ord_entries);
      if not (t <~ keys_types : not is_symb_singl_type(t)):
        labels = (only_symb(t) : t <- keys_types);
        if duplicates(labels) == []:
          return record_opt_eval_info(labels, (e.value : e <- ord_entries), var_gen);
        ;
      ;
    ;

    // Separating conditional entries from unconditional ones
    uncond_entries = isort([(e.key, e.value) : e <- entries, not e.cond?]);
    cond_entries = isort([(e.key, e.value, e.cond) : e <- entries, e.cond?]);

    return bin_rel_expr_opt_eval_info(uncond_entries, cond_entries, true, var_gen);
  }


  (Instr*, ObjExpr, VarGen) bin_rel_expr_opt_eval_info([+(args: (Expr, Expr), cond: Expr?)] entries, VarGen var_gen) {
    // Separating conditional entries from unconditional ones
    uncond_entries = isort([e.args : e <- entries, not e.cond?]);
    cond_entries = isort([(left(e.args), right(e.args), e.cond) : e <- entries, e.cond?]);

    return bin_rel_expr_opt_eval_info(uncond_entries, cond_entries, false, var_gen);
  }


  (Instr*, ObjExpr, VarGen) bin_rel_expr_opt_eval_info((Expr, Expr)* uncond_entries, (Expr, Expr, Expr)* cond_entries, Bool is_map, VarGen init_var_gen) {
    // Binary relation object and array variables.
    rel_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    col1_var, var_gen = next_array_var(ret_var_gen, :object);
    col2_var, var_gen = next_array_var(var_gen, :object);

    // Evaluating of conditions and final array size
    min_size = int32(|uncond_entries|);
    conds = (c : unused_var_1, unused_var_2, c <- cond_entries);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination arrays
    size_expr = if cond_entries == () then min_size else size_idx_var;
    code = (alloc_array(col1_var, size_expr), alloc_array(col2_var, size_expr));

    // Non-conditional elements
    for a1, a2 @ i <- uncond_entries:
      code = code & write_entry_code(a1, a2, col1_var, col2_var, int32(i), var_gen);
    ;

    if |cond_entries| == 1:
      // Just one conditional entry, no need to have an index variable
      arg1, arg2, unused_var = only(cond_entries);
      entry_code = write_entry_code(arg1, arg2, col1_var, col2_var, min_size, var_gen);
      code = (code | do_if(cond_vars(0), entry_code));

    elif |cond_entries| > 1:
      // More than one conditional element, we need to keep track of the next array slot
      for a1, a2, unused_var @ i <- cond_entries:
        cond = cond_vars(i);
        idx = if i == 0 then min_size else size_idx_var;
        entry_code = write_entry_code(a1, a2, col1_var, col2_var, idx, var_gen);
        is_last = i == |cond_entries| - 1;
        if i == 0:
          entry_code = (entry_code | set_ivar32(size_idx_var, int32(min_size+1)));
          entry_instr = branch(cond, entry_code, (set_ivar32(size_idx_var, min_size)));
        else
          entry_code = (entry_code | increment(size_idx_var)) if not is_last;
          entry_instr = do_if(cond, entry_code);
        ;
        code = (code | entry_instr);
      ;
    ;

    // Creation of the map object
    code = (code | mk_rel(rel_obj_var, col1_var, col2_var, is_map));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(rel_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, rel_obj_var, ret_var_gen);


    Instr* write_entry_code(Expr arg1, Expr arg2, ArrayVar col1, ArrayVar col2, Int32Expr idx, VarGen var_gen) {
      eval_code, surr, unused_var = opt_eval_info(arg1, var_gen);
      arg1_code = (eval_code | write_array(col1, idx, surr));
      eval_code, surr, unused_var = opt_eval_info(arg2, var_gen);
      arg2_code = (eval_code | write_array(col2, idx, surr));
      return arg1_code & arg2_code;
    }
  }


  (Instr*, ObjExpr, VarGen) tern_rel_expr_opt_eval_info([+(args: (Expr, Expr, Expr), cond: Expr?)] entries, VarGen init_var_gen) {
    // Binary relation object and array variables.
    rel_obj_var, ret_var_gen = next_obj_var(init_var_gen);
    col1_var, var_gen = next_array_var(ret_var_gen, :object);
    col2_var, var_gen = next_array_var(var_gen, :object);
    col3_var, var_gen = next_array_var(var_gen, :object);

    // Separating conditional entries from unconditional ones
    uncond_entries = isort([e : e <- entries, not e.cond?]);
    cond_entries = isort([e : e <- entries, e.cond?]);

    // Evaluating of conditions and final array size
    min_size = int32(|uncond_entries|);
    conds = (e.cond : e <- cond_entries);
    conds_code, cond_vars, size_idx_var, var_gen = conds_eval_info(conds, min_size, var_gen);

    // Allocation of destination arrays
    size_expr = if cond_entries == () then min_size else size_idx_var;
    code = (alloc_array(v, size_expr) : v <- (col1_var, col2_var, col3_var));

    // Non-conditional elements
    for e @ i <- uncond_entries:
      code = code & write_entry_code(e.args, col1_var, col2_var, col3_var, int32(i), var_gen);
    ;

    if |cond_entries| == 1:
      // Just one conditional entry, no need to have an index variable
      entry = only(cond_entries);
      entry_code = write_entry_code(entry.args, col1_var, col2_var, col3_var, min_size, var_gen);
      code = (code | do_if(cond_vars(0), entry_code));

    elif |cond_entries| > 1:
      // More than one conditional element, we need to keep track of the next array slot
      for e @ i <- cond_entries:
        cond = cond_vars(i);
        idx = if i == 0 then min_size else size_idx_var;
        entry_code = write_entry_code(e.args, col1_var, col2_var, col3_var, idx, var_gen);
        is_last = i == |cond_entries| - 1;
        if i == 0:
          entry_code = (entry_code | set_ivar32(size_idx_var, int32(min_size+1)));
          entry_instr = branch(cond, entry_code, (set_ivar32(size_idx_var, min_size)));
        else
          entry_code = (entry_code | increment(size_idx_var)) if not is_last;
          entry_instr = do_if(cond, entry_code);
        ;
        code = (code | entry_instr);
      ;
    ;

    // Creation of the map object
    code = (code | mk_rel(rel_obj_var, col1_var, col2_var, col3_var));

    // Checking for the empty sequence/set case, if all expression are conditional
    code = (branch(is_eq(size_idx_var, 0), (set_var(rel_obj_var, empty_rel)), code)) if min_size == 0;

    return (conds_code & code, rel_obj_var, ret_var_gen);


    Instr* write_entry_code((Expr, Expr, Expr) args, ArrayVar col1, ArrayVar col2, ArrayVar col3, Int32Expr idx, VarGen var_gen) {
      arg1, arg2, arg3 = args;
      eval_code, surr, unused_var = opt_eval_info(arg1, var_gen);
      arg1_code = (eval_code | write_array(col1, idx, surr));
      eval_code, surr, unused_var = opt_eval_info(arg2, var_gen);
      arg2_code = (eval_code | write_array(col2, idx, surr));
      eval_code, surr, unused_var = opt_eval_info(arg3, var_gen);
      arg3_code = (eval_code | write_array(col3, idx, surr));
      return arg1_code & arg2_code & arg3_code;
    }
  }


  (Instr*, ObjExpr, VarGen) fn_call_opt_eval_info(FnCallExpr expr, VarGen init_var_gen) {
    // fn_call(fn_id: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr])
    assert expr.impl_args == [];
    fail if not expr.args :: Expr* or not expr.impl_args :: [ImplArg -> ExprRef];

    // Actual arguments information
    args_types = (subexpr_type(a) : a <- expr.args);

    // Evaluation of the arguments
    args_eval_code, args_surrs, unused_var = opt_eval_info(expr.args, init_var_gen);

    // Signature of the target function
    fn_id, low_level_sign = low_level_sign(expr.fn_id, args_types);

    // Low-level actual arguments
    low_level_args = (low_level_expr(low_level_sign.args(i), s) : s @ i <- args_surrs);

    // Return value variable. Once the call returns the arguments
    // are not needed anymore, so we can reuse the variables
    res_var, var_gen = next_var(low_level_sign.ret_value, init_var_gen);

    // Evaluation code for the call only
    cls_args = (compiled_closure(a, next_var_gen = init_var_gen) : a <- expr.cls_args);
    eval_code = (args_eval_code | call_proc(res_var, fn_id, low_level_args, cls_args));

    return (eval_code, obj_expr(res_var), var_gen);
  }


  // builtin_call(name: BuiltIn, args: Expr+);
  (Instr*, ObjExpr, VarGen) builtin_call_opt_eval_info(BuiltinCall expr, VarGen init_var_gen) {
    // Evaluation of the arguments
    args_eval_code, args_surrs, unused_var = opt_eval_info(expr.args, init_var_gen);

    // Builtin call. The arguments are not needed anymore once the call
    // returns, so we can restart from the initial variables generator
    code, surr, var_gen = eval_info(expr.name, nonempty(args_surrs), init_var_gen);

    return (args_eval_code & code, surr, var_gen);


    (Instr*, ObjExpr, VarGen) eval_info(BuiltIn name, ObjExpr+ args, VarGen init_var_gen) =
      slice   |
      cat     |
      rev     |
      isort   |
      parse   |
      print   |
      str     = { res_var, var_gen = next_obj_var(init_var_gen);
                  instr = eval_instr(name, args, res_var);
                  return ((instr), res_var, var_gen);
                },
      _       = ((), eval_expr(name, args), init_var_gen);


    Instr eval_instr(BuiltIn name, ObjExpr+ args, LocVar res_var) =
      slice         = get_seq_slice(res_var, args(0), get_int_val(args(1)), get_int_val(args(2))),
      cat           = join_seqs(res_var, args(0), args(1)),
      rev           = rev_seq(res_var, args(0)),
      isort         = internal_sort(res_var, args(0)),
      parse         = parse_value(res_var, args(0)),
      print         = print_value(res_var, args(0)),
      str           = symb_to_str(res_var, args(0));


    ObjExpr eval_expr(BuiltIn name, ObjExpr+ args) =
      neg       |
      add       |
      sub       |
      mult      |
      div       |
      mod       |
      and       |
      or        |
      xor       = int_obj(int_op_eval_info(name, (get_int_val(a) : a <- args))),
      lt        |
      le        = bool_obj(bool_op_eval_info(name, (get_int_val(a) : a <- args))),
      flt       |
      fle       = bool_obj(floats_to_bool_op_eval_info(name, (float_value(a) : a <- args))),
      bits      |
      mantissa  |
      dec_exp   = int_obj(int_op_eval_info(name, float_value(args(0)))),
      fneg      |
      fadd      |
      fsub      |
      fmult     |
      fdiv      |
      fexp      |
      fsqrt     = float_obj(float_op_eval_info(name, (float_value(a) : a <- args))),
      float     = float_obj(int_to_float(get_int_val(args(0)))),
      symb      = to_symb(args(0)),
      tag       = get_tag(args(0)),
      untag     = get_inner_obj(args(0));



    BoolExpr bool_op_eval_info(BuiltIn, IntExpr+ args) =
      lt  = is_lt(args(0), args(1)),
      le  = is_le(args(0), args(1));

    BoolExpr floats_to_bool_op_eval_info(BuiltIn, FloatExpr+ args) =
      flt   = is_flt(args(0), args(1)),
      fle   = is_fle(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, IntExpr+ args) =
      neg   = minus(args(0)),
      add   = add(args(0), args(1)),
      sub   = sub(args(0), args(1)),
      mult  = mult(args(0), args(1)),
      div   = div(args(0), args(1)),
      mod   = mod_op(args(0), args(1)),
      and   = bitwise_and(args(0), args(1)),
      or    = bitwise_or(args(0), args(1)),
      xor   = bitwise_xor(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, FloatExpr arg) =
      bits      = float_bits(arg),
      mantissa  = mantissa(arg),
      dec_exp   = dec_exp(arg);

    FloatExpr float_op_eval_info(BuiltIn, FloatExpr+ args) =
      fneg  = neg_float(args(0)),
      fadd  = add_floats(args(0), args(1)),
      fsub  = sub_floats(args(0), args(1)),
      fmult = mult_floats(args(0), args(1)),
      fdiv  = div_floats(args(0), args(1)),
      fexp  = exp_floats(args(0), args(1)),
      fsqrt = square_root(args(0));
  }

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////

  (Instr*, BoolVar+, Int32Var, VarGen) conds_eval_info(Expr* conds, Int32 min_size, VarGen init_var_gen) {
    // Evaluation of all conditions
    var_gen = init_var_gen;
    cond_vars = ();
    code = ();
    for c @ i <- conds:
      eval_code, surr_expr, var_gen = opt_eval_info(c, var_gen);
      if not surr_expr :: <bool_obj(BoolVar)>:
        surr_var, var_gen = next_bool_var(var_gen);
        eval_code = store_result(eval_code, surr_expr, surr_var);
      else
        surr_var = untag(surr_expr);
      ;
      code = code & eval_code;
      cond_vars = (cond_vars | surr_var);
    ;

    // Integer variable for both size and cursor
    size_var, var_gen = next_int32_var(var_gen);

    // Computation of final array size
    len_expr = foldr(nonempty((bool_to_bit(v) : v <- cond_vars)), add32);
    len_expr = add32(min_size, len_expr) if min_size != 0;
    code = (code | set_ivar32(size_var, len_expr));

    return (code, nonempty(cond_vars), size_var, var_gen);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Instr+ store_result(Instr* code, ObjExpr surr_expr, AnyLocVar res_var) {
  def_code = (code | set_any_var(res_var, surr_expr));
  return def_code if code == ();
  trimmed_code = take(code, |code| - 1);

  return match (rat(code, 0))
    set_bvar()   i? |
    set_ivar()   i? |
    set_ivar32() i? | ## WHY DOES THIS EXPRESSION TYPECHECKS EVEN WITH AN Int32Var?
    set_fvar()   i? |
    set_var()    i? = if i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                        then (trimmed_code | set_any_var(res_var, obj_expr(i.value)))
                        else def_code,

    call_proc()  i? = if i.var? and i.var :: AnyLocVar and surr_expr == obj_expr(i.var)
                        then (trimmed_code | call_proc(res_var, i.name, i.args, i.cls_args))
                        else def_code,

    _               = def_code;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type AnyLocVar = LocBoolVar, LocIntVar, LocFloatVar, LocOptTagRecVar, LocVar, StdVar;


(AnyLocVar, VarGen) next_var(LowLevelRepr repr, VarGen gen) =
  bool    = next_bool_var(gen),
  int     = next_int_var(gen),
  float   = next_float_var(gen),
  symbol  |
  object  = next_obj_var(gen);

(LocOptTagRecVar, VarGen) next_var(OptTagRecRepr repr, VarGen gen) =
  next_opt_tag_rec_var(gen, repr.tag, repr.index);


## FIND BETTER NAME
(AnyLocVar, VarGen) next_var_def(LowLevelRepr repr, StdVar var, VarGen var_gen) =
  bool      |
  int       |
  float     = next_var(repr, var_gen),
  symbol    |
  object    = (var, var_gen);

(LocOptTagRecVar, VarGen) next_var_def(OptTagRecRepr repr, StdVar var, VarGen var_gen) =
  next_var(repr, var_gen);


Instr set_any_var(LocBoolVar  var, ObjExpr expr) = set_bvar(var, bool_value(expr));
Instr set_any_var(LocIntVar   var, ObjExpr expr) = set_ivar(var, get_int_val(expr));
Instr set_any_var(LocFloatVar var, ObjExpr expr) = set_fvar(var, float_value(expr));
Instr set_any_var(WriteObjVar var, ObjExpr expr) = set_var(var, expr);
Instr set_any_var(LocOptTagRecVar var, ObjExpr expr) = set_var(var, expr);
