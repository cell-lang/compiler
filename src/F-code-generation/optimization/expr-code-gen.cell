// type EnvExpr = EnvVar, ExprRef;

type SubExprInfo = (type: Type, surr_expr: ObjExpr);


implicit program : Program, typedefs : [TypeName -> NeType], context : Context, var_surrs : [EnvVar -> ObjExpr] {
  (Instr*, ObjExpr, VarGen) opt_eval_info(<undefined>, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    return ((terminate), never_used_lvar, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(LeafObj expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    return ((), expr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(FloatLit expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(Var var, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    surr = if var :: EnvVar then var_surrs(var, !!) else var;
    return ((), surr, var_gen);
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsDefExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(OutputIsSetExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(ExprRef expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail;
  }


  (Instr*, ObjExpr, VarGen) opt_eval_info(RecExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) =
    seq_expr(ses?)      = undefined,
    tuple_expr(es?)     = undefined,
    seq_tail_expr()     = undefined,
    set_expr(ses?)      = undefined,
    map_expr(es?)       = undefined,
    bin_rel_expr(es?)   = undefined,
    tern_rel_expr(es?)  = undefined,
    tag_obj_expr()      = undefined,
    fn_call()           = fn_call_opt_eval_info(expr, var_gen, subexpr_info),
    cls_call()          = undefined,
    builtin_call()      = builtin_call_opt_eval_info(expr, var_gen, subexpr_info),
    size_expr()         = undefined,
    unary_pseudo_call() = undefined,
    rel_memb_test()     = undefined,
    rel_lookup()        = undefined,
    relvar_memb_test()  = undefined,
    relvar_lookup()     = undefined,
    and_expr()          = undefined,
    or_expr()           = undefined,
    not_expr(e?)        = undefined,
    eq()                = undefined,
    membership()        = undefined,
    cast_expr()         = undefined,
    accessor()          = undefined,
    accessor_test()     = undefined,
    auto_method_call()  = undefined,
    db_method_call()    = undefined,
    if_expr()           = undefined,
    match_expr()        = undefined,
    do_expr()           = undefined,
    ex_qual()           = undefined,
    set_comp()          = undefined,
    map_comp()          = undefined,
    bin_rel_comp()      = undefined,
    tern_rel_comp()     = undefined,
    seq_comp()          = undefined,
    range_comp()        = undefined;


  // fn_call(fn_id: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr])
  (Instr*, ObjExpr, VarGen) fn_call_opt_eval_info(FnCallExpr expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    assert expr.impl_args == [];
    fail if not expr.args :: ExprRef* or not expr.impl_args :: [ImplArg -> ExprRef];

    // Actual arguments information
    args_info = (subexpr_info(a) : a <- expr.args);

    // Signature of the target function
    fn_id, low_level_sign = low_level_sign(expr.fn_id, (just(a.type) : a <- args_info));

    // Low-level actual arguments
    low_level_args = (low_level_expr(value_unsafe(low_level_sign.args(i)), a.surr_expr) : a @ i <- args_info);

    // Result variable, surrogate expression and next variable generator
    res_var, surr_expr, next_var_gen = match (low_level_sign.ret_value)
      bool            = {v, g = next_bool_var(var_gen);  return (v, bool_obj(v),  g);},
      int             = {v, g = next_int_var(var_gen);   return (v, int_obj(v),   g);},
      float           = {v, g = next_float_var(var_gen); return (v, float_obj(v), g);},
      symbol | object = {v, g = next_obj_var(var_gen);   return (v, v,            g);};

    // Evaluation code for the call only
    eval_code = (call_proc(res_var, fn_id, low_level_args));

    return (eval_code, surr_expr, next_var_gen);
  }


  // builtin_call(name: BuiltIn, args: Expr+);
  (Instr*, ObjExpr, VarGen) builtin_call_opt_eval_info(BuiltinCall expr, VarGen var_gen, (ExprRef -> SubExprInfo) subexpr_info) {
    fail if not expr.args :: ExprRef+;

    surr_args = (subexpr_info(a).surr_expr : a <- expr.args);
    return eval_info(expr.name, surr_args, var_gen);


    (Instr*, ObjExpr, VarGen) eval_info(BuiltIn name, ObjExpr+ args, VarGen var_gen) =
      slice   |
      cat     |
      rev     |
      isort   |
      parse   |
      print   |
      str     = { res_var, next_var_gen = next_obj_var(var_gen);
                  instr = eval_instr(name, args, res_var);
                  return ((instr), res_var, next_var_gen);
                },
      _       = ((), eval_info(name, args), var_gen);


    Instr eval_instr(BuiltIn name, ObjExpr+ args, LocVar res_var) =
      slice         = get_seq_slice(res_var, args(0), get_int_val(args(1)), get_int_val(args(2))),
      cat           = join_seqs(res_var, args(0), args(1)),
      rev           = rev_seq(res_var, args(0)),
      isort         = internal_sort(res_var, args(0)),
      parse         = parse_value(res_var, args(0)),
      print         = print_value(res_var, args(0)),
      str           = symb_to_str(res_var, args(0));



    ObjExpr eval_info(BuiltIn name, ObjExpr+ args) =
      neg       |
      add       |
      sub       |
      mult      |
      div       |
      mod       |
      and       |
      or        |
      xor       = int_obj(int_op_eval_info(name, (get_int_val(a) : a <- args))),
      lt        |
      le        = bool_obj(bool_op_eval_info(name, (get_int_val(a) : a <- args))),
      flt       |
      fle       = bool_obj(floats_to_bool_op_eval_info(name, (float_value(a) : a <- args))),
      bits      |
      mantissa  |
      dec_exp   = int_obj(int_op_eval_info(name, float_value(args(0)))),
      fneg      |
      fadd      |
      fsub      |
      fmult     |
      fdiv      |
      fexp      |
      fsqrt     = float_obj(float_op_eval_info(name, (float_value(a) : a <- args))),
      float     = float_obj(int_to_float(get_int_val(args(0)))),
      symb      = to_symb(args(0)),
      tag       = get_tag(args(0)),
      untag     = get_inner_obj(args(0));



    BoolExpr bool_op_eval_info(BuiltIn, IntExpr+ args) =
      lt  = is_lt(args(0), args(1)),
      le  = is_le(args(0), args(1));

    BoolExpr floats_to_bool_op_eval_info(BuiltIn, FloatExpr+ args) =
      flt   = is_flt(args(0), args(1)),
      fle   = is_fle(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, IntExpr+ args) =
      neg   = minus(args(0)),
      add   = add(args(0), args(1)),
      sub   = sub(args(0), args(1)),
      mult  = mult(args(0), args(1)),
      div   = div(args(0), args(1)),
      mod   = mod_op(args(0), args(1)),
      and   = bitwise_and(args(0), args(1)),
      or    = bitwise_or(args(0), args(1)),
      xor   = bitwise_xor(args(0), args(1));

    IntExpr int_op_eval_info(BuiltIn, FloatExpr arg) =
      bits      = float_bits(arg),
      mantissa  = mantissa(arg),
      dec_exp   = dec_exp(arg);

    FloatExpr float_op_eval_info(BuiltIn, FloatExpr+ args) =
      fneg  = neg_float(args(0)),
      fadd  = add_floats(args(0), args(1)),
      fsub  = sub_floats(args(0), args(1)),
      fmult = mult_floats(args(0), args(1)),
      fdiv  = div_floats(args(0), args(1)),
      fexp  = exp_floats(args(0), args(1)),
      fsqrt = square_root(args(0));

  }
}


  // Instr+ gen_eval_code_for_fn_call_expr(FnFamilyId id, AnyExpr* params, [ImplArg -> Expr] impl_args, EvalDestVar res_var) {
  //   if impl_args != []:
  //     ## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
  //     var = an_elem(nonempty(keys(impl_args)));
  //     expr = impl_args[var];
  //     rem_impl_args = [v -> e : v, e <- impl_args, v != var];
  //     backup_var, var_gen = next_obj_var(next_var_gen);
  //     info = gen_eval_info(expr, next_var_gen = var_gen);
  //     body = gen_eval_code_for_fn_call_expr(id, params, rem_impl_args, res_var, next_var_gen = info.next_var_gen);
  //     set_up_code = (set_var(backup_var, var), set_var(var, info.expr));
  //     tear_down_code = (set_var(var, backup_var));
  //     return nonempty(info.eval_code & set_up_code & body & tear_down_code);

  //   else
  //     pars_are_first_order = (is_expr(p) : p <- params);
  //     par_packed_idxs = packed_seq_idxs(pars_are_first_order);
  //     pars_info = gen_eval_info((cast_as_expr(p) : p @ i <- params, pars_are_first_order(i)));
  //     all_params = (
  //       if pars_are_first_order(i)
  //         then pars_info.exprs(par_packed_idxs[i])
  //         else compiled_closure(cast_as_cls_expr(p))
  //     : p @ i <- params);
  //     core_call_code = (call_proc(res_var, id, all_params));
  //     return nonempty(pars_info.eval_code & core_call_code);
  //   ;
  // }


// type RecExpr  = SetExpr, SeqExpr, TupleExpr, SeqTailExpr,
//                 MapExpr, BinRelExpr, TernRelExpr, TagObjExpr,
//                 FnCallExpr, ClsCall, BuiltinCall,
//                 SizeExpr,
//                 UnaryPseudoCall, RelMembTest, RelLookup,
//                 RelVarMembTest, RelVarLookup,
//                 AndExpr, OrExpr, NotExpr,
//                 EqExpr,
//                 MembExpr, CastExpr,
//                 AccExpr, AccTestExpr,
//                 AutoMethodCall, DBMethodCall,
//                 IfExpr, MatchExpr, DoExpr,
//                 ExQualExpr, SetCompExpr, MapCompExpr, BinRelCompExpr, TernRelCompExpr,
//                 SeqCompExpr, RangeCompExpr;
