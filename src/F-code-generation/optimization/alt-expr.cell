Expr+ exprs_cluster(Expr expr) = nonempty(exprs_cluster(expr, 0));

////////////////////////////////////////////////////////////////////////////////

type NonRecExpr     = undefined, LeafObj, FloatLit, Var, OutputIsDefExpr, OutputIsSetExpr;

Expr* exprs_cluster(NonRecExpr expr, Nat offset) = (expr);


Expr* exprs_cluster(<ExprRef, CastExpr>, Nat) = undefined;

////////////////////////////////////////////////////////////////////////////////
///////////////////// Order of subexpression doesn't matter ////////////////////

type RecExprGroup1  = SeqExpr, SetExpr, TupleExpr, TagObjExpr, ClsCall,
                      BuiltinCall, SizeExpr, UnaryPseudoCall, NotExpr, EqExpr,
                      MembExpr, AccExpr, AccTestExpr, RelVarMembTest;


Expr* exprs_cluster(RecExprGroup1 expr, Nat offset) =
  set_expr(ses?)      = subexprs_cluster(isort(ses), offset, set_expr(set($))),
  seq_expr(ses?)      = subexprs_cluster(ses, offset, seq_expr($)),
  tuple_expr(es?)     = exprs_cluster(es, offset, tuple_expr(nonempty($))),
  tag_obj_expr()      = exprs_cluster((expr.tag, expr.obj), offset, tag_obj_expr($(0), $(1))),
  cls_call()          = exprs_cluster(expr.args, offset, cls_call(expr.name, nonempty($))),
  builtin_call()      = exprs_cluster(expr.args, offset, builtin_call(expr.name, nonempty($))),
  size_expr()         = expr_cluster(expr.coll, offset, size_expr($)),
  unary_pseudo_call() = exprs_cluster((expr.target, expr.arg), offset, unary_pseudo_call($(0), $(1))),
  not_expr(e?)        = expr_cluster(e, offset, not_expr($)),
  eq()                = exprs_cluster((expr.left, expr.right), offset, eq($(0), $(1))),
  membership()        = expr_cluster(expr.obj, offset, membership($, expr.type)),
  accessor()          = expr_cluster(expr.expr, offset, accessor($, expr.field)),
  accessor_test()     = expr_cluster(expr.expr, offset, accessor_test($, expr.field)),
  relvar_memb_test()  = maybe_exprs_cluster(expr.args, offset, relvar_memb_test(expr.rel_var, nonempty($)));


// rel_memb_test(rel: Expr, args: Maybe[Expr]+);
Expr* exprs_cluster(RelMembTest expr, Nat offset) =
  maybe_exprs_cluster(
    (just(expr.rel)) & expr.args,
    offset,
    rel_memb_test(value_unsafe($(0)), nonempty(tail(nonempty($))))
  );

// seq_tail_expr(seq: Expr, tail: Expr+);
Expr* exprs_cluster(SeqTailExpr expr, Nat offset) =
  exprs_cluster(
    (expr.seq) & expr.tail,
    offset,
    seq_tail_expr($(0), nonempty(tail(nonempty($))))
  );

// rel_lookup(rel: Expr, set_args: Expr*, unknown_arg_idx: Nat);
Expr* exprs_cluster(RelLookup expr, Nat offset) =
  exprs_cluster(
    (expr.rel) & expr.set_args,
    offset,
    rel_lookup($(0), tail(nonempty($)), expr.unknown_arg_idx)
  );

// relvar_lookup(rel_var: AnyRelVar, set_args: Expr*, unknown_arg_idx: Nat);
Expr* exprs_cluster(RelVarLookup expr, Nat offset) =
  exprs_cluster(
    expr.set_args,
    offset,
    relvar_lookup(expr.rel_var, $, expr.unknown_arg_idx)
  );

// auto_method_call(var: AnyAutoVar?, name: MethodSymbol, args: Expr*);
Expr* exprs_cluster(AutoMethodCall expr, Nat offset) =
  exprs_cluster(
    expr.args,
    offset,
    auto_method_call(var: expr.var if expr.var?, name: expr.name, args: $)
  );

// db_method_call(var: AnyDBVar?, name: MethodSymbol, args: Expr*);
Expr* exprs_cluster(DBMethodCall expr, Nat offset) =
  exprs_cluster(
    expr.args,
    offset,
    db_method_call(var: expr.var if expr.var?, name: expr.name, args: $)
  );

////////////////////////////////////////////////////////////////////////////////
//////////////// Subexpression must be arranged in proper order ////////////////

type RecExprGroup2  = AndExpr, OrExpr, IfExpr;

Expr* exprs_cluster(RecExprGroup2 expr, Nat offset) =
  and_expr()  = exprs_cluster((expr.right, expr.left), offset, and_expr($(1), $(0))),
  or_expr()   = exprs_cluster((expr.right, expr.left), offset, or_expr($(1), $(0))),
  if_expr()   = exprs_cluster((expr.then, expr.else, expr.cond), offset, if_expr($(2), $(0), $(1)));

// map_expr([+(key: Expr, value: Expr, cond: Expr?)]);
Expr* exprs_cluster(MapExpr expr, Nat offset) =
  exprs_cluster(
    [(e.key, e.value, e.cond if e.cond?) : e <- untag(expr)],
    offset,
    map_expr(nonempty([(key: e(0), value: e(1), cond: e(2) if |e| == 3) : e <- $]))
  );


// bin_rel_expr([+(args: (Expr, Expr), cond: Expr?)]);
Expr* exprs_cluster(BinRelExpr expr, Nat offset) =
  exprs_cluster(
    [e.args & (e.cond if e.cond?) : e <- untag(expr)],
    offset,
    bin_rel_expr(nonempty([(args: (e(0), e(1)), cond: e(2) if |e| == 3) : e <- $]))
  );


// tern_rel_expr([+(args: (Expr, Expr, Expr), cond: Expr?)]);
Expr* exprs_cluster(TernRelExpr expr, Nat offset) =
  exprs_cluster(
    [e.args & (e.cond if e.cond?) : e <- untag(expr)],
    offset,
    tern_rel_expr(nonempty([(args: (e(0), e(1), e(2)), cond: e(3) if |e| == 4) : e <- $]))
  );

// seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
Expr* exprs_cluster(SeqCompExpr expr, Nat offset) =
  exprs_cluster(
    (expr.expr, expr.sel_expr if expr.sel_expr?, expr.src_expr),
    offset,
    seq_comp(
      expr:     $(0),
      vars:     expr.vars,
      idx_var:  expr.idx_var if expr.idx_var?,
      src_expr: rev_at($, 0),
      sel_expr: $(1) if expr.sel_expr?
    )
  );

// range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
Expr* exprs_cluster(RangeCompExpr expr, Nat offset) =
  exprs_cluster(
    (expr.expr, expr.sel_expr if expr.sel_expr?, expr.bound_expr),
    offset,
    range_comp(
      expr:       $(0),
      var:        expr.var,
      bound_expr: rev_at($, 0),
      inclusive:  expr.inclusive,
      sel_expr:   $(1) if expr.sel_expr?
    )
  );

////////////////////////////////////////////////////////////////////////////////
/////////////////////////// Expressions with clauses ///////////////////////////

// ex_qual(source: Clause, cond: Expr);
Expr* exprs_cluster(ExQualExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    (expr.cond),
    offset,
    ex_qual($a, only_unsafe($b))
  );

// set_comp(expr: Expr, source: Clause);
Expr* exprs_cluster(SetCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    (expr.expr),
    offset,
    set_comp(only_unsafe($b), $a)
  );


// map_comp(key_expr: Expr, value_expr: Expr, source: Clause);
Expr* exprs_cluster(MapCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    (expr.key_expr, expr.value_expr),
    offset,
    map_comp($b(0), $b(1), $a)
  );


// bin_rel_comp(exprs: (Expr, Expr), source: Clause);
Expr* exprs_cluster(BinRelCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    expr.exprs,
    offset,
    bin_rel_comp(($b(0), $b(1)), $a)
  );


// tern_rel_comp(exprs: (Expr, Expr, Expr), source: Clause);
Expr* exprs_cluster(TernRelCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    expr.exprs,
    offset,
    tern_rel_comp(($b(0), $b(1), $b(2)), $a)
  );

////////////////////////////////////////////////////////////////////////////////
/////////////////////////// More complex expressions ///////////////////////////

// fn_call(fn_id: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr]);
Expr* exprs_cluster(FnCallExpr expr, Nat offset) {
  first_ord_args = (pack(a) : a <- expr.args);
  impl_args_names = isort(keys(expr.impl_args));
  impl_args = (just(expr.impl_args(n, !!)) : n <- impl_args_names);
  return maybe_exprs_cluster(first_ord_args & impl_args, offset, reconstruct($, expr, impl_args_names));


  Expr reconstruct(Maybe[Expr]* exprs, FnCallExpr expr, ImplArg* impl_args_names) {
    args = (unpack(a, exprs(i)) : a @ i <- expr.args);
    offset = |args|;
    impl_args = [n -> value_unsafe(exprs(offset+i)) : n @ i <~ impl_args_names];
    return fn_call(expr.fn_id, args, impl_args);
  }

  Just[Expr] pack(Expr expr)  = just(expr);
  Nothing    pack(AnyClsExpr) = nothing;

  Expr       unpack(Expr, Maybe[Expr] alt_expr)  = value_unsafe(alt_expr);
  AnyClsExpr unpack(AnyClsExpr, Just[Expr])      = undefined;
  AnyClsExpr unpack(AnyClsExpr expr, Nothing)    = expr;
}


// match_expr(exprs: Expr+, cases: (ptrns: Pattern+, expr: Expr)+);
Expr* exprs_cluster(MatchExpr expr, Nat offset) =
  exprs_cluster(
    (c.expr : c <- expr.cases) & expr.exprs,
    offset,
    match_expr(
      nonempty(drop($, |expr.cases|)),
      ((ptrns: c.ptrns, expr: $(i)) : c @ i <- expr.cases)
    )
  );


// do_expr(body: Statement+, typed_vars: [StdVar -> NeType]);
Expr* exprs_cluster(DoExpr expr, Nat offset) {
  return (expr);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr* exprs_cluster(Clause cls, Expr+ exprs, Nat offset, (Clause Expr+ -> Expr) parent_expr) {
  return cluster_expr_seqs((exprs), offset, clause_cluster(cls, offset, $a, $b, parent_expr));

  Expr* clause_cluster(Clause cls, Nat base_offset, Expr** repl_exprs, Expr* cluster, (Clause Expr+ -> Expr) parent_expr) {
    offset = nat(base_offset + 1 + |cluster|);
    repl_clause, clause_cluster = cluster_clause(cls, offset);
    return (parent_expr(repl_clause, nonempty(only_unsafe(repl_exprs)))) & cluster & clause_cluster;
  }
}


// rel_clause(vars: StdVar+, src: Expr, args: Maybe[Expr]+),
(RelClause, Expr*) cluster_clause(RelClause cls, Nat offset) {
  packed_exprs = ((cls.src)) & (opt(a) : a <- cls.args);
  repl_exprs, cluster = cluster_expr_seqs(packed_exprs, offset);
  src = only_unsafe(repl_exprs(0));
  args = (maybe_unsafe(e) : e <- tail(nonempty(repl_exprs)));
  return (rel_clause(cls.vars, src, nonempty(args)), cluster);
}

// relvar_clause(vars: StdVar+, rel_var: AnyRelVar, args: Maybe[Expr]+),
(RelvarClause, Expr*) cluster_clause(RelvarClause cls, Nat offset) {
  repl_exprs, cluster = cluster_expr_seqs((opt(a) : a <- cls.args), offset);
  repl_cls = relvar_clause(cls.vars, cls.rel_var, (maybe_unsafe(e) : e <- nonempty(repl_exprs)));
  return (repl_cls, cluster);
}

// and_clause(left: Clause, right: Clause),
(AndClause, Expr*) cluster_clause(AndClause cls, Nat offset) {
  right_cls_repl, right_cluster = cluster_clause(cls.right, offset);
  left_cls_repl, left_cluster = cluster_clause(cls.left, nat(offset + |right_cluster|));
  return (and_clause(left_cls_repl, right_cls_repl), right_cluster & left_cluster);
}

// or_clause(left: Clause, right: Clause),
(OrClause, Expr*) cluster_clause(OrClause cls, Nat offset) {
  right_cls_repl, right_cluster = cluster_clause(cls.right, offset);
  left_cls_repl, left_cluster = cluster_clause(cls.left, nat(offset + |right_cluster|));
  return (or_clause(left_cls_repl, right_cls_repl), right_cluster & left_cluster);
}

// set_clause(var: StdVar, src: Expr),
(SetClause, Expr*) cluster_clause(SetClause cls, Nat offset) = (
  set_clause(cls.var, expr_ref(offset)),
  exprs_cluster(cls.src, offset)
);

// seq_clause(vars: Maybe[StdVar]+, idx_var: Maybe[StdVar], src: Expr),
(SeqClause, Expr*) cluster_clause(SeqClause cls, Nat offset) = (
  seq_clause(cls.vars, cls.idx_var, expr_ref(offset)),
  exprs_cluster(cls.src, offset)
);

// match_clause(ptrn: Pattern, expr: Expr),
(MatchClause, Expr*) cluster_clause(MatchClause cls, Nat offset) = (
  match_clause(cls.ptrn, expr_ref(offset)),
  exprs_cluster(cls.expr, offset)
);

// asgnm_clause(var: StdVar, expr: Expr),
(AsgnmClause, Expr*) cluster_clause(AsgnmClause cls, Nat offset) = (
  asgnm_clause(cls.var, expr_ref(offset)),
  exprs_cluster(cls.expr, offset)
);

// filter_clause(Expr);
(FilterClause, Expr*) cluster_clause(FilterClause cls, Nat offset) = (
  filter_clause(expr_ref(offset)),
  exprs_cluster(untag(cls), offset)
);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr* expr_cluster(Expr expr, Nat offset, (Expr -> Expr) parent_expr) =
  exprs_cluster((expr), offset, parent_expr(only_unsafe($)));


Expr* exprs_cluster(Expr* exprs, Nat offset, (Expr* -> Expr) parent_expr) =
  cluster_expr_seqs((exprs), offset, (parent_expr(only_unsafe($a))) & $b);


Expr* exprs_cluster([Expr*] exprs, Nat offset, ([Expr*] -> Expr) parent_expr) =
  cluster_expr_seqs(isort(exprs), offset, (parent_expr(set($a))) & $b);


Expr* maybe_exprs_cluster(Maybe[Expr]* exprs, Nat offset, (Maybe[Expr]* -> Expr) parent_expr) =
  cluster_expr_seqs((opt(e) : e <- exprs), offset, (parent_expr((maybe_unsafe(e) : e <- $a))) & $b);


Expr* subexprs_cluster(SubExpr* subexprs, Nat offset, (SubExpr* -> Expr) parent_expr) {
  packed_exprs = (pack(e) : e <- subexprs);
  return cluster_expr_seqs(packed_exprs, offset, (parent_expr((unpack(es) : es <- $a))) & $b);

  (Expr)       pack(Expr expr)     = (expr);
  (Expr, Expr) pack(CondExpr expr) = (expr.expr, expr.cond);

  SubExpr unpack(Expr* expr) =
    (e?)      = e,
    (e?, c?)  = cond_expr(e, c);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr* cluster_expr_seqs(Expr** exprs, Nat offset, (Expr** Expr* -> Expr*) parent_expr) {
  repl_exprs, cluster = cluster_expr_seqs(exprs, offset);
  return parent_expr(repl_exprs, cluster);
}


(Expr**, Expr*) cluster_expr_seqs(Expr** exprs, Nat base_offset) {
  cluster = ();
  expr_refs = ();
  for es <- exprs:
    expr_refs_group = ();
    for e <- es:
      offset = nat(base_offset + |cluster| + 1);
      expr_refs_group = (expr_refs_group | expr_ref(offset));
      cluster = cluster & exprs_cluster(e, offset);
    ;
    expr_refs = (expr_refs | expr_refs_group);
  ;
  return (expr_refs, cluster);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Opt[T] opt(Maybe[T]) =
  just(x?)  = (x),
  nothing   = ();

Maybe[T] maybe_unsafe(T* opt) =
  if opt == ()    then nothing
  elif |opt| == 1 then just(only(opt))
                  else undefined;