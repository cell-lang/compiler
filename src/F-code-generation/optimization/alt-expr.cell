Expr* exprs_cluster(Expr expr) = exprs_cluster(expr, 0);

////////////////////////////////////////////////////////////////////////////////

type NonRecExpr     = undefined, LeafObj, FloatLit, Var, OutputIsDefExpr, OutputIsSetExpr;

Expr* exprs_cluster(NonRecExpr expr, Nat offset) = (expr);


Expr* exprs_cluster(<ExprRef, CastExpr>, Nat) = undefined;

////////////////////////////////////////////////////////////////////////////////
///////////////////// Order of subexpression doesn't matter ////////////////////

type RecExprGroup1  = SeqExpr, SetExpr, TupleExpr, TagObjExpr, ClsCall,
                      BuiltinCall, SizeExpr, UnaryPseudoCall, NotExpr, EqExpr,
                      MembExpr, AccExpr, AccTestExpr, RelVarMembTest;


Expr* exprs_cluster(RecExprGroup1 expr, Nat offset) =
  set_expr(ses?)      = subexprs_cluster(isort(ses), offset, set_expr(set($))),
  seq_expr(ses?)      = subexprs_cluster(ses, offset, seq_expr($)),
  tuple_expr(es?)     = exprs_cluster(es, offset, tuple_expr(nonempty($))),
  tag_obj_expr()      = exprs_cluster((expr.tag, expr.obj), offset, tag_obj_expr($(0), $(1))),
  cls_call()          = exprs_cluster(expr.args, offset, cls_call(expr.name, nonempty($))),
  builtin_call()      = exprs_cluster(expr.args, offset, builtin_call(expr.name, nonempty($))),
  size_expr()         = expr_cluster(expr.coll, offset, size_expr($)),
  unary_pseudo_call() = exprs_cluster((expr.target, expr.arg), offset, unary_pseudo_call($(0), $(1))),
  not_expr(e?)        = expr_cluster(e, offset, not_expr($)),
  eq()                = exprs_cluster((expr.left, expr.right), offset, eq($(0), $(1))),
  membership()        = expr_cluster(expr.obj, offset, membership($, expr.type)),
  accessor()          = expr_cluster(expr.expr, offset, accessor($, expr.field)),
  accessor_test()     = expr_cluster(expr.expr, offset, accessor_test($, expr.field)),
  relvar_memb_test()  = maybe_exprs_cluster(expr.args, offset, relvar_memb_test(expr.rel_var, nonempty($)));


// rel_memb_test(rel: Expr, args: Maybe[Expr]+);
Expr* exprs_cluster(RelMembTest expr, Nat offset) =
  maybe_exprs_cluster(
    (just(expr.rel)) & expr.args,
    offset,
    rel_memb_test(value_unsafe($(0)), nonempty(tail(nonempty($))))
  );

// seq_tail_expr(seq: Expr, tail: Expr+);
Expr* exprs_cluster(SeqTailExpr expr, Nat offset) =
  exprs_cluster(
    (expr.seq) & expr.tail,
    offset,
    seq_tail_expr($(0), nonempty(tail(nonempty($))))
  );

// rel_lookup(rel: Expr, set_args: Expr*, unknown_arg_idx: Nat);
Expr* exprs_cluster(RelLookup expr, Nat offset) =
  exprs_cluster(
    (expr.rel) & expr.set_args,
    offset,
    rel_lookup($(0), tail(nonempty($)), expr.unknown_arg_idx)
  );

// relvar_lookup(rel_var: AnyRelVar, set_args: Expr*, unknown_arg_idx: Nat);
Expr* exprs_cluster(RelVarLookup expr, Nat offset) =
  exprs_cluster(
    expr.set_args,
    offset,
    relvar_lookup(expr.rel_var, $, expr.unknown_arg_idx)
  );

// auto_method_call(var: AnyAutoVar?, name: MethodSymbol, args: Expr*);
Expr* exprs_cluster(AutoMethodCall expr, Nat offset) =
  exprs_cluster(
    expr.args,
    offset,
    auto_method_call(var: expr.var if expr.var?, name: expr.name, args: $)
  );

// db_method_call(var: AnyDBVar?, name: MethodSymbol, args: Expr*);
Expr* exprs_cluster(DBMethodCall expr, Nat offset) =
  exprs_cluster(
    expr.args,
    offset,
    db_method_call(var: expr.var if expr.var?, name: expr.name, args: $)
  );

////////////////////////////////////////////////////////////////////////////////
//////////////// Subexpression must be arranged in proper order ////////////////

type RecExprGroup2  = AndExpr, OrExpr, IfExpr;

Expr* exprs_cluster(RecExprGroup2 expr, Nat offset) =
  and_expr()  = exprs_cluster((expr.right, expr.left), offset, and_expr($(1), $(0))),
  or_expr()   = exprs_cluster((expr.right, expr.left), offset, or_expr($(1), $(0))),
  if_expr()   = exprs_cluster((expr.then, expr.else, expr.cond), offset, if_expr($(2), $(0), $(1)));

// map_expr([+(key: Expr, value: Expr, cond: Expr?)]);
Expr* exprs_cluster(MapExpr expr, Nat offset) =
  exprs_cluster(
    [(e.key, e.value, e.cond if e.cond?) : e <- untag(expr)],
    offset,
    map_expr(nonempty([(key: e(0), value: e(1), cond: e(2) if |e| == 3) : e <- $]))
  );


// bin_rel_expr([+(args: (Expr, Expr), cond: Expr?)]);
Expr* exprs_cluster(BinRelExpr expr, Nat offset) =
  exprs_cluster(
    [e.args & (e.cond if e.cond?) : e <- untag(expr)],
    offset,
    bin_rel_expr(nonempty([(args: (e(0), e(1)), cond: e(2) if |e| == 3) : e <- $]))
  );


// tern_rel_expr([+(args: (Expr, Expr, Expr), cond: Expr?)]);
Expr* exprs_cluster(TernRelExpr expr, Nat offset) =
  exprs_cluster(
    [e.args & (e.cond if e.cond?) : e <- untag(expr)],
    offset,
    tern_rel_expr(nonempty([(args: (e(0), e(1), e(2)), cond: e(3) if |e| == 4) : e <- $]))
  );

// seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
Expr* exprs_cluster(SeqCompExpr expr, Nat offset) =
  exprs_cluster(
    (expr.expr, expr.sel_expr if expr.sel_expr?, expr.src_expr),
    offset,
    seq_comp(
      expr:     $(0),
      vars:     expr.vars,
      idx_var:  expr.idx_var if expr.idx_var?,
      src_expr: rev_at($, 0),
      sel_expr: $(1) if expr.sel_expr?
    )
  );

// range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
Expr* exprs_cluster(RangeCompExpr expr, Nat offset) =
  exprs_cluster(
    (expr.expr, expr.sel_expr if expr.sel_expr?, expr.bound_expr),
    offset,
    range_comp(
      expr:       $(0),
      var:        expr.var,
      bound_expr: rev_at($, 0),
      inclusive:  expr.inclusive,
      sel_expr:   $(1) if expr.sel_expr?
    )
  );

////////////////////////////////////////////////////////////////////////////////
/////////////////////////// Expressions with clauses ///////////////////////////

// ex_qual(source: Clause, cond: Expr);
Expr* exprs_cluster(ExQualExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    (expr.cond),
    offset,
    ex_qual($a, only_unsafe($b))
  );

// set_comp(expr: Expr, source: Clause);
Expr* exprs_cluster(SetCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    (expr.expr),
    offset,
    set_comp(only_unsafe($b), $a)
  );


// map_comp(key_expr: Expr, value_expr: Expr, source: Clause);
Expr* exprs_cluster(MapCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    (expr.key_expr, expr.value_expr),
    offset,
    map_comp($b(0), $b(1), $a)
  );


// bin_rel_comp(exprs: (Expr, Expr), source: Clause);
Expr* exprs_cluster(BinRelCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    expr.exprs,
    offset,
    bin_rel_comp(($b(0), $b(1)), $a)
  );


// tern_rel_comp(exprs: (Expr, Expr, Expr), source: Clause);
Expr* exprs_cluster(TernRelCompExpr expr, Nat offset) =
  exprs_cluster(
    expr.source,
    expr.exprs,
    offset,
    tern_rel_comp(($b(0), $b(1), $b(2)), $a)
  );

////////////////////////////////////////////////////////////////////////////////
/////////////////////////// More complex expressions ///////////////////////////

// fn_call(fn_id: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr]);
Expr* exprs_cluster(FnCallExpr expr, Nat offset) {
  fail;
}


// match_expr(exprs: Expr+, cases: (ptrns: Pattern+, expr: Expr)+);
Expr* exprs_cluster(MatchExpr expr, Nat offset) {
  fail;
}


// do_expr(body: Statement+, typed_vars: [StdVar -> NeType]);
Expr* exprs_cluster(DoExpr expr, Nat offset) {
  fail;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr* expr_cluster(Expr expr, Nat offset, (Expr -> Expr) parent_expr) {
  cluster = exprs_cluster(expr, nat(offset+1));
  return (parent_expr(expr_ref(offset))) & cluster;
}


Expr* exprs_cluster(Expr* exprs, Nat base_offset, (Expr* -> Expr) parent_expr) {
  cluster = ();
  expr_refs = ();
  for e <- exprs:
    offset = nat(base_offset + |cluster| + 1);
    expr_refs = (expr_refs | expr_ref(offset));
    cluster = cluster & exprs_cluster(e, offset);
  ;
  return (parent_expr(expr_refs)) & cluster;
}


Expr* maybe_exprs_cluster(Maybe[Expr]* exprs, Nat base_offset, (Maybe[Expr]* -> Expr) parent_expr) {
  expr_refs : Maybe[ExprRef]*;

  cluster = ();
  expr_refs = ();
  for e <- exprs:
    if e != nothing:
      offset = nat(base_offset + |cluster| + 1);
      expr_refs = (expr_refs | just(expr_ref(offset)));
      cluster = cluster & exprs_cluster(value(e), offset);
    else
      expr_refs = (expr_refs | nothing);
    ;
  ;
  return (parent_expr(expr_refs)) & cluster;
}


Expr* subexprs_cluster(SubExpr* subexprs, Nat offset, (SubExpr* -> Expr) parent_expr) {
  fail;
  // fail if not subexprs :: Expr*; ## TEMPORARY
  // return exprs_cluster(subexprs);
}


Expr* exprs_cluster([Expr*] exprs, Nat offset, ([Expr*] -> Expr) parent_expr) {
  fail;
}


Expr* exprs_cluster(Clause cls, Expr+ exprs, Nat offset, (Clause Expr+ -> Expr) parent_expr) {
  fail;
}