implicit program           : Program,
         context           : Context,
         var_aliases       : [[LocVar2]],
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         next_var_gen      : VarGen,
         options           : CompilationOptions
{
  Instr+ opt_eval_code(Expr expr, [<StdVar, FnArg, ImplArg> -> NeType] env, EvalDestVar res_var) {
    exprs_cluster = exprs_cluster(expr);
    rec_exprs = reconstruct_all(exprs_cluster);

    cltr_size = |exprs_cluster|;
    envs = (if i == 0 then env else [] : i < cltr_size);

    let typedefs = program.typedefs, typed_vars = []:
      let rec_exprs = rec_exprs:
        for e @ i <- exprs_cluster:
          for j, vs <- subenvs(e, envs(i)):
            assert envs(j) == [];
            envs(j) := vs;
          ;
        ;
      ;

      types = (expr_type(e, envs(i)) : e @ i <- rec_exprs);
    ;

    return (no_op);
  }
}

implicit program     : Program,
         typedefs    : [TypeName -> NeType],
         context     : Context,
         var_aliases : [[LocVar2]],
         typed_vars  : [StdVar -> NeType],
         rec_exprs   : Expr+
{
  () subenvs(NonRecExpr, [EnvVar -> Type]) = ();
  () subenvs(ExprRef,    [EnvVar -> Type]) = undefined;


  (Nat, [EnvVar -> Type])* subenvs(RecExpr expr, [EnvVar -> Type] env) =
    seq_expr(ses?)      = join((subenvs(se, env) : se <- ses)),
    set_expr(ses?)      = join((subenvs(se, env) : se <- isort(ses))),
    // map_expr(es?)       = join((subenvs((e.key, e.value), (e.cond if e.cond?), env) : e <- isort(es))),
    ## SHOULD BE USING THE ABOVE EXPRESSION, NOT THE ONE BELOW
    map_expr(es?)       = join((
                            subenvs((e.key, e.value), if e.cond? then (e.cond) else (), env) : e <- isort(es)
                          )),
    bin_rel_expr(es?)   |
    // tern_rel_expr(es?)  = join((subenvs(e.args, (e.cond if e.cond?), env) : e <- isort(es))),
    ## DITTO
    tern_rel_expr(es?)  = join((subenvs(e.args, if e.cond? then (e.cond) else (), env) : e <- isort(es))),
    and_expr()          = subenvs(expr.left, env) & subenvs((expr.right), (expr.left), env),
    or_expr()           = subenvs(expr.left, env) & subenvs((expr.right), (not_expr(expr.left)), env),
    if_expr()           = subenvs(expr.cond, env) &
                          subenvs((expr.then), (expr.cond), env) &
                          subenvs((expr.else), (not_expr(expr.cond)), env),
    match_expr()        = match_expr_subenvs(expr, env),
    do_expr()           = (),
    ex_qual()           = subenvs((expr.cond), expr.source, env),
    set_comp()          = subenvs((expr.expr), expr.source, env),
    map_comp()          = subenvs((expr.key_expr, expr.value_expr), expr.source, env),
    bin_rel_comp()      |
    tern_rel_comp()     = subenvs(expr.exprs, expr.source, env),
    seq_comp()          = seq_comp_subenvs(expr, env),
    range_comp()        = range_comp_subenvs(expr, env),
    tuple_expr()        |
    seq_tail_expr()     |
    tag_obj_expr()      |
    fn_call()           |
    cls_call()          |
    builtin_call()      |
    size_expr()         |
    unary_pseudo_call() |
    rel_memb_test()     |
    rel_lookup()        |
    relvar_memb_test()  |
    relvar_lookup()     |
    not_expr()          |
    eq()                |
    membership()        |
    cast_expr()         |
    accessor()          |
    accessor_test()     |
    auto_method_call()  |
    db_method_call()    = simple_subenvs(expr, env);


  (Nat, [EnvVar -> Type])* subenvs(CondExpr expr, [EnvVar -> Type] env) {
    cond_id = expr_ref_id_unsafe(expr.cond);
    env_when_true, env_when_false = refine_env(rec_exprs(cond_id), env);
    expr_id = expr_ref_id_unsafe(expr.expr);
    return ((cond_id, env), (expr_id, env_when_true));
  }


  (Nat, [EnvVar -> Type])* subenvs(Expr+ exprs, Opt[Expr] guard, [EnvVar -> Type] env) {
    if guard != ():
      exprs_env, unused_var = refine_env(rec_exprs(expr_ref_id_unsafe(only(guard))), env);
      envs = ((expr_ref_id_unsafe(only(guard)), env));
    else
      exprs_env = env;
      envs = ();
    ;
    return ((expr_ref_id_unsafe(e), exprs_env) : e <- exprs) & envs;
  }


  (Nat, [EnvVar -> Type])* subenvs(Expr+ exprs, Clause cls, [EnvVar -> Type] env) {
    fail;
  }


  (Nat, [EnvVar -> Type])* match_expr_subenvs(MatchExpr expr, [EnvVar -> Type] env) {
    envs = ((expr_ref_id_unsafe(e), env) : e <- expr.exprs);
    exprs = (rec_exprs(expr_ref_id_unsafe(e)) : e <- expr.exprs);
    for c <- expr.cases:
      case_expr_env = update_env(exprs, c.ptrns, env);
      envs = (envs | (expr_ref_id_unsafe(c.expr), case_expr_env));
    ;
    return envs;
  }


  // seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
  (Nat, [EnvVar -> Type])* seq_comp_subenvs(SeqCompExpr expr, [EnvVar -> Type] env) {
    ## I'M NOT SURE THIS IS SYNCRONIZED WITH seq_comp_expr_type()...
    src_expr = rec_exprs(expr_ref_id_unsafe(expr.src_expr));
    src_elt_type = seq_elem_supertype(expr_type(src_expr, env));
    sel_env = env & asgnm_env_updates(expr.vars, src_elt_type) & [expr.idx_var -> type_nat if expr.idx_var?];
    if expr.sel_expr?:
      sel_expr = rec_exprs(expr_ref_id_unsafe(expr.sel_expr));
      elt_env, unused_var = refine_env(sel_expr, sel_env);
    else
      elt_env = sel_env;
    ;
    return (
      (expr_ref_id_unsafe(expr.src_expr), env),
      (expr_ref_id_unsafe(expr.sel_expr), sel_env) if expr.sel_expr?,
      (expr_ref_id_unsafe(expr.expr),     elt_env)
    );
  }


  // range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);
  (Nat, [EnvVar -> Type])* range_comp_subenvs(RangeCompExpr expr, [EnvVar -> Type] env) {
    ## BAD: HERE WE COULD TAKE ADVANTAGE OF THE KNOWLEDGE ON THE TYPE OF THE UPPER BOUND
    sel_env = update(env, [expr.var -> type_nat]);
    if expr.sel_expr?:
      sel_expr = rec_exprs(expr_ref_id_unsafe(expr.sel_expr));
      elt_env, unused_var = refine_env(sel_expr, sel_env);
    else
      elt_env = sel_env;
    ;
    return (
      (expr_ref_id_unsafe(expr.bound_expr), env),
      (expr_ref_id_unsafe(expr.sel_expr),   sel_env) if expr.sel_expr?,
      (expr_ref_id_unsafe(expr.expr),       elt_env)
    );
  }


  (Nat, [EnvVar -> Type])* simple_subenvs(Expr expr, [EnvVar -> Type] env) {
    subexpr_ids = retrieve_from_nested_exprs(expr, [expr_ref_id_unsafe($)]);
    return ((id, env) : id <- isort(subexpr_ids));
  }
}


Nat expr_ref_id_unsafe(Expr expr) =
  expr_ref(id?) = id,
  _             = undefined;
