implicit program           : Program,
         context           : Context,
         var_aliases       : [[LocVar2]],
         var_subst_map     : [StdVar -> CaptVar],
         cls_var_subst_map : [ClsVar -> CaptClsVar],
         next_var_gen      : VarGen,
         options           : CompilationOptions
{
  Instr+ opt_eval_code(Expr expr, [<StdVar, FnArg, ImplArg> -> NeType] env, EvalDestVar res_var) {
    exprs_cluster = exprs_cluster(expr);
    rec_exprs = reconstruct_all(exprs_cluster);

    cltr_size = |exprs_cluster|;
    envs = (if i == 0 then env else [] : i < cltr_size);
    for e @ i <- exprs_cluster:
      for j, vs <- subenvs(e, envs(i), rec_exprs):
        assert envs(j) == [];
        envs(j) := vs;
      ;
    ;

    let typedefs = program.typedefs, typed_vars = []:
      types = (expr_type(e, envs(i)) : e @ i <- rec_exprs);
    ;

    return (no_op);
  }


  () subenvs(NonRecExpr, [EnvVar -> Type], Expr+) = ();
  () subenvs(ExprRef,    [EnvVar -> Type], Expr+) = undefined;


  (Nat, [EnvVar -> Type])* subenvs(RecExpr expr, [EnvVar -> Type] env, Expr+ rec_exprs) =
    seq_expr(ses?)      = join((subenvs(se, env, rec_exprs) : se <- ses)),
    set_expr(ses?)      = join((subenvs(se, env, rec_exprs) : se <- isort(ses))),
    // map_expr(es?)       = join((subenvs((e.key, e.value), (e.cond if e.cond?), env, rec_exprs) : e <- isort(es))),
    ## SHOULD BE USING THE ABOVE EXPRESSION, NOT THE ONE BELOW
    map_expr(es?)       = join((
                            subenvs((e.key, e.value), if e.cond? then (e.cond) else (), env, rec_exprs)
                            : e <- isort(es)
                          )),
    bin_rel_expr(es?)   |
    // tern_rel_expr(es?)  = join((subenvs(e.args, (e.cond if e.cond?), env, rec_exprs) : e <- isort(es))),
    ## DITTO
    tern_rel_expr(es?)  = join((
                            subenvs(e.args, if e.cond? then (e.cond) else (), env, rec_exprs)
                            : e <- isort(es)
                          )),
    and_expr()          = subenvs(expr.left, env, rec_exprs) &
                          subenvs((expr.right), (expr.left), env, rec_exprs),
    or_expr()           = subenvs(expr.left, env, rec_exprs) &
                          subenvs((expr.right), (not_expr(expr.left)), env, rec_exprs),
    if_expr()           = subenvs(expr.cond, env, rec_exprs) &
                          subenvs((expr.then), (expr.cond), env, rec_exprs) &
                          subenvs((expr.else), (not_expr(expr.cond)), env, rec_exprs),
    match_expr()        = match_expr_subenvs(expr, env, rec_exprs),
    do_expr()           = (),
    ex_qual()           = subenvs((expr.cond), expr.source, env, rec_exprs),
    set_comp()          = subenvs((expr.expr), expr.source, env, rec_exprs),
    map_comp()          = subenvs((expr.key_expr, expr.value_expr), expr.source, env, rec_exprs),
    bin_rel_comp()      |
    tern_rel_comp()     = subenvs(expr.exprs, expr.source, env, rec_exprs),
    seq_comp()          = seq_comp_subenvs(expr, env, rec_exprs),
    range_comp()        = range_comp_subenvs(expr, env, rec_exprs),
    tuple_expr()        |
    seq_tail_expr()     |
    tag_obj_expr()      |
    fn_call()           |
    cls_call()          |
    builtin_call()      |
    size_expr()         |
    unary_pseudo_call() |
    rel_memb_test()     |
    rel_lookup()        |
    relvar_memb_test()  |
    relvar_lookup()     |
    not_expr()          |
    eq()                |
    membership()        |
    cast_expr()         |
    accessor()          |
    accessor_test()     |
    auto_method_call()  |
    db_method_call()    = simple_subenvs(expr, env, rec_exprs);


  (Nat, [EnvVar -> Type])* subenvs(CondExpr expr, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }


  (Nat, [EnvVar -> Type])* subenvs(Expr+ exprs, Opt[Expr] guard, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }


  (Nat, [EnvVar -> Type])* subenvs(Expr+ exprs, Clause cls, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }


  (Nat, [EnvVar -> Type])* match_expr_subenvs(MatchExpr expr, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }


  (Nat, [EnvVar -> Type])* seq_comp_subenvs(SeqCompExpr expr, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }


  (Nat, [EnvVar -> Type])* range_comp_subenvs(RangeCompExpr expr, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }


  (Nat, [EnvVar -> Type])* simple_subenvs(Expr expr, [EnvVar -> Type] env, Expr+ rec_exprs) {
    fail;
  }
}
