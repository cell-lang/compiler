type Symbol         = <+>;
type Int            = <*..*>;
type Float          = <!>;

type Any            = Symbol, Int, Float, Any*, [Any], [Any, Any], [Any, Any, Any], <+>(Any);

type Bool           = true, false;
type True           = true;
type False          = false;

type Nat            = <0..*>;
type NzNat          = <1..*>;

type Bit            = <0..1>;
type Byte           = <0..255>;

type String         = string(Nat*);
type Ascii          = string(<0..127>*);
type Char           = string((Nat));

type Opt[T]         = (), (T);

type Nothing        = nothing;
type Just[T]        = just(T);
type Maybe[T]       = Nothing, Just[T]; //nothing, just(T);

type Success[T]     = success(T);
type Failure[T]     = failure(T);
type Result[R, E]   = success(R), failure(E);

////////////////////////////////////////////////////////////////////////////////

protocol Ord:
  (_<_) : Ord, Ord -> Bool;

////////////////////////////////////////////////////////////////////////////////

Int (-_) (Int n) = _neg_(n);

Int (_+_) (Int a, Int b) = _add_(a, b);
Int (_-_) (Int a, Int b) = _sub_(a, b);
Int (_*_) (Int a, Int b) = _mult_(a, b);
Int (_/_) (Int a, Int b) = _div_(a, b);

Int mod(Int a, Int b) = _mod_(a, b);

Bool (_<_)  (Int a, Int b) = _lt_(a, b);
Bool (_<=_) (Int a, Int b) = _le_(a, b);
Bool (_>_)  (Int a, Int b) = _lt_(b, a);
Bool (_>=_) (Int a, Int b) = _le_(b, a);

////////////////////////////////////////////////////////////////////////////////

Int bwand(Int a, Int b) = _and_(a, b);
Int bwor(Int a, Int b)  = _or_(a, b);
Int xor(Int a, Int b)   = _xor_(a, b);

////////////////////////////////////////////////////////////////////////////////

Nat nat(Int n) = if n :: Nat then n else undefined;

Nat abs(Int n) = if n :: Nat then n else nat(-n);

Int sum(Int* ns) {
  res = 0;
  for n <- ns:
    res = res + n;
  ;
  return res;
}

//////////////////////////////////////////////////////////////////////////////

Ord min(Ord a, Ord b) = if a < b then a else b;
Ord max(Ord a, Ord b) = if a < b then b else a;

Ord min([+Ord] ns) = min(isort(ns));

Ord min(Ord+ ns) {
  min = ns(0);
  for n <- ns:
    min = n if n < min;
  ;
  return min;
}

Ord max([+Ord] ns) = max(isort(ns));

Ord max(Ord+ ns) {
  max = ns(0);
  for n <- ns:
    max = n if max < n;
  ;
  return max;
}

//////////////////////////////////////////////////////////////////////////////

Float (-_) (Float x) = _fneg_(x);

Float (_+_) (Float x, Float y) = _fadd_(x, y);
Float (_+_) (Int   x, Float y) = _fadd_(_float_(x), y);
Float (_+_) (Float x, Int   y) = _fadd_(x, _float_(y));

Float (_-_) (Float x, Float y) = _fsub_(x, y);
Float (_-_) (Int   x, Float y) = _fsub_(_float_(x), y);
Float (_-_) (Float x, Int   y) = _fsub_(x, _float_(y));

Float (_*_) (Float x, Float y) = _fmult_(x, y);
Float (_*_) (Int   x, Float y) = _fmult_(_float_(x), y);
Float (_*_) (Float x, Int   y) = _fmult_(x, _float_(y));

Float (_/_) (Float x, Float y) = _fdiv_(x, y);
Float (_/_) (Int   x, Float y) = _fdiv_(_float_(x), y);
Float (_/_) (Float x, Int   y) = _fdiv_(x, _float_(y));

Bool (_<_)  (Float x, Float y) = _flt_(x, y);
Bool (_<_)  (Int   x, Float y) = _flt_(_float_(x), y);
Bool (_<_)  (Float x, Int   y) = _flt_(x, _float_(y));

Bool (_<=_) (Float x, Float y) = _fle_(x, y);
Bool (_<=_) (Int   x, Float y) = _fle_(_float_(x), y);
Bool (_<=_) (Float x, Int   y) = _fle_(x, _float_(y));

Bool (_>_)  (Float x, Float y) = _flt_(y, x);
Bool (_>_)  (Int   x, Float y) = _flt_(y, _float_(x));
Bool (_>_)  (Float x, Int   y) = _flt_(_float_(y), x);

Bool (_>=_) (Float x, Float y) = _fle_(y, x);
Bool (_>=_) (Int   x, Float y) = _fle_(y, _float_(x));
Bool (_>=_) (Float x, Int   y) = _fle_(_float_(y), x);

Float (_^_) (Float x, Float y) = _fexp_(x, y);
Float (_^_) (Int   x, Float y) = _fexp_(_float_(x), y);
Float (_^_) (Float x, Int   y) = _fexp_(x, _float_(y));
Float (_^_) (Int   x, Int   y) = _fexp_(_float_(x), _float_(y));

Float sqrt(Float x) = _fsqrt_(x);
Float sqrt(Int   x) = _fsqrt_(_float_(x));

////////////////////////////////////////////////////////////////////////////////

Bool all(Bool* s)  = not (e <~ s : not e);
Bool none(Bool* s) = not (e <~ s : e);
Bool any(Bool* s)  = (e <~ s : e);

////////////////////////////////////////////////////////////////////////////////

<0..1> bit(Bool b) = if b then 1 else 0;

//////////////////////////////////////////////////////////////////////////////

Nothing nothing = :nothing;

Just[T] just(T x) = :just(x);

T value(Just[T]) =
  just(x?)  = x;

T value_unsafe(Maybe[T]) =
  just(x?)  = x,
  _         = undefined;

Maybe[T] maybe(T x, Bool cond) = if cond then :just(x) else nothing;

T* values(Maybe[T]* maybe_seq) = (value(maybe_value) : maybe_value <- maybe_seq, maybe_value != nothing);

// [T] values([Maybe[T]] maybe_seq) = [value(maybe_value) : maybe_value <- maybe_seq, maybe_value != nothing];

Maybe[B] apply(Maybe[A] m, (A -> B) f) =
  just(x?)  = just(f(x)),
  nothing   = nothing;

Opt[T] opt(Maybe[T]) =
  just(x?)  = (x),
  nothing   = ();

Maybe[T] maybe(Opt[T] opt) = if opt != () then just(only(opt)) else nothing;

Maybe[T] maybe_unsafe(T* opt) =
  if opt == ()    then nothing
  elif |opt| == 1 then just(only(opt))
                  else undefined;

////////////////////////////////////////////////////////////////////////////////

True  succeeded(Success[T]) = true;
False succeeded(Failure[T]) = false;

False failed(Success[T]) = false;
True  failed(Failure[T]) = true;

T result(Success[T] r) = untag(r);

T error(Failure[T] r) = untag(r);

////////////////////////////////////////////////////////////////////////////////

(A, B)* zip(A* s1, B* s2) {
  assert |s1| == |s2|;
  return ((e1, s2(i)) : e1 @ i <- s1);
}

(A, B, C)* zip(A* s1, B* s2, C* s3) {
  assert |s1| == |s2| and |s2| == |s3|;
  return ((e1, s2(i), s3(i)) : e1 @ i <- s1);
}

(A, B, C, D)* zip(A* s1, B* s2, C* s3, D* s4) {
  assert |s1| == |s2| and |s2| == |s3| and |s3| == |s4|;
  return ((e1, s2(i), s3(i), s4(i)) : e1 @ i <- s1);
}

(A*, B*) unzip((A, B)* ts) = ((t(0) : t <- ts), (t(1) : t <- ts));

(A*, B*, C*) unzip3((A, B, C)* ts) = ((t(0) : t <- ts), (t(1) : t <- ts), (t(2) : t <- ts));

////////////////////////////////////////////////////////////////////////////////

T* (_&_)(T* s1, T* s2) = _cat_(s1, s2);

T* join(T** seqs) {
  res = ();
  for s <- seqs:
    res = _cat_(res, s);
  ;
  return res;
}

T* reverse(T* seq) = _rev_(seq);

T* take(T* seq, Int count) = if |seq| > count then _slice_(seq, 0, count) else seq;
T* drop(T* seq, Int count) = if |seq| > count then _slice_(seq, count, |seq| - count) else ();

T* slice(T* seq, Int first, Int count) = _slice_(seq, first, count);

T* (_*_)(Nat count, T* seq) = {
  l = |seq|;
  res = ();
  for i < count:
    for x <- seq:
      res = res & (x);
    ;
  ;
  return res;
};

T* intermix(T* seq, T obj) = join(((obj if i != 0, e) : e @ i <- seq));

T only((T)) = (x?) = x;

T+ insert(T* seq, Nat idx, T elt) {
  assert idx >= 0 and idx <= |seq|;
  return (if i == idx then elt elif i < idx then seq(i) else seq(i-1) : i <= |seq|);
}

////////////////////////////////////////////////////////////////////////////////

[T] union([T] s1, [T] s2) = [x : x <- s1 | x <- s2];

[T] intersection([T] s1, [T] s2)  = [e : e <- s1, s2(e)];
[A] difference([A] s1, [B] s2)    = [e : e <- s1, not s2(e)];

[]   (_&_)([],      [])       = [];
[+T] (_&_)([+T] s,  [])       = s;
[+T] (_&_)([],      [+T] s)   = s;
[+T] (_&_)([+T] s1, [+T] s2)  = [x : x <- s1 | x <- s2];

[A] (_-_)([A] s1, [B] s2) = difference(s1, s2);

Bool disjoint([Any] s1, [Any] s2) = not (e <- s1 : s2(e));
Bool subset([Any] s1, [Any] s2)   = not (e <- s1 : not s2(e));

[T] union([[T]] sets) = [x : s <- sets, x <- s];

// [T] union([T]* sets) = [x : s <~ sets, x <- s];

T only([T] set) {
  seq = _isort_(set);
  fail if |seq| != 1;
  return seq(0);
}

([A], [B]) unzip([(A, B)] ps) = ([p(0) : p <- ps], [p(1) : p <- ps]);

([A], [B], [C]) unzip3([(A, B, C)] ts) = ([t(0) : t <- ts], [t(1) : t <- ts], [t(2) : t <- ts]);

() isort([]) = ();

T+ isort([+T] s) {
  seq = _isort_(s);
  fail if seq == ();
  return seq;
}

////////////////////////////////////////////////////////////////////////////////

[+A -> B] (_&_)([],             [+A -> B] map)  = map;
[+A -> B] (_&_)([+A -> B] map,  [])             = map;
[+A -> B] (_&_)([+A -> B] map1, [+A -> B] map2) = [k -> v : k, v <- map1 | k, v <- map2];

[A -> B] merge([[A -> B]] maps) = [k -> v : m <- maps, k, v <- m];
[A -> B] merge([A -> B]* maps)  = [k -> v : m <~ maps, k, v <- m];

(A, B)+ isort([+A, B] rel) {
  seq = _isort_([(a, b) : a, b <- rel]);
  fail if seq == ();
  return seq;
}

////////////////////////////////////////////////////////////////////////////////

(A, B, C)+ isort([+A, B, C] rel) {
  seq = _isort_([(a, b, c) : a, b, c <- rel]);
  fail if seq == ();
  return seq;
}

////////////////////////////////////////////////////////////////////////////////

T untag(<+>(T)) =
  t?(v?) = v;

///////////////////////////////////////////////////////////////////////////////

Byte ascii_null              = 0;
Byte ascii_tab               = 9;
Byte ascii_newline           = 10;
Byte ascii_carriage_return   = 13;

Byte ascii_space             = 32;
Byte ascii_exclamation_mark  = 33;
Byte ascii_double_quotes     = 34; // quotation marks, quote, double quote
Byte ascii_hash              = 35;
Byte ascii_dollar            = 36;
Byte ascii_percent           = 37; // percent sign
Byte ascii_ampersand         = 38;
Byte ascii_single_quote      = 39;
Byte ascii_left_parenthesis  = 40;
Byte ascii_right_parenthesis = 41;
Byte ascii_asterisk          = 42;
Byte ascii_plus              = 43;
Byte ascii_comma             = 44;
Byte ascii_minus             = 45; // dash, hyphen
Byte ascii_dot               = 46; // period, point, decimal point
Byte ascii_slash             = 47;
Byte ascii_0                 = 48;
Byte ascii_1                 = 49;
Byte ascii_2                 = 50;
Byte ascii_3                 = 51;
Byte ascii_4                 = 52;
Byte ascii_5                 = 53;
Byte ascii_6                 = 54;
Byte ascii_7                 = 55;
Byte ascii_8                 = 56;
Byte ascii_9                 = 57;
Byte ascii_colon             = 58;
Byte ascii_semicolon         = 59;
Byte ascii_lower             = 60; // less than, bra
Byte ascii_equals            = 61;
Byte ascii_greater           = 62; // greater than, ket
Byte ascii_question_mark     = 63;
Byte ascii_at                = 64;
Byte ascii_upper_a           = 65;
Byte ascii_upper_b           = 66;
Byte ascii_upper_c           = 67;
Byte ascii_upper_d           = 68;
Byte ascii_upper_e           = 69;
Byte ascii_upper_f           = 70;
Byte ascii_upper_g           = 71;
Byte ascii_upper_h           = 72;
Byte ascii_upper_i           = 73;
Byte ascii_upper_j           = 74;
Byte ascii_upper_k           = 75;
Byte ascii_upper_l           = 76;
Byte ascii_upper_m           = 77;
Byte ascii_upper_n           = 78;
Byte ascii_upper_o           = 79;
Byte ascii_upper_p           = 80;
Byte ascii_upper_q           = 81;
Byte ascii_upper_r           = 82;
Byte ascii_upper_s           = 83;
Byte ascii_upper_t           = 84;
Byte ascii_upper_u           = 85;
Byte ascii_upper_v           = 86;
Byte ascii_upper_w           = 87;
Byte ascii_upper_x           = 88;
Byte ascii_upper_y           = 89;
Byte ascii_upper_z           = 90;
Byte ascii_left_bracket      = 91;
Byte ascii_backslash         = 92;
Byte ascii_right_bracket     = 93;
Byte ascii_circumflex        = 94;
Byte ascii_underscore        = 95;
Byte ascii_backquote         = 96;
Byte ascii_lower_a           = 97;
Byte ascii_lower_b           = 98;
Byte ascii_lower_c           = 99;
Byte ascii_lower_d           = 100;
Byte ascii_lower_e           = 101;
Byte ascii_lower_f           = 102;
Byte ascii_lower_g           = 103;
Byte ascii_lower_h           = 104;
Byte ascii_lower_i           = 105;
Byte ascii_lower_j           = 106;
Byte ascii_lower_k           = 107;
Byte ascii_lower_l           = 108;
Byte ascii_lower_m           = 109;
Byte ascii_lower_n           = 110;
Byte ascii_lower_o           = 111;
Byte ascii_lower_p           = 112;
Byte ascii_lower_q           = 113;
Byte ascii_lower_r           = 114;
Byte ascii_lower_s           = 115;
Byte ascii_lower_t           = 116;
Byte ascii_lower_u           = 117;
Byte ascii_lower_v           = 118;
Byte ascii_lower_w           = 119;
Byte ascii_lower_x           = 120;
Byte ascii_lower_y           = 121;
Byte ascii_lower_z           = 122;
Byte ascii_left_brace        = 123;
Byte ascii_bar               = 124; // vertical bar, pipe
Byte ascii_right_brace       = 125;
Byte ascii_tilde             = 126;

Bool is_digit(Nat ch) = ch >= ascii_0 and ch <= ascii_9;
Bool is_lower(Nat ch) = ch >= ascii_lower_a and ch <= ascii_lower_z;
Bool is_upper(Nat ch) = ch >= ascii_upper_a and ch <= ascii_upper_z;

Bool is_space(Int ch) = ch == ascii_space or
                        ch == ascii_tab or
                        ch == ascii_newline or
                        ch == ascii_carriage_return;

Nat lower(Nat ch) = if is_upper(ch) then nat(ch + 32) else ch;
Nat upper(Nat ch) = if is_lower(ch) then nat(ch - 32) else ch;

////////////////////////////////////////////////////////////////////////////////

String string(Nat* chs) = :string(chs);

Nat* chars(String str)  = string(chs?) = chs;

Nat length(String s)    = |chars(s)|;

Nat (_[_]) (String str, Int idx) = chars(str)(idx);

String (_&_) (String s1, String s2)   = string(chars(s1) & chars(s2));
String append(String* ss)             = string(join((chars(s) : s <- ss)));
String append(String* ss, String sep) = string(join(intermix((chars(s) : s <- ss), chars(sep))));
String reverse(String s)              = string(reverse(chars(s)));
String substr(String s, Int n, Int m) = string(_slice_(chars(s), n, m));

String take(String s, Int count) = string(take(chars(s), count));
String drop(String s, Int count) = string(drop(chars(s), count));

String (_*_) (Nat len, String str)    = string(len * chars(str));

Bool (_<_) (String str1, String str2) = {
  chs1 = chars(str1);
  chs2 = chars(str2);

  len1 = |chs1|;
  len2 = |chs2|;
  min_len = min(len1, len2);

  for i < min_len:
    ch1 = chs1(i);
    ch2 = chs2(i);
    return true  if ch1 < ch2;
    return false if ch1 > ch2;
  ;

  return len1 < len2;
};
