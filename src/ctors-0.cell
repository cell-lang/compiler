ParType parenthesis           = :parenthesis;
ParType bracket               = :bracket;
ParType brace                 = :brace;

LangSymb left(ParType p)     	= :left(p);
LangSymb right(ParType p)    	= :right(p);

LangSymb left_parenthesis    	= left(parenthesis);
LangSymb right_parenthesis   	= right(parenthesis);
LangSymb left_bracket        	= left(bracket);
LangSymb right_bracket       	= right(bracket);
LangSymb left_brace          	= left(brace);
LangSymb right_brace         	= right(brace);
LangSymb comma               	= :comma;
LangSymb semicolon           	= :semicolon;
LangSymb question_mark       	= :question_mark;
LangSymb equals              	= :equals;
LangSymb pipe                	= :pipe;
LangSymb colon               	= :colon;
LangSymb underscore          	= :underscore;
LangSymb circumflex          	= :circumflex;
LangSymb dot                 	= :dot;
LangSymb tilde               	= :tilde;
LangSymb at                  	= :at;
LangSymb ampersand           	= :ampersand;
LangSymb bang                	= :bang;
LangSymb hash                	= :hash;
LangSymb dollar              	= :dollar;
LangSymb lower               	= :lower;
LangSymb greater             	= :greater;
LangSymb plus                	= :plus;
LangSymb minus               	= :minus;
LangSymb asterisk            	= :asterisk;
LangSymb slash               	= :slash;
LangSymb double_dot          	= :double_dot;
LangSymb double_equals       	= :double_equals;
LangSymb not_equal           	= :not_equal;
LangSymb lower_eq            	= :lower_eq;
LangSymb greater_eq          	= :greater_eq;
LangSymb assign              	= :assign;
LangSymb try_assign          	= :try_assign;
LangSymb right_arrow         	= :right_arrow;
LangSymb double_right_arrow  	= :double_right_arrow;
LangSymb left_arrow          	= :left_arrow;
LangSymb wavy_left_arrow     	= :wavy_left_arrow;
LangSymb triple_dot          	= :triple_dot;
LangSymb double_colon        	= :double_colon;
LangSymb double_pipe         	= :double_pipe;
LangSymb double_lower        	= :double_lower;
LangSymb double_greater      	= :double_greater;

PlainToken lowercase_id(Symbol s)       = :lowercase_id(s);
PlainToken mixedcase_id(Symbol s)       = :mixedcase_id(s);
PlainToken uppercase_id(Symbol s)       = :uppercase_id(s);
PlainToken qualified_symbol(Symbol s)   = :qualified_symbol(s);
PlainToken operator(Operator op)        = :operator(op);
PlainToken builtin(BuiltIn b)           = :builtin(b);
PlainToken qual_var(Nat n)              = :qual_var(n);
PlainToken pref_lowercase_id(Symbol s)  = :pref_lowercase_id(s);
PlainToken nanoseconds(NzNat n)         = :nanoseconds(n);

AnnotatedToken annotated_token(PlainToken t, NzNat l, NzNat c, NzNat len, Nat i) =
  annotated_token(token: t, line: l, col: c, length: len, index: i);

TokenMatchingRule lowercase_id      = :lowercase_id;
TokenMatchingRule mixedcase_id      = :mixedcase_id;
TokenMatchingRule uppercase_id      = :uppercase_id;
TokenMatchingRule qualified_symbol  = :qualified_symbol;
// TokenMatchingRule integer           = :integer; ## Conflicts with "IntType integer = :integer;" int utils_2_ctors.h
TokenMatchingRule float             = :float;
TokenMatchingRule string            = :string;
TokenMatchingRule unary_operator    = :unary_operator;
TokenMatchingRule binary_operator   = :binary_operator;
TokenMatchingRule builtin           = :builtin;
TokenMatchingRule qual_var          = :qual_var;
TokenMatchingRule pref_lowercase_id = :pref_lowercase_id;
TokenMatchingRule time_span         = :time_span;
TokenMatchingRule keyword(Symbol a) = :keyword(a);

ParsingRule empty_rule                                                = :empty_rule;
ParsingRule atomic_rule(TokenMatchingRule r)                          = :atomic_rule(r);
ParsingRule optional_rule(ParsingRule r)                              = :optional_rule(r);
ParsingRule maybe_optional_rule(ParsingRule r, Bool optional)         = if optional then optional_rule(r) else r;
ParsingRule optional_rule_seq(ParsingRule+ rs)                        = :optional_rule(:rule_seq(rs));
ParsingRule rule_seq(ParsingRule+ rs)                                 = :rule_seq(rs);
ParsingRule rep_rule(ParsingRule r)                                   = rep_rule(r, 0, empty_rule, false);
ParsingRule rep_rule(ParsingRule r, ParsingRule s)                    = rep_rule(r, 0, s, false);
ParsingRule rep_rule(ParsingRule r, Nat c, ParsingRule s, Bool ss)    = rep_rule(rule: r, min_count: c, separator: s, save_sep: ss);
ParsingRule rep_rule(ParsingRule r, Bool ne)                          = rep_rule(r, bit(ne), empty_rule, false);
ParsingRule rep_rule(ParsingRule r, ParsingRule s, Bool ne, Bool ss)  = rep_rule(r, bit(ne), s, ss);
ParsingRule rep_rule_nonempty(ParsingRule r)                          = rep_rule(r, true);
ParsingRule rule_anon_choice(ParsingRule+ rs)                         = :rule_choice(((rule: r) : r <- rs));
ParsingRule rule_choice((Symbol, ParsingRule)+ rs)                    = :rule_choice(((name: n, rule: r) : n, r <- rs));
ParsingRule rule_neg(ParsingRule r)                                   = :rule_neg(r);
ParsingRule block_rule(ParType pt, ParsingRule r)                     = rule_seq((atomic_rule(left(pt)), r, atomic_rule(right(pt))));
ParsingRule rule_ref(Symbol a)                                        = :rule_ref(a); ## MAKE IT MORE SPECIFIC

RuleMatch null_match                                = :null_match;
RuleMatch atomic_rule_match(AnnotatedToken t)       = :atomic_rule_match(t);
RuleMatch rule_seq_match(RuleMatch+ rms)            = :rule_seq_match(rms);
RuleMatch rep_rule_match(RuleMatch* rms)            = :rep_rule_match(rms);
RuleMatch rule_choice_match(Symbol n, RuleMatch m)  = rule_choice_match(name: n, match: m);
