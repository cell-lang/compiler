CompiledPrg optimize_array_init(CompiledPrg prg) =
  compiled_prg(
    typedefs:       prg.typedefs,
    opt_reprs:      prg.opt_reprs,
    bool_procs:     prg.bool_procs,
    procs:          [optimize_array_init(pd) : pd <- prg.procs],
    react_blocks:   prg.react_blocks,
    static_blocks:  [optimize_array_init(b)  : b <- prg.static_blocks],
    int_seqs:       prg.int_seqs
  );


ObjProcDef optimize_array_init(ObjProcDef pd) =
  obj_proc_def(
    name:           pd.name,
    args:           pd.args,
    cls_args:       pd.cls_args,
    impl_args:      pd.impl_args,
    ret_val_repr:   pd.ret_val_repr,
    type:           pd.type,
    loc_auto_vars:  pd.loc_auto_vars,
    loc_db_vars:    pd.loc_db_vars,
    body:           nonempty(optimize_array_init(pd.body)),
    cached:         pd.cached
  );


StaticBlock optimize_array_init(StaticBlock block) =
  static_block(
    name:                     block.name,
    links:                    block.links,
    state_vars:               block.state_vars,
    nested_blocks:            block.nested_blocks,
    value_stores:             block.value_stores,
    tables:                   block.tables,
    foreign_keys:             block.foreign_keys,
    init_code:                block.init_code,
    cleanup_code:             block.cleanup_code,
    copy_state_code:          block.copy_state_code,
    set_state_code:           block.set_state_code,
    foreign_keys_check_code:  block.foreign_keys_check_code,
    methods:                  [id -> optimize_array_init(m) : id, m <- block.methods],
    accessors:                block.accessors,
    updates:                  [id -> compiled_update(u.args_vars, optimize_array_init(u.body)) : id, u <- block.updates],
    msg_memb_pred:            block.msg_memb_pred
  );


OptCompMethod optimize_array_init(OptCompMethod method) =
  opt_comp_method(
    args:             method.args,
    args_types:       method.args_types,
    args_memb_preds:  method.args_memb_preds,
    ret_type:         method.ret_type,
    ret_val_repr:     method.ret_val_repr,
    body:             optimize_array_init(method.body)
  );


////////////////////////////////////////////////////////////////////////////////

Instr* optimize_array_init(Instr* code) {
  opt_code = ();
  pending = [];
  for instr @ i <- code:
    // If the instruction (which can be a composite one) requires the instantiation
    // of the sequence object, we do that before anything else
    ## BUG BUG BUG: INSTANTIATION COULD BE FORCED BY ANY SORT OF JUMP
    vars = pending_vars_used(instr, pending);
    for v <- isort(vars):
      opt_code = (opt_code | inst_instr(v));
      pending = remove(pending, v);
    ;
    // If the instruction is a sequence instantiatiation that can be
    // optimized we rewrite it and update the list of pending variables
    instrs, pending = rewrite_if_seq_inst_instr(instr, pending);
    if instrs != ():
      opt_code = opt_code & instrs;
    else
      // Otherwise we just rewrite the instructions and
      // expressions that can be optimized
      rw_instr = rewrite_seq_ops(instr, pending);
      opt_code = (opt_code | rw_instr);
    ;
  ;
  // Before leaving this block of code, we instantiate all pending variables
  ## THIS SHOULD BE DONE ONLY IF IT'S STRICTLY NECESSARY
  ## OR ARE UNNECESSARY INSTANTIATIONS REMOVED BY OTHER OPTIMIZATION STAGES?
  return opt_code & (inst_instr(v) : v <- _isort_(pending));

  //////////////////////////////////////////////////////////////////////////////

  Instr inst_instr(StdVar var) {
    var_id = bare_id(var);
    array_var = shadow_array_var(var_id, :object);
    array_size_var = shadow_array_size_var(var_id);
    return mk_seq(var, array_var, array_size_var);
  }

  //////////////////////////////////////////////////////////////////////////////

  (Instr*, [StdVar]) rewrite_if_seq_inst_instr(Instr instr, [StdVar] pending) {
    if instr :: <set_var(var: StdVar, value: empty_seq)>:
      var_id = bare_id(instr.var);
      instrs = (
        set_ivar32(shadow_array_size_var(var_id), 0),
        array_alloc(shadow_array_var(var_id, :object), 0)
      );
      return (instrs, insert(pending, instr.var));
    ;

    if instr :: <set_rc_var(var: StdVar, value: mk_seq_from_array(array: avar(id: Nat, repr: LowLevelEltRepr), size: Int32Expr))>:
      var_id = bare_id(instr.var);
      instrs = (
        set_ivar32(shadow_array_size_var(var_id), instr.value.size),
        array_set_var(shadow_array_var(var_id, instr.value.array.repr), instr.value.array)
      );
      return (instrs, insert(pending, instr.var));
    ;

    return ((), pending);
  }

  //////////////////////////////////////////////////////////////////////////////

  [StdVar] pending_vars_used(Instr instr, [StdVar] pending) {
    if instr :: <set_rc_var(var: StdVar, value: append_to_seq(seq: StdVar, new_elem: AtomicExpr))>:
      if instr.var == instr.value.seq and pending(instr.var):
        return pending_vars_used(instr.value.new_elem, pending);
      ;
    ;
    return search_nested(instr, pending_vars_used($, pending), pending_vars_used($, pending));
  }


  [StdVar] pending_vars_used(AnyTypeExpr expr, [StdVar] pending) =
    var()         = [expr if pending(expr)],
    at()          = {if not pending(expr.seq) then pending_vars_used(expr.seq, pending) else []} &
                    pending_vars_used(expr.idx, pending),
    get_size(e?)  = if not pending(e) then pending_vars_used(e, pending) else [],
    _             = search_nested(expr, pending_vars_used($, pending));

  //////////////////////////////////////////////////////////////////////////////

  Instr rewrite_seq_ops(Instr instr, [StdVar] pending) {
    if instr :: <set_rc_var(var: StdVar, value: append_to_seq(seq: StdVar, new_elem: AtomicExpr))>:
      if instr.var == instr.value.seq and pending(instr.var):
        // set_rc_var(var: var(ys), value: append_to_seq(seq: var(ys), new_elem: var(x)))
        // array_append(
        //   array_var: shadow_array_var(id: ys, repr: object),
        //   size_var:  shadow_array_size_var(ys),
        //   value:     var(x)
        // )
        var_id = bare_id(instr.var);
        return array_append(
          shadow_array_var(var_id, :object),
          shadow_array_size_var(var_id),
          instr.value.new_elem
        );
      ;
    ;
    return rewrite_nested(instr, rewrite_seq_ops($, pending), rewrite_seq_ops($, pending));
  }


  AnyTypeExpr rewrite_seq_ops(AnyTypeExpr expr, [StdVar] pending) = expr;
    // at(seq: ObjExpr, idx: IntExpr),
    // get_size(ObjExpr),
}
