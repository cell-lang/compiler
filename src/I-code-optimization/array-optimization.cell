CompiledPrg optimize_array_init(CompiledPrg prg) =
  compiled_prg(
    typedefs:       prg.typedefs,
    opt_reprs:      prg.opt_reprs,
    bool_procs:     prg.bool_procs,
    procs:          [optimize_array_init(pd) : pd <- prg.procs],
    react_blocks:   prg.react_blocks,
    static_blocks:  [optimize_array_init(b)  : b <- prg.static_blocks],
    int_seqs:       prg.int_seqs
  );


ObjProcDef optimize_array_init(ObjProcDef pd) =
  obj_proc_def(
    name:           pd.name,
    args:           pd.args,
    cls_args:       pd.cls_args,
    impl_args:      pd.impl_args,
    ret_val_repr:   pd.ret_val_repr,
    type:           pd.type,
    loc_auto_vars:  pd.loc_auto_vars,
    loc_db_vars:    pd.loc_db_vars,
    body:           nonempty(optimize_array_init(pd.body)),
    cached:         pd.cached
  );


StaticBlock optimize_array_init(StaticBlock block) =
  static_block(
    name:                     block.name,
    links:                    block.links,
    state_vars:               block.state_vars,
    nested_blocks:            block.nested_blocks,
    value_stores:             block.value_stores,
    tables:                   block.tables,
    foreign_keys:             block.foreign_keys,
    init_code:                block.init_code,
    cleanup_code:             block.cleanup_code,
    copy_state_code:          block.copy_state_code,
    set_state_code:           block.set_state_code,
    foreign_keys_check_code:  block.foreign_keys_check_code,
    methods:                  [id -> optimize_array_init(m) : id, m <- block.methods],
    accessors:                block.accessors,
    updates:                  [id -> compiled_update(u.args_vars, optimize_array_init(u.body)) : id, u <- block.updates],
    msg_memb_pred:            block.msg_memb_pred
  );


OptCompMethod optimize_array_init(OptCompMethod method) =
  opt_comp_method(
    args:             method.args,
    args_types:       method.args_types,
    args_memb_preds:  method.args_memb_preds,
    ret_type:         method.ret_type,
    ret_val_repr:     method.ret_val_repr,
    body:             optimize_array_init(method.body)
  );


////////////////////////////////////////////////////////////////////////////////

Instr* optimize_array_init(Instr* code) {
  pending : [StdVar -> LowLevelEltRepr];

  opt_code = ();
  pending = [];
  for instr @ i <- code:
    // If the instruction (which can be a composite one) requires the instantiation
    // of the sequence object, either because of an operation that cannot be mapped
    // to an array or because of a unstructered jump, we do that before anything else
    vars = required_insts(instr, pending);
    for v <- isort(vars):
      opt_code = (opt_code | inst_instr(v, pending(v)));
      pending = drop(pending, v);
    ;
    // If the instruction is a sequence instantiatiation that can be
    // optimized we rewrite it and update the list of pending variables
    instrs, pending = rewrite_if_seq_inst_instr(instr, pending);
    if instrs != ():
      opt_code = opt_code & instrs;
    else
      // Otherwise we just rewrite the instructions and
      // expressions that can be optimized
      rw_instr = rewrite_seq_ops(instr, pending);
      opt_code = (opt_code | rw_instr);
    ;
  ;
  // Before leaving this block of code, we instantiate all pending variables
  ## THIS SHOULD BE DONE ONLY IF IT'S STRICTLY NECESSARY
  ## OR ARE UNNECESSARY INSTANTIATIONS REMOVED BY OTHER OPTIMIZATION STAGES?
  return opt_code & (inst_instr(v, pending(v)) : v <- _isort_(keys(pending)));

  //////////////////////////////////////////////////////////////////////////////

  Instr inst_instr(StdVar var, LowLevelEltRepr repr) {
    var_id = bare_id(var);
    array_var = shadow_array_var(var_id, repr);
    array_size_var = shadow_array_size_var(var_id);
    return mk_seq(var, array_var, array_size_var);
  }

  //////////////////////////////////////////////////////////////////////////////

  (Instr*, [StdVar -> LowLevelEltRepr]) rewrite_if_seq_inst_instr(Instr instr, [StdVar -> LowLevelEltRepr] pending) {
    if instr :: <set_var(var: StdVar, value: empty_seq)>:
      var_id = bare_id(instr.var);
      instrs = (
        set_ivar32(shadow_array_size_var(var_id), 0),
        array_alloc(shadow_array_var(var_id, :object), 0)
      );
      return (instrs, put(pending, instr.var, :object));
    ;

    if instr :: <set_rc_var(var: StdVar, value: mk_seq_from_array(array: avar(id: Nat, repr: LowLevelEltRepr), size: Int32Expr))>:
      var_id = bare_id(instr.var);
      instrs = (
        set_ivar32(shadow_array_size_var(var_id), instr.value.size),
        array_set_var(shadow_array_var(var_id, instr.value.array.repr), instr.value.array)
      );
      return (instrs, put(pending, instr.var, instr.value.array.repr));
    ;

    return ((), pending);
  }

  //////////////////////////////////////////////////////////////////////////////

  [StdVar] required_insts(Instr instr, [StdVar -> LowLevelEltRepr] pending) {
    outcomes = code_outcomes(instr);
    return if outcomes(:breaks_loop) or outcomes(:exits_block)
      then keys(pending)
      else pending_vars_used(instr, pending);
  }


  [StdVar] pending_vars_used(Instr instr, [StdVar -> LowLevelEltRepr] pending) {
    if instr :: <set_rc_var(var: StdVar, value: append_to_seq(seq: StdVar, new_elem: AtomicExpr))>:
      if instr.var == instr.value.seq and pending(instr.var, *):
        return pending_vars_used(instr.value.new_elem, pending);
      ;
    ;
    return search_nested(instr, pending_vars_used($, pending), pending_vars_used($, pending));
  }


  [StdVar] pending_vars_used(AnyTypeExpr expr, [StdVar -> LowLevelEltRepr] pending) =
    var()         = [expr if pending(expr, *)],
    at()          = {if not pending(expr.seq, *) then pending_vars_used(expr.seq, pending) else []} &
                    pending_vars_used(expr.idx, pending),
    get_size(e?)  = if not pending(e, *) then pending_vars_used(e, pending) else [],
    _             = search_nested(expr, pending_vars_used($, pending));

  //////////////////////////////////////////////////////////////////////////////

  Instr rewrite_seq_ops(Instr instr, [StdVar -> LowLevelEltRepr] pending) {
    if instr :: <set_rc_var(var: StdVar, value: append_to_seq(seq: StdVar, new_elem: AtomicExpr))>:
      if instr.var == instr.value.seq and pending(instr.var, *):
        // set_rc_var(var: var(ys), value: append_to_seq(seq: var(ys), new_elem: var(x)))
        // array_append(
        //   array_var: shadow_array_var(id: ys, repr: object),
        //   size_var:  shadow_array_size_var(ys),
        //   value:     var(x)
        // )
        var_id = bare_id(instr.var);
        return array_append(
          shadow_array_var(var_id, pending(instr.var)),
          shadow_array_size_var(var_id),
          instr.value.new_elem
        );
      ;
    ;
    return rewrite_nested(instr, rewrite_seq_ops($, pending), rewrite_seq_ops($, pending));
  }


  AnyTypeExpr rewrite_seq_ops(AnyTypeExpr expr, [StdVar -> LowLevelEltRepr] pending) {
    if expr :: <at(seq: StdVar, idx: IntExpr)>:
      seq_var = expr.seq;
      if pending(seq_var, *):
        var_id = bare_id(seq_var);
        rw_idx = cast_int_expr(rewrite_nested(expr.idx, rewrite_seq_ops($, pending)));
        return array_at(shadow_array_var(var_id, pending(seq_var)), shadow_array_size_var(var_id), rw_idx);
      ;
    ;

    if expr :: <get_size(StdVar)>:
      seq_var = untag(expr);
      if pending(seq_var, *):
        return shadow_array_size_var(untag(seq_var));
      ;
    ;

    return rewrite_nested(expr, rewrite_seq_ops($, pending));
  }
}
