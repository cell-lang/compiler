CompiledPrg optimize_by_tracking_surrs_membs(CompiledPrg prg) {
  opt_static_blocks = [optimize_static_block(b) : b <- prg.static_blocks];
  return compiled_prg(
    typedefs:       prg.typedefs,
    opt_reprs:      prg.opt_reprs,
    bool_procs:     prg.bool_procs,
    procs:          prg.procs,
    react_blocks:   prg.react_blocks,
    static_blocks:  [optimize_static_block_by_tracking_surrs_membs(b) : b <- prg.static_blocks],
    int_seqs:       prg.int_seqs
  );
}


StaticBlock optimize_static_block_by_tracking_surrs_membs(StaticBlock block) {
  let cols_subset_map = block.cols_subset_map, value_stores_owners = block.value_stores_owners {
    opt_methods = [id -> optimize_static_block_method_by_tracking_surrs_membs(def) : id def <- block.methods];
    opt_handlers = [id -> optimize_static_block_handler_by_tracking_surrs_membs(def) : id def <- block.handlers];
  }

  return static_block(
    name:                         block.name,
    links:                        block.links,
    state_vars:                   block.state_vars,
    value_stores:                 block.value_stores,
    value_stores_owners:          block.value_stores_owners,
    tables:                       block.tables,
    foreign_keys:                 block.foreign_keys,
    cols_subset_map:              block.cols_subset_map,
    init_code:                    block.init_code,
    cleanup_code:                 block.cleanup_code,
    copy_state_code:              block.copy_state_code,
    set_state_code:               block.set_state_code,
    memb_var_check_exprs:         block.memb_var_check_exprs,
    rel_vars_load_code:           block.rel_vars_load_code,
    foreign_keys_check_code:      block.foreign_keys_check_code,
    methods:                      opt_methods,
    handlers:                     opt_handlers,
    handler_dispatch_resolver:    block.handler_dispatch_resolver,
    exported_handlers:            block.exported_handlers,
    msg_memb_pred:                block.msg_memb_pred
  );
}

////////////////////////////////////////////////////////////////////////////////

implicit cols_subset_map : [PhysCol, PhysCol], value_stores_owners : [ValueStoreId -> PhysCol] {
  OptCompMethod optimize_static_block_method_by_tracking_surrs_membs(OptCompMethod method) {
    opt_body = optimize_by_tracking_surrs_membs(method.body, [], []);
    return opt_comp_method(
      args:             method.args,
      args_types:       method.args_types,
      args_memb_preds:  method.args_memb_preds,
      loc_vars_types:   method.loc_vars_types,
      ret_type:         method.ret_type,
      ret_val_repr:     method.ret_val_repr,
      body:             opt_body
    );

  }


  CompiledHandler optimize_static_block_handler_by_tracking_surrs_membs(CompiledHandler handler) {
    opt_body = optimize_by_tracking_surrs_membs(handler.body, [], []);
    return compiled_handler(handler.msg_type, opt_body);
  }

  //////////////////////////////////////////////////////////////////////////////

  () optimize_by_tracking_surrs_membs((), [Int32Var, PhysCol], [Int32Var, PhysCol]) = ();

  Instr+ optimize_by_tracking_surrs_membs(Instr+ instrs, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
    curr_membs = memberships;
    curr_maybe_membs = maybe_memberships;
    opt_instrs = ();
    for instr <- instrs {
      opt_instr = optimize_by_tracking_surrs_membs(instr, curr_membs, curr_maybe_membs);
      opt_instrs = (opt_instrs | opt_instr);
      curr_membs, curr_maybe_membs = updated_memberships(instr, curr_membs, curr_maybe_membs);
    }
    return nonempty(opt_instrs);
  }

  //////////////////////////////////////////////////////////////////////////////

  ([Int32Var, PhysCol], [Int32Var, PhysCol]) updated_memberships(Instr* instrs, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
    curr_membs = memberships;
    curr_maybe_membs = maybe_memberships;
    for instr <- instrs
      curr_membs, curr_maybe_membs = updated_memberships(instr, curr_membs, curr_maybe_membs);
    return (curr_membs, curr_maybe_membs);
  }


  ([Int32Var, PhysCol], [Int32Var, PhysCol]) updated_memberships(Instr instr, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
    return match (instr)
        set_ivar32()  = set_ivar32_updated_memberships(instr.var, instr.value, memberships, maybe_memberships),
        branch()      = branch_updated_memberships(instr.cond, instr.when_true, instr.when_false, memberships, maybe_memberships),
        _             = (memberships, maybe_memberships);


    ([Int32Var, PhysCol], [Int32Var, PhysCol]) set_ivar32_updated_memberships(Int32Var var, Int32Expr value, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      membs = [v, c : v c <- memberships, v != var];
      maybe_membs = [v, c : v c <- maybe_memberships, v != var];
      if value :: Int32Var and var != value {
        new_membs = [var, c : c <- memberships(value, ?)];
        membs = union(membs, new_membs);
        new_maybe_membs = [var, c : c <- maybe_memberships(value, ?)];
        maybe_membs = union(maybe_membs, new_maybe_membs);
      }
      else {
        new_maybe_membs = match (value)
          ## TODO TODO TODO: EXTEND THE TRACKING TO DEPENDEE'S VALUE STORES
          // value_to_surr() = [var -> value_stores_owners(value.store) if is_value_store_id(value.store)],
          ## BAD BAD BAD: IMPROVE THE TYPE INFERENCE SO THAT THE ABOVE LINE OF CODE IS ACCEPTED
          value_to_surr() = {store = value.store; return [var -> value_stores_owners(store) if is_value_store_id(store)];},
          _               = [];
        maybe_membs = union(maybe_membs, new_maybe_membs);
      }
      return (membs, maybe_membs);
    }


    ([Int32Var, PhysCol], [Int32Var, PhysCol]) branch_updated_memberships(BoolExpr cond, Instr+ when_true, Instr* when_false, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      then_branch_entry_membs, then_branch_entry_maybe_membs = updated_memberships_when_true(cond, memberships, maybe_memberships);
      else_branch_entry_membs, else_branch_entry_maybe_membs = updated_memberships_when_false(cond, memberships, maybe_memberships);

      then_branch_exit_membs, then_branch_exit_maybe_membs = updated_memberships(when_true, then_branch_entry_membs, then_branch_entry_maybe_membs);
      else_branch_exit_membs, else_branch_exit_maybe_membs = updated_memberships(when_true, else_branch_entry_membs, else_branch_entry_maybe_membs);

      then_branch_outcomes = code_outcomes(when_true);
      else_branch_outcomes = code_outcomes(when_false);

      if then_branch_outcomes(falls_through)
        if else_branch_outcomes(falls_through)
          return merge_memberships(then_branch_exit_membs, then_branch_exit_maybe_membs, else_branch_exit_membs, else_branch_exit_maybe_membs);
        else
          return (then_branch_exit_membs, then_branch_exit_maybe_membs);
      else
        if else_branch_outcomes(falls_through)
          return (else_branch_exit_membs, else_branch_exit_maybe_membs);
        else
          return ([], []); ## SHOULD I FAIL HERE INSTEAD?
    }


    ([Int32Var, PhysCol], [Int32Var, PhysCol]) updated_memberships_when_true(BoolExpr cond, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      return (memberships, maybe_memberships);
    }


    ([Int32Var, PhysCol], [Int32Var, PhysCol]) updated_memberships_when_false(BoolExpr cond, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      return match (cond)
        are_eq(int_obj(upcast_int32(e?)), int_obj(-1))  = if e :: Int32Var and maybe_memberships(e, _) then
                                                            ( union(memberships, [e, c : c <- maybe_memberships(e, ?)]),
                                                              [v, c : v c <- maybe_memberships, v != e]
                                                            )
                                                          else (memberships, maybe_memberships),
        _                                               = (memberships, maybe_memberships);
    }

    ////////////////////////////////////////////////////////////////////////////

    ([Int32Var, PhysCol], [Int32Var, PhysCol]) merge_memberships([Int32Var, PhysCol] membs_1, [Int32Var, PhysCol] maybe_membs_1, [Int32Var, PhysCol] membs_2, [Int32Var, PhysCol] maybe_membs_2) {
      membs = ();
      maybe_membs = ();

      for v c <- membs_1 {
        if membs_2(v, c)
          membs = (membs | (v, c));
        else if maybe_membs_2(v, c)
          maybe_membs = (maybe_membs | (v, c));
      }

      for v c <- membs_2
        if maybe_membs_1(v, c)
          maybe_membs = (maybe_membs | (v, c));

      for v c <- maybe_membs_1
        if maybe_membs_2(v, c)
          maybe_membs = (maybe_membs | (v, c));

      return ([v, c : (v, c) <- membs], [v, c : (v, c) <- maybe_membs]);
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  JumpInstr optimize_by_tracking_surrs_membs(JumpInstr instr, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) =
    ret_val(e?)   = ret_val(optimize_by_tracking_surrs_membs(e, memberships)),
    _             = instr;


  BasicInstr optimize_by_tracking_surrs_membs(BasicInstr instr, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) =
    rewrite_exprs(instr, optimize_by_tracking_surrs_membs($, memberships), rewrite_nested($, optimize_by_tracking_surrs_membs($, memberships)));


  AnyTypeExpr optimize_by_tracking_surrs_membs(AnyTypeExpr expr, [Int32Var, PhysCol] memberships) {
    return match (expr)
      column_lookup()                                 = if not expr.safe and expr.var :: TableVar and expr.column :: MandatoryColumn
                                                          then optimize_column_lookup(expr.var, expr.column, expr.key, memberships)
                                                          else expr,
      are_eq(int_obj(upcast_int32(v?)), int_obj(-1))  = if memberships(v, _) then false else expr,
      _                                               = rewrite_nested(expr, optimize_by_tracking_surrs_membs($, memberships));


    ObjNatOp optimize_column_lookup(TableVar var, MandatoryColumn column, Int32Var key, [Int32Var, PhysCol] memberships) {
      safe_cols = follow([c : c <- memberships(key, ?)], cols_subset_map);
      phys_col = phys_col(var, 0);
      return column_lookup(var, column, key, safe_cols(phys_col));
    }
  }


  CompInstr optimize_by_tracking_surrs_membs(CompInstr instr, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
    return match (instr)
      branch()            = optimized_branch(instr.cond, instr.when_true, instr.when_false, memberships, maybe_memberships),
      switch_on_nat()     = optimized_switch_on_nat(instr.value, instr.cases, memberships, maybe_memberships),
      symb_switch()       = optimized_symb_switch(instr.value, instr.cases, instr.else, memberships, maybe_memberships),
      repeat(is?)         = repeat(optimize_by_tracking_surrs_membs(is, memberships, maybe_memberships)),
      execute_block(is?)  = execute_block(optimize_by_tracking_surrs_membs(is, memberships, maybe_memberships)),
      try_block()         = instr,
      foreach()           = optimized_foreach(instr.iter, instr.body, memberships, maybe_memberships);


    CompInstr optimized_branch(BoolExpr cond, Instr+ when_true, Instr* when_false, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      opt_cond = cast_bool_expr(optimize_by_tracking_surrs_membs(cond, memberships));
      opt_then_branch = optimize_by_tracking_surrs_membs(when_true, memberships, maybe_memberships);
      opt_else_branch = optimize_by_tracking_surrs_membs(when_false, memberships, maybe_memberships);
      return branch(opt_cond, opt_then_branch, opt_else_branch);
    }


    CompInstr optimized_switch_on_nat(IntExpr value, Instr*+ cases, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      opt_cases = (optimize_by_tracking_surrs_membs(c, memberships, maybe_memberships) : c <- cases);
      return switch_on_nat(value, opt_cases);
    }


    CompInstr optimized_symb_switch(ObjExpr value, [+([+SymbObj], Instr+)] cases, Instr* else, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      opt_cases = [(c(0), optimize_by_tracking_surrs_membs(c(1), memberships, maybe_memberships)) : c <- cases];
      opt_else = optimize_by_tracking_surrs_membs(else, memberships, maybe_memberships);
      return symb_switch(value, opt_cases, else);
    }

    CompInstr optimized_foreach(ForeachIter iter, Instr* body, [Int32Var, PhysCol] memberships, [Int32Var, PhysCol] maybe_memberships) {
      body_memberships = updated_memberships(iter, memberships);
      opt_body = optimize_by_tracking_surrs_membs(body, body_memberships, maybe_memberships);
      return foreach(iter, opt_body);
    }

    ////////////////////////////////////////////////////////////////////////////

    [Int32Var, PhysCol] updated_memberships(SeqIter iter, [Int32Var, PhysCol] memberships) = memberships;


    // type UnaryTableIter       = unary_table_iter(table_var: AnyTableVar, var: Int32Var?);
    [Int32Var, PhysCol] updated_memberships(UnaryTableIter iter, [Int32Var, PhysCol] memberships) {
      assert not (iter.var? and memberships(iter.var, _));

      if iter.var? and iter.table_var :: TableVar
        return union(memberships, [iter.var -> phys_col(iter.table_var, 0)]);
      else
        return memberships;
    }

    // type BinTableIter         = bin_table_iter(
    //                               table_var:  AnyTableVar,
    //                               table:      Table,
    //                               args:       (TableArgStatus, TableArgStatus)
    //                             );
    [Int32Var, PhysCol] updated_memberships(BinTableIter iter, [Int32Var, PhysCol] memberships) {
      body_memberships = memberships;
      if iter.table_var :: TableVar {
        for a @ i <- iter.args
          body_memberships = updated_memberships(a, i, iter.table_var, body_memberships);
      }
      return body_memberships;
    }

    // type SymBinTableIter      = sym_bin_table_iter(
    //                               table_var:  AnyTableVar,
    //                               table:      Table,
    //                               args:       (TableArgStatus, TableArgStatus)
    //                             );
    [Int32Var, PhysCol] updated_memberships(SymBinTableIter iter, [Int32Var, PhysCol] memberships) {
      return memberships;
    }

    // type MasterBinTableIter   = master_bin_table_iter(
    //                               table_var:  AnyTableVar,
    //                               table:      MasterBinTable,
    //                               args:       (TableArgStatus, TableArgStatus),
    //                               surr_var:   Int32Var?
    //                             );
    [Int32Var, PhysCol] updated_memberships(MasterBinTableIter iter, [Int32Var, PhysCol] memberships) {
      body_memberships = memberships;
      if iter.table_var :: TableVar {
        for a @ i <- iter.args
          body_memberships = updated_memberships(a, i, iter.table_var, body_memberships);
        ## BAD BAD BAD: WE'RE NOT CONSIDERING THE ASSOCIATIVE SURROGATE
      }
      return body_memberships;
    }

    // type SlaveTernTableIter   = slave_tern_table_iter(
    //                               table_var:  AnyTableVar,
    //                               table:      SlaveTernTable,
    //                               args:       (TableArgStatus, TableArgStatus)
    //                             );
    [Int32Var, PhysCol] updated_memberships(SlaveTernTableIter iter, [Int32Var, PhysCol] memberships) {
      if iter.table_var :: TableVar {
        ## BAD BAD BAD: WE'RE NOT CONSIDERING THE ASSOCIATIVE SURROGATE
        return updated_memberships(iter.args(1), 1, iter.table_var, memberships);
      }
      else
        return memberships;
    }

    // type TernTableIter        = tern_table_iter(
    //                               table_var:  AnyTableVar,
    //                               table:      Table,
    //                               args:       (TableArgStatus, TableArgStatus, TableArgStatus)
    //                             );
    [Int32Var, PhysCol] updated_memberships(TernTableIter iter, [Int32Var, PhysCol] memberships) {
      body_memberships = memberships;
      if iter.table_var :: TableVar {
        for a @ i <- iter.args
          body_memberships = updated_memberships(a, i, iter.table_var, body_memberships);
      }
      return body_memberships;
    }

    // type SemiSymTernTableIter = semi_sym_tern_table_iter(
    //                               table_var:  AnyTableVar,
    //                               table:      Table,
    //                               args:       (TableArgStatus, TableArgStatus, TableArgStatus)
    //                             );
    [Int32Var, PhysCol] updated_memberships(SemiSymTernTableIter iter, [Int32Var, PhysCol] memberships) {
      return memberships;
    }
  }
}


[Int32Var, PhysCol] updated_memberships(TableArgStatus status, Nat index, TableVar table_var, [Int32Var, PhysCol] memberships) =
  read(v?)  = {
    assert not memberships(v, _);
    phys_col = phys_col(table_var, index);
    return union(memberships, [v -> phys_col]);
  },
  bound()   |
  ignored   = memberships;
